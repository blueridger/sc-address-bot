#!/usr/bin/env node
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/cli/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, description, homepage, repository, version, private, dependencies, devDependencies, greenkeeper, scripts, engines, license, jest, files, main, browser, module, bin, gitHead, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"sourcecred\\\",\\\"description\\\":\\\"a tool for communities to measure and reward value creation\\\",\\\"homepage\\\":\\\"https://sourcecred.io\\\",\\\"repository\\\":\\\"github:sourcecred/sourcecred\\\",\\\"version\\\":\\\"0.10.2\\\",\\\"private\\\":false,\\\"dependencies\\\":{\\\"@aws-sdk/util-base64-browser\\\":\\\"^3.37.0\\\",\\\"@date-io/date-fns\\\":\\\"1.3.11\\\",\\\"@material-ui/core\\\":\\\"^4.11.2\\\",\\\"@material-ui/icons\\\":\\\"^4.11.2\\\",\\\"@material-ui/lab\\\":\\\"^4.0.0-alpha.56\\\",\\\"@material-ui/pickers\\\":\\\"3.3.10\\\",\\\"@sourcecred/grain-integration-csv\\\":\\\"^0.0.1\\\",\\\"@walletconnect/web3-provider\\\":\\\"^1.4.1\\\",\\\"aphrodite\\\":\\\"^2.4.0\\\",\\\"babel-plugin-transform-flow-strip-types\\\":\\\"^6.22.0\\\",\\\"base-64\\\":\\\"^1.0.0\\\",\\\"base64url\\\":\\\"^3.0.1\\\",\\\"better-sqlite3\\\":\\\"^7.0.0\\\",\\\"big-integer\\\":\\\"^1.6.48\\\",\\\"bottleneck\\\":\\\"^2.19.5\\\",\\\"chalk\\\":\\\"^4.0.0\\\",\\\"classnames\\\":\\\"~2.2.5\\\",\\\"commonmark\\\":\\\"0.29.1\\\",\\\"cross-fetch\\\":\\\"^3.0.6\\\",\\\"d3-array\\\":\\\"^2.4.0\\\",\\\"d3-format\\\":\\\"^2.0.0\\\",\\\"d3-scale\\\":\\\"^3.2.1\\\",\\\"d3-scale-chromatic\\\":\\\"^2.0.0\\\",\\\"d3-shape\\\":\\\"^2.0.0\\\",\\\"d3-time\\\":\\\"^2.0.0\\\",\\\"d3-time-format\\\":\\\"^3.0.0\\\",\\\"date-fns\\\":\\\"2.23.0\\\",\\\"deep-freeze\\\":\\\"^0.0.1\\\",\\\"entities\\\":\\\"^2.0.0\\\",\\\"ethers\\\":\\\"^5.2.0\\\",\\\"express\\\":\\\"^4.17.1\\\",\\\"fs-extra\\\":\\\"^10.0.0\\\",\\\"globby\\\":\\\"^11.0.0\\\",\\\"history\\\":\\\"^5.0.0\\\",\\\"htmlparser2\\\":\\\"^6.0.0\\\",\\\"isomorphic-fetch\\\":\\\"^3.0.0\\\",\\\"json-stable-stringify\\\":\\\"^1.0.1\\\",\\\"json2csv\\\":\\\"^5.0.6\\\",\\\"lodash.clonedeep\\\":\\\"^4.5.0\\\",\\\"lodash.differenceby\\\":\\\"^4.8.0\\\",\\\"lodash.findlast\\\":\\\"^4.6.0\\\",\\\"lodash.findlastindex\\\":\\\"^4.6.0\\\",\\\"lodash.isequal\\\":\\\"^4.5.0\\\",\\\"lodash.sortby\\\":\\\"^4.7.0\\\",\\\"lodash.sortedindex\\\":\\\"^4.1.0\\\",\\\"object-assign\\\":\\\"^4.1.1\\\",\\\"pako\\\":\\\"^2.0.3\\\",\\\"promise\\\":\\\"^8.1.0\\\",\\\"ra-core\\\":\\\"^3.13.4\\\",\\\"ra-data-fakerest\\\":\\\"^3.6.2\\\",\\\"ra-ui-materialui\\\":\\\"^3.13.4\\\",\\\"react\\\":\\\"^16.13.0\\\",\\\"react-admin\\\":\\\"^3.6.2\\\",\\\"react-dom\\\":\\\"^16.13.0\\\",\\\"react-icons\\\":\\\"^4.1.0\\\",\\\"react-markdown\\\":\\\"^4.3.1\\\",\\\"react-router\\\":\\\"^5.2.0\\\",\\\"react-router-dom\\\":\\\"^5.2.0\\\",\\\"remove-markdown\\\":\\\"^0.3.0\\\",\\\"rimraf\\\":\\\"^3.0.2\\\",\\\"svg-react-loader\\\":\\\"^0.4.6\\\",\\\"tmp\\\":\\\"0.2.1\\\",\\\"web3-utils\\\":\\\"^1.3.0\\\",\\\"web3modal\\\":\\\"^1.9.3\\\"},\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.8.7\\\",\\\"@babel/node\\\":\\\"^7.8.7\\\",\\\"@babel/plugin-proposal-class-properties\\\":\\\"^7.8.3\\\",\\\"@babel/plugin-syntax-bigint\\\":\\\"^7.8.3\\\",\\\"@babel/preset-env\\\":\\\"^7.8.7\\\",\\\"@babel/preset-flow\\\":\\\"^7.8.3\\\",\\\"@babel/preset-react\\\":\\\"^7.8.3\\\",\\\"babel-eslint\\\":\\\"^10.1.0\\\",\\\"babel-jest\\\":\\\"^26.0.1\\\",\\\"babel-loader\\\":\\\"^8.0.6\\\",\\\"copy-webpack-plugin\\\":\\\"^6.1.0\\\",\\\"css-loader\\\":\\\"^5.0.0\\\",\\\"dotenv\\\":\\\"^9.0.0\\\",\\\"dotenv-expand\\\":\\\"^5.1.0\\\",\\\"enzyme\\\":\\\"^3.11.0\\\",\\\"enzyme-adapter-react-16\\\":\\\"^1.15.2\\\",\\\"enzyme-to-json\\\":\\\"^3.4.4\\\",\\\"eslint\\\":\\\"^7.8.1\\\",\\\"eslint-plugin-flowtype\\\":\\\"^5.2.0\\\",\\\"eslint-plugin-import\\\":\\\"^2.20.1\\\",\\\"eslint-plugin-react\\\":\\\"7.23.2\\\",\\\"file-loader\\\":\\\"^6.0.0\\\",\\\"flow-bin\\\":\\\"^0.135.0\\\",\\\"jest\\\":\\\"^26.0.1\\\",\\\"jest-fetch-mock\\\":\\\"^3.0.2\\\",\\\"jsdoc\\\":\\\"^3.6.6\\\",\\\"jsdoc-babel\\\":\\\"^0.5.0\\\",\\\"jsdoc-to-markdown\\\":\\\"^6.0.1\\\",\\\"npm-run-all\\\":\\\"^4.1.5\\\",\\\"null-loader\\\":\\\"^4.0.0\\\",\\\"postinstall-postinstall\\\":\\\"^2.1.0\\\",\\\"prettier\\\":\\\"^2.0.1\\\",\\\"raf\\\":\\\"^3.4.1\\\",\\\"react-dev-utils\\\":\\\"^11.0.0\\\",\\\"static-site-generator-webpack-plugin\\\":\\\"^3.4.2\\\",\\\"url-loader\\\":\\\"^4.0.0\\\",\\\"webpack\\\":\\\"^4.42.0\\\",\\\"webpack-cli\\\":\\\"^4.4.0\\\",\\\"webpack-dev-server\\\":\\\"^3.10.3\\\",\\\"webpack-manifest-plugin\\\":\\\"^3.0.0\\\",\\\"webpack-node-externals\\\":\\\"^3.0.0\\\"},\\\"greenkeeper\\\":{\\\"ignore\\\":[\\\"history\\\",\\\"react-dev-utils\\\",\\\"react-router\\\",\\\"tmp\\\"]},\\\"scripts\\\":{\\\"prettify\\\":\\\"prettier --write '**/*.{js,md,yml}'\\\",\\\"check-pretty\\\":\\\"prettier --list-different '**/*.{js,md,yml}'\\\",\\\"start\\\":\\\"./scripts/devServer.sh\\\",\\\"build\\\":\\\"run-p build:* && cp -r ./build ./bin/site-template && chmod +x ./bin/sourcecred.js\\\",\\\"build:frontend\\\":\\\"NODE_ENV=production webpack --config config/webpack.config.web.js\\\",\\\"build:backend\\\":\\\"NODE_ENV=development webpack --config config/webpack.config.backend.js\\\",\\\"build:api\\\":\\\"NODE_ENV=production webpack --config config/webpack.config.api.js\\\",\\\"test\\\":\\\"node ./config/test.js\\\",\\\"createLedger\\\":\\\"babel-node ./scripts/createLedgerFromLegacyProject.js\\\",\\\"unit\\\":\\\"BABEL_ENV=test NODE_ENV=test jest\\\",\\\"sharness\\\":\\\"make -sC ./sharness prove PROVE_OPTS=-f TEST_OPTS='--chain-lint'\\\",\\\"sharness-full\\\":\\\"make -sC ./sharness prove PROVE_OPTS=-vf TEST_OPTS='-v --chain-lint --long'\\\",\\\"coverage\\\":\\\"yarn run unit --coverage\\\",\\\"flow\\\":\\\"flow\\\",\\\"lint\\\":\\\"eslint src config --max-warnings 0\\\",\\\"prepublishOnly\\\":\\\"yarn build\\\",\\\"docs\\\":\\\"bash ../../scripts/generate-docs.sh ./src/api/lib\\\",\\\"shell\\\":\\\"node ./scripts/shell.js\\\"},\\\"engines\\\":{\\\"node\\\":\\\">=12\\\"},\\\"license\\\":\\\"(MIT OR Apache-2.0)\\\",\\\"jest\\\":{\\\"collectCoverageFrom\\\":[\\\"src/**/*.{js,jsx,mjs}\\\"],\\\"setupFiles\\\":[\\\"<rootDir>/config/polyfills.js\\\",\\\"<rootDir>/config/jest/setupJest.js\\\"],\\\"testMatch\\\":[\\\"<rootDir>/src/**/__tests__/**/*.{js,jsx,mjs}\\\",\\\"<rootDir>/src/**/?(*.)(spec|test).{js,jsx,mjs}\\\"],\\\"testEnvironment\\\":\\\"node\\\",\\\"testURL\\\":\\\"http://localhost\\\",\\\"transform\\\":{\\\"^.+\\\\\\\\.(js|jsx|mjs)$\\\":\\\"<rootDir>/node_modules/babel-jest\\\",\\\"^.+\\\\\\\\.css$\\\":\\\"<rootDir>/config/jest/cssTransform.js\\\",\\\"^(?!.*\\\\\\\\.(js|jsx|mjs|css|json)$)\\\":\\\"<rootDir>/config/jest/fileTransform.js\\\"},\\\"transformIgnorePatterns\\\":[\\\"[/\\\\\\\\\\\\\\\\]node_modules[/\\\\\\\\\\\\\\\\].+\\\\\\\\.(js|jsx|mjs)$\\\"],\\\"moduleNameMapper\\\":{\\\"^react-native$\\\":\\\"react-native-web\\\"},\\\"moduleFileExtensions\\\":[\\\"web.js\\\",\\\"js\\\",\\\"json\\\",\\\"web.jsx\\\",\\\"jsx\\\",\\\"node\\\",\\\"mjs\\\"]},\\\"files\\\":[\\\"/bin\\\",\\\"/dist\\\",\\\"/src\\\",\\\"!src/**/*.test.js?(.snap)\\\",\\\"!src/ui\\\"],\\\"main\\\":\\\"dist/server/api.js\\\",\\\"browser\\\":\\\"dist/client/api.js\\\",\\\"module\\\":\\\"dist/module/api.js\\\",\\\"bin\\\":\\\"./bin/sourcecred.js\\\",\\\"gitHead\\\":\\\"4effd927d59d4007a8322d0cb881011ac098fc72\\\"}\");\n\n//# sourceURL=webpack:///./package.json?");

/***/ }),

/***/ "./src/analysis/pluginDeclaration.js":
/*!*******************************************!*\
  !*** ./src/analysis/pluginDeclaration.js ***!
  \*******************************************/
/*! exports provided: declarationParser, combineTypes, weightsForDeclaration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"declarationParser\", function() { return declarationParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"combineTypes\", function() { return combineTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"weightsForDeclaration\", function() { return weightsForDeclaration; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/analysis/types.js\");\n/* harmony import */ var _core_weights__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/weights */ \"./src/core/weights.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n// TODO(@decentralion): Maybe merge this file with analysis/types\nconst declarationParser=_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"object\"]({name:_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"string\"],nodePrefix:_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].parser,edgePrefix:_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].parser,nodeTypes:_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"array\"](_types__WEBPACK_IMPORTED_MODULE_1__[\"nodeTypeParser\"]),edgeTypes:_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"array\"](_types__WEBPACK_IMPORTED_MODULE_1__[\"edgeTypeParser\"]),userTypes:_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"array\"](_types__WEBPACK_IMPORTED_MODULE_1__[\"nodeTypeParser\"])});function combineTypes(decs){const nodeTypes=[].concat(...decs.map(x=>x.nodeTypes));const edgeTypes=[].concat(...decs.map(x=>x.edgeTypes));return{nodeTypes,edgeTypes};}function weightsForDeclaration(dec){const weights=_core_weights__WEBPACK_IMPORTED_MODULE_2__[\"empty\"]();const{nodeTypes,edgeTypes}=dec;for(const{prefix,defaultWeight}of nodeTypes){weights.nodeWeights.set(prefix,defaultWeight);}for(const{prefix,defaultWeight}of edgeTypes){weights.edgeWeights.set(prefix,defaultWeight);}return weights;}\n\n//# sourceURL=webpack:///./src/analysis/pluginDeclaration.js?");

/***/ }),

/***/ "./src/analysis/types.js":
/*!*******************************!*\
  !*** ./src/analysis/types.js ***!
  \*******************************/
/*! exports provided: nodeTypeParser, edgeTypeParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodeTypeParser\", function() { return nodeTypeParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeTypeParser\", function() { return edgeTypeParser; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _core_weights__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/weights */ \"./src/core/weights.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/**\n * This module defines `NodeType`s and `EdgeType`s, both of which are\n * data structures containing shared metadata that describes many nodes or edges\n * in the graph. Nodes can be \"members\" of zero or more `NodeType`s, and edges can\n * be \"members\" of zero or more `EdgeType`s. Membership is determined based on the\n * type's `prefix`, which is an address. A node or edge is considered a member of\n * a type if that type's prefix is a prefix of the node's address.\n *\n * To make this more concrete, let's consider a specific example. Suppose we define\n * the following nodes:\n *\n * const pullNode = NodeAddress.fromParts([\"github\", \"pull\", \"repo\", \"34\"]);\n * const commitNode = NodeAddress.fromParts([\"git\", \"commit\", \"e1337\"]);\n * const pullType: NodeType = {\n *  name: \"Pull request\",\n *  prefix: NodeAddress.fromParts([\"github\", \"pull\"]),\n *  // ... more properties as required\n * };\n * const githubType: NodeType = {\n *   name: \"GitHub node\",\n *   prefix: NodeAddress.fromParts([\"github\"])\n * };\n *\n * Then the `pullNode` is considered a member of the `pullType` and `githubType`,\n * while the `commitNode` is not a member of either type.\n *\n * The concept of a \"type\" is useful to SourceCred because it let's us express\n * that groups of nodes are conceptually related, and that we should treat them similarly.\n * Most saliently, we use types to assign default weights to groups of nodes, and to\n * aggregate them for better UI organization. The fact that the SourceCred UI can group\n * all pull requests together, and assign a default weight to all of them, is possible\n * because the GitHub plugin defines a pull request node type.\n *\n * While a node or edge can theoretically be a member of multiple types, in practice we\n * generally treat the node or edge as though it is only a member of its most specific type.\n * In the example above, we would treat any individual pull request as though it is only\n * a member of the pull request node type. That may change in the future. In general,\n * the type system is not wholly finalized; when it does become finalized, we will\n * likely move it into src/core. See [#710] for context.\n *\n * [#710]: https://github.com/sourcecred/sourcecred/issues/710\n */ /**\n * Represents a \"Type\" of node in the graph. See the module docstring\n * for context.\n */const nodeTypeParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({name:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"string\"],pluralName:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"string\"],prefix:_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].parser,defaultWeight:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],description:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"string\"]});/**\n * Represents a \"Type\" of edge in the graph. See the module docstring\n * for context.\n */const edgeTypeParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({forwardName:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"string\"],backwardName:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"string\"],defaultWeight:_core_weights__WEBPACK_IMPORTED_MODULE_1__[\"edgeWeightParser\"],prefix:_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].parser,description:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"string\"]});\n\n//# sourceURL=webpack:///./src/analysis/types.js?");

/***/ }),

/***/ "./src/api/bundledDeclarations.js":
/*!****************************************!*\
  !*** ./src/api/bundledDeclarations.js ***!
  \****************************************/
/*! exports provided: getPluginDeclaration, upgradeRawInstanceConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPluginDeclaration\", function() { return getPluginDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"upgradeRawInstanceConfig\", function() { return upgradeRawInstanceConfig; });\n/* harmony import */ var _plugins_github_declaration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../plugins/github/declaration */ \"./src/plugins/github/declaration.js\");\n/* harmony import */ var _plugins_discourse_declaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugins/discourse/declaration */ \"./src/plugins/discourse/declaration.js\");\n/* harmony import */ var _plugins_discord_declaration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../plugins/discord/declaration */ \"./src/plugins/discord/declaration.js\");\n/* harmony import */ var _plugins_initiatives_declaration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../plugins/initiatives/declaration */ \"./src/plugins/initiatives/declaration.js\");\n/* harmony import */ var _plugins_ethereum_declaration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../plugins/ethereum/declaration */ \"./src/plugins/ethereum/declaration.js\");\n/* harmony import */ var _pluginId__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pluginId */ \"./src/api/pluginId.js\");\n/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/storage */ \"./src/core/storage/index.js\");\n/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_core_storage__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _plugins_external_plugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../plugins/external/plugin */ \"./src/plugins/external/plugin.js\");\nasync function getPluginDeclaration(pluginId,storage){const mapping={\"sourcecred/github\":_plugins_github_declaration__WEBPACK_IMPORTED_MODULE_0__[\"declaration\"],\"sourcecred/discourse\":_plugins_discourse_declaration__WEBPACK_IMPORTED_MODULE_1__[\"declaration\"],\"sourcecred/discord\":_plugins_discord_declaration__WEBPACK_IMPORTED_MODULE_2__[\"declaration\"],\"sourcecred/initiatives\":_plugins_initiatives_declaration__WEBPACK_IMPORTED_MODULE_3__[\"declaration\"],\"sourcecred/ethereum\":_plugins_ethereum_declaration__WEBPACK_IMPORTED_MODULE_4__[\"declaration\"]};if(mapping[pluginId.toString()])return mapping[pluginId.toString()];if(Object(_pluginId__WEBPACK_IMPORTED_MODULE_5__[\"getPluginOwner\"])(pluginId)===_plugins_external_plugin__WEBPACK_IMPORTED_MODULE_7__[\"ExternalPluginIdOwner\"])return await new _plugins_external_plugin__WEBPACK_IMPORTED_MODULE_7__[\"ExternalPlugin\"]({pluginId,storage}).declaration();throw\"Bad declaration: \"+JSON.stringify(pluginId);}async function upgradeRawInstanceConfig(raw,storage){const bundledPlugins=new Map();for(const id of raw.bundledPlugins){const plugin=await getPluginDeclaration(id,storage);if(plugin==null){throw new Error(\"bad bundled declaration: \"+JSON.stringify(id));}bundledPlugins.set(id,plugin);}return bundledPlugins;}\n\n//# sourceURL=webpack:///./src/api/bundledDeclarations.js?");

/***/ }),

/***/ "./src/api/bundledGrainIntegrations.js":
/*!*********************************************!*\
  !*** ./src/api/bundledGrainIntegrations.js ***!
  \*********************************************/
/*! exports provided: bundledGrainIntegrations, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bundledGrainIntegrations\", function() { return bundledGrainIntegrations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _sourcecred_grain_integration_csv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sourcecred/grain-integration-csv */ \"@sourcecred/grain-integration-csv\");\n/* harmony import */ var _sourcecred_grain_integration_csv__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_sourcecred_grain_integration_csv__WEBPACK_IMPORTED_MODULE_1__);\nconst allowedDeclarations={\"csv\":_sourcecred_grain_integration_csv__WEBPACK_IMPORTED_MODULE_1__[\"csvIntegration\"]};function bundledGrainIntegrations(integrationKey){const integration=allowedDeclarations[integrationKey];if(!integration)throw new Error(\"grain integration not found; enter a valid `integration` value in config/grain.json\");return integration;}const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"exactly\"]([\"csv\"]),integrationKey=>({name:integrationKey,function:bundledGrainIntegrations(integrationKey)}));\n\n//# sourceURL=webpack:///./src/api/bundledGrainIntegrations.js?");

/***/ }),

/***/ "./src/api/bundledPlugins.js":
/*!***********************************!*\
  !*** ./src/api/bundledPlugins.js ***!
  \***********************************/
/*! exports provided: getPlugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPlugin\", function() { return getPlugin; });\n/* harmony import */ var _pluginId__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginId */ \"./src/api/pluginId.js\");\n/* harmony import */ var _plugins_github_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugins/github/plugin */ \"./src/plugins/github/plugin.js\");\n/* harmony import */ var _plugins_discourse_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../plugins/discourse/plugin */ \"./src/plugins/discourse/plugin.js\");\n/* harmony import */ var _plugins_discord_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../plugins/discord/plugin */ \"./src/plugins/discord/plugin.js\");\n/* harmony import */ var _plugins_initiatives_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../plugins/initiatives/plugin */ \"./src/plugins/initiatives/plugin.js\");\n/* harmony import */ var _plugins_ethereum_plugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../plugins/ethereum/plugin */ \"./src/plugins/ethereum/plugin.js\");\n/* harmony import */ var _plugins_external_plugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../plugins/external/plugin */ \"./src/plugins/external/plugin.js\");\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/storage/disk */ \"./src/core/storage/disk.js\");\n/**\n * Returns an object mapping owner-name pairs to CLI plugin\n * declarations; keys are like `sourcecred/github`.\n */ // TODO(@decentralion): Fix the type signature here.\nfunction getPlugin(pluginId){const mapping={\"sourcecred/github\":new _plugins_github_plugin__WEBPACK_IMPORTED_MODULE_1__[\"GithubPlugin\"](),\"sourcecred/discourse\":new _plugins_discourse_plugin__WEBPACK_IMPORTED_MODULE_2__[\"DiscoursePlugin\"](),\"sourcecred/discord\":new _plugins_discord_plugin__WEBPACK_IMPORTED_MODULE_3__[\"DiscordPlugin\"](),\"sourcecred/initiatives\":new _plugins_initiatives_plugin__WEBPACK_IMPORTED_MODULE_4__[\"InitiativesPlugin\"](),\"sourcecred/ethereum\":new _plugins_ethereum_plugin__WEBPACK_IMPORTED_MODULE_5__[\"EthereumPlugin\"]()};if(mapping[pluginId.toString()])return mapping[pluginId.toString()];if(Object(_pluginId__WEBPACK_IMPORTED_MODULE_0__[\"getPluginOwner\"])(pluginId)===_plugins_external_plugin__WEBPACK_IMPORTED_MODULE_6__[\"ExternalPluginIdOwner\"])return new _plugins_external_plugin__WEBPACK_IMPORTED_MODULE_6__[\"ExternalPlugin\"]({pluginId,storage:new _core_storage_disk__WEBPACK_IMPORTED_MODULE_7__[\"DiskStorage\"](process.cwd())});}\n\n//# sourceURL=webpack:///./src/api/bundledPlugins.js?");

/***/ }),

/***/ "./src/api/config/personalAttributionsConfig.js":
/*!******************************************************!*\
  !*** ./src/api/config/personalAttributionsConfig.js ***!
  \******************************************************/
/*! exports provided: updatePersonalAttributionsConfig, toPersonalAttributions, personalAttributionsConfigParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updatePersonalAttributionsConfig\", function() { return updatePersonalAttributionsConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toPersonalAttributions\", function() { return toPersonalAttributions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"personalAttributionsConfigParser\", function() { return personalAttributionsConfigParser; });\n/* harmony import */ var _core_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/identity */ \"./src/core/identity/index.js\");\n/* harmony import */ var _util_timestamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/timestamp */ \"./src/util/timestamp.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/**\n  Adds the IdentityIds where only IdentityNames are provided, and updates names\n  and ids to reflect the account's current identity after merging/renaming.\n */function updatePersonalAttributionsConfig(config,ledger){return config.map(_ref=>{var _ledger$accountByName;let{fromParticipantId,fromParticipantName,recipients}=_ref;const id=fromParticipantId?ledger.account(fromParticipantId).identity.id:(_ledger$accountByName=ledger.accountByName(fromParticipantName))===null||_ledger$accountByName===void 0?void 0:_ledger$accountByName.identity.id;if(!id)throw new Error(\"\".concat(fromParticipantName,\" does not exist.\"));const name=ledger.account(id).identity.name;return{fromParticipantId:id,fromParticipantName:name,recipients:recipients.map(_ref2=>{var _ledger$accountByName2;let{toParticipantId,toParticipantName,proportions}=_ref2;const id=toParticipantId?ledger.account(toParticipantId).identity.id:(_ledger$accountByName2=ledger.accountByName(toParticipantName))===null||_ledger$accountByName2===void 0?void 0:_ledger$accountByName2.identity.id;if(!id)throw new Error(\"\".concat(toParticipantName,\" does not exist.\"));const name=ledger.account(id).identity.name;return{toParticipantId:id,toParticipantName:name,proportions};})};});}function toPersonalAttributions(config){return config.map(_ref3=>{let{fromParticipantId,recipients}=_ref3;if(!fromParticipantId)throw new Error(\"PersonalAttributionConfig must be updated before use.\");return{fromParticipantId,recipients:recipients.map(_ref4=>{let{toParticipantId,proportions}=_ref4;if(!toParticipantId)throw new Error(\"PersonalAttributionConfig must be updated before use.\");return{toParticipantId,proportions:proportions.map(_ref5=>{let{startDate,decimalProportion}=_ref5;return{timestampMs:Object(_util_timestamp__WEBPACK_IMPORTED_MODULE_1__[\"fromISO\"])(startDate),proportionValue:decimalProportion};})};})};});}const proportionParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"].fmap(n=>{if(n<0||n>1){throw new Error(\"Proportion \".concat(n,\" is not in range [0,1]\"));}return n;});const personalAttributionsConfigParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({fromParticipantName:_core_identity__WEBPACK_IMPORTED_MODULE_0__[\"nameParser\"],recipients:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({toParticipantName:_core_identity__WEBPACK_IMPORTED_MODULE_0__[\"nameParser\"],proportions:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({startDate:_util_timestamp__WEBPACK_IMPORTED_MODULE_1__[\"timestampISOParser\"],decimalProportion:proportionParser}))},{toParticipantId:_core_identity__WEBPACK_IMPORTED_MODULE_0__[\"identityIdParser\"]}))},{fromParticipantId:_core_identity__WEBPACK_IMPORTED_MODULE_0__[\"identityIdParser\"]}));\n\n//# sourceURL=webpack:///./src/api/config/personalAttributionsConfig.js?");

/***/ }),

/***/ "./src/api/currencyConfig.js":
/*!***********************************!*\
  !*** ./src/api/currencyConfig.js ***!
  \***********************************/
/*! exports provided: DEFAULT_NAME, DEFAULT_SUFFIX, DEFAULT_DECIMALS, defaultCurrencyConfig, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_NAME\", function() { return DEFAULT_NAME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_SUFFIX\", function() { return DEFAULT_SUFFIX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_DECIMALS\", function() { return DEFAULT_DECIMALS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultCurrencyConfig\", function() { return defaultCurrencyConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _core_ledger_currency__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ledger/currency */ \"./src/core/ledger/currency.js\");\n/**\n * Shape of currencyDetails.json on disk\n */const DEFAULT_NAME=\"Grain\";const DEFAULT_SUFFIX=\"g\";const DEFAULT_DECIMALS=2;/**\n * Utilized by combo.fmap to enforce default currency values\n * when parsing. This engenders a \"canonical default\" since there\n * will be no need to add default fallbacks when handling currency\n * detail values after parsing the serialized file.\n */function upgrade(c){if(typeof c.decimalsToDisplay===\"number\"&&(c.decimalsToDisplay>18||c.decimalsToDisplay<0))throw new Error(\"currencyConfig: decimalsToDisplay must be between 0-18\");return{name:_util_null__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"](c.currencyName,DEFAULT_NAME),suffix:_util_null__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"](c.currencySuffix,DEFAULT_SUFFIX),decimals:_util_null__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"](c.decimalsToDisplay,DEFAULT_DECIMALS),integrationCurrency:c.integrationCurrency};}function defaultCurrencyConfig(){return{name:DEFAULT_NAME,suffix:DEFAULT_SUFFIX,decimals:DEFAULT_DECIMALS};}const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({},{currencyName:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],currencySuffix:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],decimalsToDisplay:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],integrationCurrency:_core_ledger_currency__WEBPACK_IMPORTED_MODULE_2__[\"currencyParser\"]}),upgrade);\n\n//# sourceURL=webpack:///./src/api/currencyConfig.js?");

/***/ }),

/***/ "./src/api/dependenciesConfig.js":
/*!***************************************!*\
  !*** ./src/api/dependenciesConfig.js ***!
  \***************************************/
/*! exports provided: mintPeriodParser, dependencyConfigParser, parser, ensureIdentityExists, toBonusPolicy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mintPeriodParser\", function() { return mintPeriodParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dependencyConfigParser\", function() { return dependencyConfigParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ensureIdentityExists\", function() { return ensureIdentityExists; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toBonusPolicy\", function() { return toBonusPolicy; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _core_ledger_ledger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ledger/ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _util_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/timestamp */ \"./src/util/timestamp.js\");\n/* harmony import */ var _core_identity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/identity */ \"./src/core/identity/index.js\");\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/uuid */ \"./src/util/uuid.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * This module defines configuration for the Dependencies system, a system\n * which allows a project to mint excess Cred for its dependencies.\n *\n * To learn about the semantics of the dependencies system, read the module\n * docstring for core/bonusMinting.js\n *\n * At a high level, this config type allows the instance maintainer to specify\n * identities (usually PROJECT-type identities) to mint extra Cred over time,\n * as a fraction of the baseline instance Cred.\n *\n * In the future, we'll likely build a UI to manage this config. However, right\n * now it's designed for hand-editability. Also, we really want to be able to\n * ship a default config that adds a SourceCred account (if one doesn't already\n * exist), activates it (if it was just created), and then flows it some Cred.\n *\n * With that in mind, here's how the config works:\n * - User makes a new config, specifying a name for the identity. The user does\n *   not manually write in an id.\n * - The config is validated against the ledger. If the config has an id, we\n *   verify that there's a matching identity in the ledger with that name\n *   (erroring if not). If the config doesn't have an id, we check if there is\n *   an identity in the ledger with that name. If there is, we write the id\n *   into the config. If there isn't, we create a new identity with the name,\n *   activate it (if told to do so by the config), and then write the id into\n *   the config.\n * - Afterwards, we save the config (which is guaranteed to have an id) back to\n *   disk.\n *\n * You'll note that the state in the config is a mix of human generated\n * (choosing the name) and automatically maintained (the id). It's something of\n * a weird compromise, but it accomplishes the design objective of having state\n * that's easy for humans to write by hand, but also tracks the vital\n * information by identity id (which is immutable) rather than by name (which\n * is re-nameable).\n *\n * Note that at present, when the identity in question is re-named, the config\n * must be manually updated to account for the rename. In the future (when the\n * config is automatically maintained) we'll remove this requirement. (Likely\n * we'll stop tracking the identities by name at all in the config; that's an\n * affordance to make the files generatable by hand.)\n */const mintPeriodParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({startTime:_util_timestamp__WEBPACK_IMPORTED_MODULE_2__[\"timestampISOParser\"],weight:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"]});function checkWeightValid(x){if(x<0)throw new Error(\"must be a non-negative number, got \".concat(x));return x;}const dependencyConfigParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({name:_core_identity__WEBPACK_IMPORTED_MODULE_3__[\"nameParser\"],periods:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](mintPeriodParser)},{id:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"],autoActivateOnIdentityCreation:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"boolean\"],autoInjectStartingPeriodWeight:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],checkWeightValid)});const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](dependencyConfigParser);function ensureIdentityExists(dep,ledger){const depId=dep.id;if(depId==null){const existingAccount=ledger.accountByName(dep.name);if(existingAccount!=null){// Already created an account; let's just return a config with the id\n// set.\nconst id=existingAccount.identity.id;return _objectSpread(_objectSpread({},dep),{},{id});}else{// Create a new Identity for this dependency.\nconst id=ledger.createIdentity(\"PROJECT\",dep.name);if(dep.autoActivateOnIdentityCreation){ledger.activate(id);}const weight=dep.autoInjectStartingPeriodWeight;if(weight!=null&&!dep.periods.length){return _objectSpread(_objectSpread({},dep),{},{id,periods:[{\"startTime\":Object(_util_timestamp__WEBPACK_IMPORTED_MODULE_2__[\"toISO\"])(Date.now()),weight}]});}return _objectSpread(_objectSpread({},dep),{},{id});}}else{let identity;try{identity=ledger.account(depId).identity;}catch(_unused){throw new Error(\"The identity for the dependency \".concat(dep.name,\" has been deleted from the ledger, or the ledger has been reset. \")+\"If this was intentional, go to your dependencies.json file and delete the 'id' attribute to reset.\");}if(identity.name!==dep.name){throw new Error(\"dependency name discrepancy: dep has name \".concat(dep.name,\" in \")+\"config, but name \".concat(identity.name,\" in the ledger. \")+\"if you deliberately renamed this dep in the ledger, please re-name it in the config as well.\");}return dep;}}function toBonusPolicy(config,ledger){const{id}=config;if(id==null){throw new Error(\"cannot convert config to policy before it has an id. ensureIdentityExists must be called first.\");}const address=ledger.account(id).identity.address;const periods=config.periods.map(_ref=>{let{startTime,weight}=_ref;return{weight,startTimeMs:Object(_util_timestamp__WEBPACK_IMPORTED_MODULE_2__[\"fromISO\"])(startTime)};});return{address,periods};}\n\n//# sourceURL=webpack:///./src/api/dependenciesConfig.js?");

/***/ }),

/***/ "./src/api/grainConfig.js":
/*!********************************!*\
  !*** ./src/api/grainConfig.js ***!
  \********************************/
/*! exports provided: rawParser, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rawParser\", function() { return rawParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _core_ledger_policies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ledger/policies */ \"./src/core/ledger/policies/index.js\");\n/* harmony import */ var _core_identity_name__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/identity/name */ \"./src/core/identity/name.js\");\n/* harmony import */ var _bundledGrainIntegrations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bundledGrainIntegrations */ \"./src/api/bundledGrainIntegrations.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const rawParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({allocationPolicies:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](_core_ledger_policies__WEBPACK_IMPORTED_MODULE_2__[\"allocationConfigParser\"])},{maxSimultaneousDistributions:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],sinkIdentity:_core_identity_name__WEBPACK_IMPORTED_MODULE_3__[\"parser\"],processDistributions:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"boolean\"],integration:_bundledGrainIntegrations__WEBPACK_IMPORTED_MODULE_4__[\"parser\"]});const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({allocationPolicies:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](_core_ledger_policies__WEBPACK_IMPORTED_MODULE_2__[\"policyConfigParser\"])},{maxSimultaneousDistributions:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],sinkIdentity:_core_identity_name__WEBPACK_IMPORTED_MODULE_3__[\"parser\"],processDistributions:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"boolean\"],integration:_bundledGrainIntegrations__WEBPACK_IMPORTED_MODULE_4__[\"parser\"]}),config=>_objectSpread(_objectSpread({},config),{},{maxSimultaneousDistributions:_util_null__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"](config.maxSimultaneousDistributions,Infinity)}));\n\n//# sourceURL=webpack:///./src/api/grainConfig.js?");

/***/ }),

/***/ "./src/api/instance/instance.js":
/*!**************************************!*\
  !*** ./src/api/instance/instance.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_credrank_credGraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/credrank/credGraph */ \"./src/core/credrank/credGraph.js\");\n/* harmony import */ var _core_credGrainView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/credGrainView */ \"./src/core/credGrainView.js\");\n/* harmony import */ var _core_ledger_ledger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/ledger/ledger */ \"./src/core/ledger/ledger.js\");\n\n\n//# sourceURL=webpack:///./src/api/instance/instance.js?");

/***/ }),

/***/ "./src/api/instance/localInstance.js":
/*!*******************************************!*\
  !*** ./src/api/instance/localInstance.js ***!
  \*******************************************/
/*! exports provided: LocalInstance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LocalInstance\", function() { return LocalInstance; });\n/* harmony import */ var _instance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instance */ \"./src/api/instance/instance.js\");\n/* harmony import */ var _readInstance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./readInstance */ \"./src/api/instance/readInstance.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _core_weightedGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/weightedGraph */ \"./src/core/weightedGraph.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var _util_disk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/disk */ \"./src/util/disk.js\");\n/* harmony import */ var _util_timestamp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/timestamp */ \"./src/util/timestamp.js\");\n/* harmony import */ var _instanceConfig__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../instanceConfig */ \"./src/api/instanceConfig.js\");\n/* harmony import */ var _core_ledger_ledger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/ledger/ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _core_credrank_credGraph__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/credrank/credGraph */ \"./src/core/credrank/credGraph.js\");\n/* harmony import */ var _core_credGrainView__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/credGrainView */ \"./src/core/credGrainView.js\");\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/storage/disk */ \"./src/core/storage/disk.js\");\n/* harmony import */ var _core_storage_zip__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/storage/zip */ \"./src/core/storage/zip.js\");\n/* harmony import */ var _core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../core/storage/textEncoding */ \"./src/core/storage/textEncoding.js\");\n/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../core/storage */ \"./src/core/storage/index.js\");\n/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_core_storage__WEBPACK_IMPORTED_MODULE_15__);\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const DEPENDENCIES_PATH=[\"config\",\"dependencies.json\"];const PERSONAL_ATTRIBUTIONS_PATH=[\"config\",\"personalAttributions.json\"];const INSTANCE_CONFIG_PATH=[\"sourcecred.json\"];const CREDGRAPH_PATH=[\"output\",\"credGraph\"];const CREDGRAINVIEW_PATH=[\"output\",\"credGrainView\"];const GRAPHS_PATH=[\"graph\"];const LEDGER_PATH=[\"data\",\"ledger.json\"];const ACCOUNTS_PATH=[\"output\",\"accounts.json\"];const NEO4J_DIRECTORY=[\"output\",\"neo4j\"];const GRAIN_INTEGRATION_DIRECTORY=[\"output\",\"grainIntegration\"];const JSON_SUFFIX=\".json\";const CSV_SUFFIX=\".csv\";const ZIP_SUFFIX=\"\";/**\nThis is an Instance implementation that reads and writes using relative paths\non the local disk.\n */class LocalInstance extends _readInstance__WEBPACK_IMPORTED_MODULE_1__[\"ReadInstance\"]{constructor(baseDirectory){const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_12__[\"DiskStorage\"](baseDirectory);super(storage);_defineProperty(this,\"_baseDirectory\",void 0);_defineProperty(this,\"_writableStorage\",void 0);_defineProperty(this,\"_writableZipStorage\",void 0);this._writableStorage=storage;this._baseDirectory=baseDirectory;this._writableZipStorage=new _core_storage_zip__WEBPACK_IMPORTED_MODULE_13__[\"WritableZipStorage\"](storage);}//////////////////////////////\n//  Interface Functions\n//////////////////////////////\nasync readGraphInput(){const[instanceConfig,ledger]=await Promise.all([this.readInstanceConfig(),this.readLedger()]);const plugins=[];for(const[pluginId,plugin]of instanceConfig.bundledPlugins.entries()){plugins.push({pluginId,plugin,directoryContext:this.pluginDirectoryContext(pluginId)});}return{plugins,ledger};}async writeGraphOutput(graphOutput){let shouldZip=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;await Promise.all([this.writeLedger(graphOutput.ledger),...graphOutput.pluginGraphs.map(_ref=>{let{pluginId,weightedGraph}=_ref;return this.writePluginGraph(pluginId,weightedGraph,shouldZip);})]);}async writeCredrankOutput(credrankOutput){let shouldZip=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;await Promise.all([this.writeLedger(credrankOutput.ledger),this.writeCredGraph(credrankOutput.credGraph,shouldZip),this.writeCredGrainView(credrankOutput.credGrainView,shouldZip),this.writeDependenciesConfig(credrankOutput.dependencies),this.writePersonalAttributionsConfig(credrankOutput.personalAttributions)]);}async writeAnalysisOutput(analysisOutput){await Promise.all([this.writeCredAccounts(analysisOutput.accounts),this.writeNeo4jOutput(analysisOutput.neo4j)]);}async writeLedger(ledger){const ledgerPath=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...LEDGER_PATH);return this._writableStorage.set(ledgerPath,Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_14__[\"encode\"])(ledger.serialize()));}async writeGrainIntegrationOutput(result){if(!result.output){return;}const{fileName,content}=result.output;Object(_util_disk__WEBPACK_IMPORTED_MODULE_6__[\"mkdirx\"])(Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...GRAIN_INTEGRATION_DIRECTORY));const credDateString=Object(_util_timestamp__WEBPACK_IMPORTED_MODULE_7__[\"toISO\"])(result.distributionCredTimestamp);const grainIntegrationPath=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...GRAIN_INTEGRATION_DIRECTORY,credDateString+\"_\"+fileName);this._writableStorage.set(grainIntegrationPath,Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_14__[\"encode\"])(content));}//////////////////////////////\n//  Private Functions\n//////////////////////////////\nasync readInstanceConfig(){const pluginsConfigPath=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...INSTANCE_CONFIG_PATH);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_5__[\"loadJson\"])(this._storage,pluginsConfigPath,_instanceConfig__WEBPACK_IMPORTED_MODULE_8__[\"parser\"]);}createPluginDirectory(components,pluginId){const idParts=pluginId.split(\"/\");if(idParts.length!==2){throw new Error(\"Bad plugin name: \".concat(pluginId));}const[pluginOwner,pluginName]=idParts;const pathComponents=[...components,pluginOwner,pluginName];let path=this._baseDirectory;for(const pc of pathComponents){path=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(path,pc);Object(_util_disk__WEBPACK_IMPORTED_MODULE_6__[\"mkdirx\"])(path);}return Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...pathComponents);}pluginDirectoryContext(pluginName){const cacheDir=this.createPluginDirectory([\"cache\"],pluginName);const configDir=this.createPluginDirectory([\"config\",\"plugins\"],pluginName);return{configDirectory(){return configDir;},cacheDirectory(){return cacheDir;}};}async writeCredGraph(credGraph){let shouldZip=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;const cgJson=json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(credGraph.toJSON());const outputPath=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...CREDGRAPH_PATH)+(shouldZip?ZIP_SUFFIX:JSON_SUFFIX);const storage=shouldZip?this._writableZipStorage:this._writableStorage;return storage.set(outputPath,Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_14__[\"encode\"])(cgJson));}async writeCredGrainView(credGrainView){let shouldZip=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;const json=json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(credGrainView.toJSON());const outputPath=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...CREDGRAINVIEW_PATH)+(shouldZip?ZIP_SUFFIX:JSON_SUFFIX);const storage=shouldZip?this._writableZipStorage:this._writableStorage;return storage.set(outputPath,Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_14__[\"encode\"])(json));}async writePluginGraph(pluginId,weightedGraph){let shouldZip=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;const serializedGraph=Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_14__[\"encode\"])(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_4__[\"toJSON\"])(weightedGraph)));const outputDir=this.createPluginGraphDirectory(pluginId);const outputPath=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(outputDir,...GRAPHS_PATH)+(shouldZip?ZIP_SUFFIX:JSON_SUFFIX);const storage=shouldZip?this._writableZipStorage:this._writableStorage;return storage.set(outputPath,serializedGraph);}async writeDependenciesConfig(dependenciesConfig){const dependenciesPath=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...DEPENDENCIES_PATH);return this._writableStorage.set(dependenciesPath,json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(dependenciesConfig,{space:4}));}async writePersonalAttributionsConfig(config){const path=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...PERSONAL_ATTRIBUTIONS_PATH);return this._writableStorage.set(path,json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(config,{space:4}));}async writeCredAccounts(credAccounts){const accountsPath=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...ACCOUNTS_PATH);return this._writableStorage.set(accountsPath,Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_14__[\"encode\"])(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(credAccounts)));}async writeNeo4jOutput(neo4jOutput){if(!neo4jOutput)return;Object(_util_disk__WEBPACK_IMPORTED_MODULE_6__[\"mkdirx\"])(Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...NEO4J_DIRECTORY));await Promise.all([this.writeFromIterator(neo4jOutput.nodes,NEO4J_DIRECTORY,\"nodes_\",CSV_SUFFIX,false),this.writeFromIterator(neo4jOutput.edges,NEO4J_DIRECTORY,\"edges_\",CSV_SUFFIX,false)]);}async writeFromIterator(iterator,directory,prefix,suffix,shouldZip){const promises=[];const storage=shouldZip?this._writableZipStorage:this._writableStorage;let n=1;for(const str of iterator){const path=Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(...directory,prefix+n+suffix);promises.push(storage.set(path,Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_14__[\"encode\"])(str)));n++;}await Promise.all(promises);}}\n\n//# sourceURL=webpack:///./src/api/instance/localInstance.js?");

/***/ }),

/***/ "./src/api/instance/readInstance.js":
/*!******************************************!*\
  !*** ./src/api/instance/readInstance.js ***!
  \******************************************/
/*! exports provided: getNetworkReadInstance, getRawGithubReadInstance, getOriginReadInstance, ReadInstance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNetworkReadInstance\", function() { return getNetworkReadInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRawGithubReadInstance\", function() { return getRawGithubReadInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOriginReadInstance\", function() { return getOriginReadInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadInstance\", function() { return ReadInstance; });\n/* harmony import */ var _instance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instance */ \"./src/api/instance/instance.js\");\n/* harmony import */ var _core_weightedGraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/weightedGraph */ \"./src/core/weightedGraph.js\");\n/* harmony import */ var _core_weights__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/weights */ \"./src/core/weights.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var _core_credrank_credGraph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/credrank/credGraph */ \"./src/core/credrank/credGraph.js\");\n/* harmony import */ var _core_credGrainView__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/credGrainView */ \"./src/core/credGrainView.js\");\n/* harmony import */ var _core_ledger_ledger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/ledger/ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _dependenciesConfig__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dependenciesConfig */ \"./src/api/dependenciesConfig.js\");\n/* harmony import */ var _pluginBudgetConfig__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../pluginBudgetConfig */ \"./src/api/pluginBudgetConfig.js\");\n/* harmony import */ var _rawInstanceConfig__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../rawInstanceConfig */ \"./src/api/rawInstanceConfig.js\");\n/* harmony import */ var _core_storage_networkStorage__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/storage/networkStorage */ \"./src/core/storage/networkStorage.js\");\n/* harmony import */ var _core_storage_originStorage__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/storage/originStorage */ \"./src/core/storage/originStorage.js\");\n/* harmony import */ var _core_storage_zip__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/storage/zip */ \"./src/core/storage/zip.js\");\n/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../core/storage */ \"./src/core/storage/index.js\");\n/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_core_storage__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _grainConfig__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../grainConfig */ \"./src/api/grainConfig.js\");\n/* harmony import */ var _currencyConfig__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../currencyConfig */ \"./src/api/currencyConfig.js\");\n/* harmony import */ var _config_personalAttributionsConfig__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../config/personalAttributionsConfig */ \"./src/api/config/personalAttributionsConfig.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const getNetworkReadInstance=base=>new ReadInstance(new _core_storage_networkStorage__WEBPACK_IMPORTED_MODULE_11__[\"NetworkStorage\"](base));const getRawGithubReadInstance=(organization,repository,branch)=>new ReadInstance(new _core_storage_networkStorage__WEBPACK_IMPORTED_MODULE_11__[\"NetworkStorage\"](\"https://raw.githubusercontent.com/\".concat(organization,\"/\").concat(repository,\"/\").concat(branch,\"/\")));const getOriginReadInstance=base=>new ReadInstance(new _core_storage_originStorage__WEBPACK_IMPORTED_MODULE_12__[\"OriginStorage\"](base));const DEPENDENCIES_PATH=[\"config\",\"dependencies.json\"];const WEIGHT_OVERRIDES_PATH=[\"config\",\"weights.json\"];const BUDGET_PATH=[\"config\",\"pluginBudgets.json\"];const GRAIN_PATH=[\"config\",\"grain.json\"];const CURRENCY_PATH=[\"config\",\"currencyDetails.json\"];const PERSONAL_ATTRIBUTIONS_PATH=[\"config\",\"personalAttributions.json\"];const RAW_INSTANCE_CONFIG_PATH=[\"sourcecred.json\"];const LEDGER_PATH=[\"data\",\"ledger.json\"];const CREDGRAPH_PATH=[\"output\",\"credGraph\"];const CREDGRAINVIEW_PATH=[\"output\",\"credGrainView\"];const GRAPHS_DIRECTORY=[\"output\",\"graphs\"];const GRAPHS_PATH=[\"graph\"];const JSON_SUFFIX=\".json\";const ZIP_SUFFIX=\"\";/**\nThis is an Instance implementation that reads and writes using relative paths\non the given base URL. The base URL given should end with a trailing slash.\n */class ReadInstance{constructor(storage){_defineProperty(this,\"_storage\",void 0);_defineProperty(this,\"_zipStorage\",void 0);this._storage=storage;this._zipStorage=new _core_storage_zip__WEBPACK_IMPORTED_MODULE_13__[\"ZipStorage\"](this._storage);}async readGraphInput(){throw\"not yet implemented\";}async readCredrankInput(){const[pluginGraphs,ledger,weightOverrides,dependencies,pluginsBudget,personalAttributions]=await Promise.all([this.readPluginGraphs(),this.readLedger(),this.readWeightOverrides(),this.readDependencies(),this.readPluginsBudget(),this.readPersonalAttributions()]);return{pluginGraphs,ledger,weightOverrides,dependencies,pluginsBudget,personalAttributions};}async readGrainInput(){const[credGraph,ledger,grainConfig,currencyDetails]=await Promise.all([this.readCredGraph(),this.readLedger(),this.readGrainConfig(),this.readCurrencyDetails()]);return{credGraph,ledger,grainConfig,currencyDetails};}async readAnalysisInput(){const[credGraph,ledger]=await Promise.all([this.readCredGraph(),this.readLedger()]);return{credGraph,ledger,featureFlags:{}};}async readWeightedGraphForPlugin(pluginId){const outputPath=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(this.createPluginGraphDirectory(pluginId),...GRAPHS_PATH);const graphJSON=await Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJson\"])(this._zipStorage,outputPath,_util_combo__WEBPACK_IMPORTED_MODULE_18__[\"raw\"]);return Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_1__[\"fromJSON\"])(graphJSON);}async readCredGraph(){const credGraphPath=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...CREDGRAPH_PATH);return await Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJson\"])(this._zipStorage,credGraphPath+ZIP_SUFFIX,_core_credrank_credGraph__WEBPACK_IMPORTED_MODULE_5__[\"parser\"]).catch(()=>Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJson\"])(this._storage,credGraphPath+JSON_SUFFIX,_core_credrank_credGraph__WEBPACK_IMPORTED_MODULE_5__[\"parser\"]));}async readCredGrainView(){const path=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...CREDGRAINVIEW_PATH);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJson\"])(this._zipStorage,path+ZIP_SUFFIX,_core_credGrainView__WEBPACK_IMPORTED_MODULE_6__[\"credGrainViewParser\"]).catch(()=>Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJson\"])(this._storage,path+JSON_SUFFIX,_core_credGrainView__WEBPACK_IMPORTED_MODULE_6__[\"credGrainViewParser\"]));}async readLedger(){const ledgerPath=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...LEDGER_PATH);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadFileWithDefault\"])(this._storage,ledgerPath,()=>new _core_ledger_ledger__WEBPACK_IMPORTED_MODULE_7__[\"Ledger\"]().serialize()).then(result=>_core_ledger_ledger__WEBPACK_IMPORTED_MODULE_7__[\"Ledger\"].parse(result));}async readGrainConfig(){const grainConfigPath=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...GRAIN_PATH);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJson\"])(this._storage,grainConfigPath,_grainConfig__WEBPACK_IMPORTED_MODULE_15__[\"parser\"]);}async readCurrencyDetails(){const currencyDetailsPath=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...CURRENCY_PATH);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJsonWithDefault\"])(this._storage,currencyDetailsPath,_currencyConfig__WEBPACK_IMPORTED_MODULE_16__[\"parser\"],_currencyConfig__WEBPACK_IMPORTED_MODULE_16__[\"defaultCurrencyConfig\"]);}// Private Functions\nasync readRawInstanceConfig(){const pluginsConfigPath=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...RAW_INSTANCE_CONFIG_PATH);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJson\"])(this._storage,pluginsConfigPath,_rawInstanceConfig__WEBPACK_IMPORTED_MODULE_10__[\"rawParser\"]);}async readPersonalAttributions(){const path=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...PERSONAL_ATTRIBUTIONS_PATH);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJsonWithDefault\"])(this._storage,path,_config_personalAttributionsConfig__WEBPACK_IMPORTED_MODULE_17__[\"personalAttributionsConfigParser\"],()=>[]);}async readPluginGraphs(){const instanceConfig=await this.readRawInstanceConfig();const pluginNames=instanceConfig.bundledPlugins;return await Promise.all(pluginNames.map(async name=>{const outputDir=this.createPluginDirectory(GRAPHS_DIRECTORY,name);const outputPath=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(outputDir,...GRAPHS_PATH);const graphJSON=await Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJson\"])(this._zipStorage,outputPath+ZIP_SUFFIX,_util_combo__WEBPACK_IMPORTED_MODULE_18__[\"raw\"]).catch(()=>Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJson\"])(this._storage,outputPath+JSON_SUFFIX,_util_combo__WEBPACK_IMPORTED_MODULE_18__[\"raw\"]));return Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_1__[\"fromJSON\"])(graphJSON);}));}async readWeightOverrides(){const weightsPath=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...WEIGHT_OVERRIDES_PATH);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJsonWithDefault\"])(this._storage,weightsPath,_core_weights__WEBPACK_IMPORTED_MODULE_2__[\"parser\"],_core_weights__WEBPACK_IMPORTED_MODULE_2__[\"empty\"]);}async readDependencies(){const dependenciesPath=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...DEPENDENCIES_PATH);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJsonWithDefault\"])(this._storage,dependenciesPath,_dependenciesConfig__WEBPACK_IMPORTED_MODULE_8__[\"parser\"],()=>[]);}async readPluginsBudget(){const budgetPath=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...BUDGET_PATH);const raw=await Object(_util_storage__WEBPACK_IMPORTED_MODULE_4__[\"loadJsonWithDefault\"])(this._storage,budgetPath,_pluginBudgetConfig__WEBPACK_IMPORTED_MODULE_9__[\"rawParser\"],()=>null);return raw?await Object(_pluginBudgetConfig__WEBPACK_IMPORTED_MODULE_9__[\"upgrade\"])(raw,this._storage):null;}createPluginDirectory(components,pluginId){const idParts=pluginId.split(\"/\");if(idParts.length!==2){throw new Error(\"Bad plugin name: \".concat(pluginId));}const[pluginOwner,pluginName]=idParts;const pathComponents=[...components,pluginOwner,pluginName];return Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...pathComponents);}createPluginGraphDirectory(pluginId){return this.createPluginDirectory(GRAPHS_DIRECTORY,pluginId);}}\n\n//# sourceURL=webpack:///./src/api/instance/readInstance.js?");

/***/ }),

/***/ "./src/api/instanceConfig.js":
/*!***********************************!*\
  !*** ./src/api/instanceConfig.js ***!
  \***********************************/
/*! exports provided: parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugin */ \"./src/api/plugin.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_plugin__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _bundledPlugins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bundledPlugins */ \"./src/api/bundledPlugins.js\");\n/* harmony import */ var _rawInstanceConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rawInstanceConfig */ \"./src/api/rawInstanceConfig.js\");\n/* harmony import */ var _pluginId__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pluginId */ \"./src/api/pluginId.js\");\nfunction upgrade(raw){const bundledPlugins=new Map();for(const id of raw.bundledPlugins){const plugin=Object(_bundledPlugins__WEBPACK_IMPORTED_MODULE_2__[\"getPlugin\"])(id);if(plugin==null){throw new Error(\"bad bundled plugin: \"+JSON.stringify(id));}bundledPlugins.set(id,plugin);}return{bundledPlugins};}const parser=_rawInstanceConfig__WEBPACK_IMPORTED_MODULE_3__[\"rawParser\"].fmap(upgrade);\n\n//# sourceURL=webpack:///./src/api/instanceConfig.js?");

/***/ }),

/***/ "./src/api/main/analysis.js":
/*!**********************************!*\
  !*** ./src/api/main/analysis.js ***!
  \**********************************/
/*! exports provided: analysis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analysis\", function() { return analysis; });\n/* harmony import */ var _analysisUtils_neo4j__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./analysisUtils/neo4j */ \"./src/api/main/analysisUtils/neo4j.js\");\n/* harmony import */ var _core_credrank_credGraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/credrank/credGraph */ \"./src/core/credrank/credGraph.js\");\n/* harmony import */ var _core_ledger_ledger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/ledger/ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _core_ledger_credAccounts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/ledger/credAccounts */ \"./src/core/ledger/credAccounts.js\");\n/** Input type for the analysis API */ /**\n  A primary SourceCred API that transforms the given inputs into useful data\n  analysis structures.\n */async function analysis(input){const accounts=Object(_core_ledger_credAccounts__WEBPACK_IMPORTED_MODULE_3__[\"computeCredAccounts\"])(input.ledger,input.credGraph);const neo4j=input.featureFlags.neo4j?Object(_analysisUtils_neo4j__WEBPACK_IMPORTED_MODULE_0__[\"computeNeo4jData\"])(input):undefined;return{accounts,neo4j};}\n\n//# sourceURL=webpack:///./src/api/main/analysis.js?");

/***/ }),

/***/ "./src/api/main/analysisUtils/neo4j.js":
/*!*********************************************!*\
  !*** ./src/api/main/analysisUtils/neo4j.js ***!
  \*********************************************/
/*! exports provided: computeNeo4jData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeNeo4jData\", function() { return computeNeo4jData; });\n/* harmony import */ var _core_credrank_nodeGadgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/credrank/nodeGadgets */ \"./src/core/credrank/nodeGadgets.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _util_batch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/batch */ \"./src/util/batch.js\");\n/* harmony import */ var json2csv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! json2csv */ \"json2csv\");\n/* harmony import */ var json2csv__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(json2csv__WEBPACK_IMPORTED_MODULE_3__);\n/** Iterators that will yield CSV strings. The CSV contents will be batched in\ngroups for scalability. Each group will include headers. These strings can\neach be written to disk as a .csv file and then used to export the nodes\nand edges of a CredGraph into a Neo4j database using neo4j-admin.*/ // Used for batching nodes and edges.\n// This is mainly mitigating against the max string length in JS,\n// so hardcoding it makes sense for now.\nconst safeBatchSize=500000;const computeNeo4jData=input=>{function*nodesCsvGenerator(){const batchedNodes=Object(_util_batch__WEBPACK_IMPORTED_MODULE_2__[\"batchIterator\"])(input.credGraph.nodes(),safeBatchSize);while(batchedNodes.hasNext()){const formattedNodes=[];for(const node of batchedNodes){formattedNodes.push({description:getNodeDescription(node,input.ledger),cred:node.cred,mint:node.mint,\"address:ID\":reformatNodeAddress(node.address),\"nodeType:LABEL\":reformatNodeAddress(node.address,3),\"plugin:LABEL\":reformatNodeAddress(node.address,2)});}yield Object(json2csv__WEBPACK_IMPORTED_MODULE_3__[\"parse\"])(formattedNodes);}}function*edgesCsvGenerator(){const batchedEdges=Object(_util_batch__WEBPACK_IMPORTED_MODULE_2__[\"batchIterator\"])(input.credGraph.edges(),safeBatchSize);while(batchedEdges.hasNext()){const formattedEdges=[];for(const edge of batchedEdges){formattedEdges.push({reversed:edge.reversed,transitionProbability:edge.transitionProbability,credFlow:edge.credFlow,address:reformatEdgeAddress(edge.address),\":TYPE\":reformatEdgeAddress(edge.address,3),\"dst:END_ID\":reformatNodeAddress(edge.dst),\"src:START_ID\":reformatNodeAddress(edge.src)});}yield Object(json2csv__WEBPACK_IMPORTED_MODULE_3__[\"parse\"])(formattedEdges);}}return{nodes:generatorToCountingIterator(nodesCsvGenerator()),edges:generatorToCountingIterator(edgesCsvGenerator())};};function reformatNodeAddress(address){let partsToInclude=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Infinity;const a=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(address).slice(0,partsToInclude);return a.join(\"/\");}function reformatEdgeAddress(address){let partsToInclude=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Infinity;const a=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].toParts(address).slice(0,partsToInclude);return a.join(\"/\");}function getNodeDescription(node,ledger){if(_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].hasPrefix(node.address,_core_credrank_nodeGadgets__WEBPACK_IMPORTED_MODULE_0__[\"epochGadget\"].prefix)){const{owner,epochStart}=_core_credrank_nodeGadgets__WEBPACK_IMPORTED_MODULE_0__[\"epochGadget\"].fromRaw(node.address);return\"Participant: \".concat(ledger.account(owner).identity.name,\", Epoch Start: \").concat(new Date(epochStart).toDateString());}return node.description.replace(/[^a-zA-Z0-9/:[\\]() \\-.#]/g,\"\");}function generatorToCountingIterator(generator){let counter=0;const countingGenerator=function*(){let next=generator.next();while(!next.done){counter++;yield next.value;next=generator.next();}}();const result={iterationsCompleted:()=>counter,next:countingGenerator.next,[\"@@iterator\"]:()=>countingGenerator,[Symbol.iterator]:()=>countingGenerator};return result;}\n\n//# sourceURL=webpack:///./src/api/main/analysisUtils/neo4j.js?");

/***/ }),

/***/ "./src/api/main/credrank.js":
/*!**********************************!*\
  !*** ./src/api/main/credrank.js ***!
  \**********************************/
/*! exports provided: credrank */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"credrank\", function() { return credrank; });\n/* harmony import */ var _core_credrank_credGraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/credrank/credGraph */ \"./src/core/credrank/credGraph.js\");\n/* harmony import */ var _core_credGrainView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/credGrainView */ \"./src/core/credGrainView.js\");\n/* harmony import */ var _core_weightedGraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/weightedGraph */ \"./src/core/weightedGraph.js\");\n/* harmony import */ var _api_dependenciesConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../api/dependenciesConfig */ \"./src/api/dependenciesConfig.js\");\n/* harmony import */ var _core_ledger_ledger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/ledger/ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _core_bonusMinting__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/bonusMinting */ \"./src/core/bonusMinting.js\");\n/* harmony import */ var _core_mintBudget__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/mintBudget */ \"./src/core/mintBudget.js\");\n/* harmony import */ var _core_identity__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/identity */ \"./src/core/identity/index.js\");\n/* harmony import */ var _core_credrank_compute__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/credrank/compute */ \"./src/core/credrank/compute.js\");\n/* harmony import */ var _config_personalAttributionsConfig__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../config/personalAttributionsConfig */ \"./src/api/config/personalAttributionsConfig.js\");\n/**\n  A primary SourceCred API that combines the given inputs into a single\n  WeightedGraph and then runs the CredRank algorithm on it to create a CredGraph\n  containing the cred scores of nodes/participants.\n\n  Might mutate the ledger that is passed in.\n */async function credrank(input){let weightedGraph=Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_2__[\"overrideWeights\"])(Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_2__[\"merge\"])(input.pluginGraphs),input.weightOverrides);// important that this happens before identity contractions\nconst dependenciesWithIds=input.dependencies.map(d=>// This mutates the ledger, adding new identities when needed.\nObject(_api_dependenciesConfig__WEBPACK_IMPORTED_MODULE_3__[\"ensureIdentityExists\"])(d,input.ledger));const identities=input.ledger.accounts().map(a=>a.identity);const contractedGraph=weightedGraph.graph.contractNodes(Object(_core_identity__WEBPACK_IMPORTED_MODULE_7__[\"contractions\"])(identities));weightedGraph={graph:contractedGraph,weights:weightedGraph.weights};if(input.pluginsBudget){weightedGraph=Object(_core_mintBudget__WEBPACK_IMPORTED_MODULE_6__[\"applyBudget\"])(weightedGraph,input.pluginsBudget);}const dependencyBonuses=dependenciesWithIds.map(d=>Object(_api_dependenciesConfig__WEBPACK_IMPORTED_MODULE_3__[\"toBonusPolicy\"])(d,input.ledger));const bonusGraph=Object(_core_bonusMinting__WEBPACK_IMPORTED_MODULE_5__[\"createBonusGraph\"])(Object(_core_bonusMinting__WEBPACK_IMPORTED_MODULE_5__[\"computeBonusMinting\"])(weightedGraph,dependencyBonuses));weightedGraph=Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_2__[\"merge\"])([weightedGraph,bonusGraph]);const updatedPersonalAttributionsConfig=Object(_config_personalAttributionsConfig__WEBPACK_IMPORTED_MODULE_9__[\"updatePersonalAttributionsConfig\"])(input.personalAttributions,input.ledger);const credGraph=await Object(_core_credrank_compute__WEBPACK_IMPORTED_MODULE_8__[\"credrank\"])(weightedGraph,input.ledger,Object(_config_personalAttributionsConfig__WEBPACK_IMPORTED_MODULE_9__[\"toPersonalAttributions\"])(updatedPersonalAttributionsConfig));return{credGraph,credGrainView:_core_credGrainView__WEBPACK_IMPORTED_MODULE_1__[\"CredGrainView\"].fromCredGraphAndLedger(credGraph,input.ledger),ledger:input.ledger,dependencies:dependenciesWithIds,personalAttributions:updatedPersonalAttributionsConfig};}\n\n//# sourceURL=webpack:///./src/api/main/credrank.js?");

/***/ }),

/***/ "./src/api/main/grain.js":
/*!*******************************!*\
  !*** ./src/api/main/grain.js ***!
  \*******************************/
/*! exports provided: grain, executeGrainIntegrationsFromGrainInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"grain\", function() { return grain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"executeGrainIntegrationsFromGrainInput\", function() { return executeGrainIntegrationsFromGrainInput; });\n/* harmony import */ var _core_credrank_credGraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/credrank/credGraph */ \"./src/core/credrank/credGraph.js\");\n/* harmony import */ var _core_ledger_ledger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/ledger/ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _core_ledger_applyDistributions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/ledger/applyDistributions */ \"./src/core/ledger/applyDistributions.js\");\n/* harmony import */ var _core_ledger_grainIntegration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/ledger/grainIntegration */ \"./src/core/ledger/grainIntegration.js\");\n/**\n  A primary SourceCred API that combines the given inputs into a list of\n  grain distributions.\n\n  May mutate the ledger that is passed in.\n */async function grain(input){const distributions=Object(_core_ledger_applyDistributions__WEBPACK_IMPORTED_MODULE_2__[\"applyDistributions\"])(input.grainConfig,input.credGraph,input.ledger,+Date.now(),input.allowMultipleDistributionsPerInterval||false);return{distributions,ledger:input.ledger};}/**\n * Marshall grainInput from a Grain Configuration file for use with\n * executeGrainIntegration function\n */function executeGrainIntegrationsFromGrainInput(grainInput,ledger,distributions){const integrationCurrency=grainInput.currencyDetails.integrationCurrency;const grainIntegration=grainInput.grainConfig.integration;const results=[];// track the latest ledger in the for-loop for the purposes of returning it\n// at the top level, observing that any function may deep-copy\n// the ledger (thus creating a new reference we'll need to track) and also\n// supporting the case where the distributions parameter is an empty array\nlet ledgerResult=ledger;if(integrationCurrency&&grainIntegration){distributions.forEach(distribution=>{const result=Object(_core_ledger_grainIntegration__WEBPACK_IMPORTED_MODULE_3__[\"executeGrainIntegration\"])(ledgerResult,grainIntegration.function,distribution,integrationCurrency,false);const{output,distributionCredTimestamp,ledger:nextLedger}=result;ledgerResult=nextLedger;results.push({output,distributionCredTimestamp});});}return{ledger:ledgerResult,results};}\n\n//# sourceURL=webpack:///./src/api/main/grain.js?");

/***/ }),

/***/ "./src/api/main/graph.js":
/*!*******************************!*\
  !*** ./src/api/main/graph.js ***!
  \*******************************/
/*! exports provided: graph, _hackyIdentityNameReferenceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"graph\", function() { return graph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_hackyIdentityNameReferenceDetector\", function() { return _hackyIdentityNameReferenceDetector; });\n/* harmony import */ var _core_ledger_ledger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ledger/ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugin */ \"./src/api/plugin.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_plugin__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_taskReporter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/taskReporter */ \"./src/util/taskReporter.js\");\n/* harmony import */ var _core_references_cascadingReferenceDetector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/references/cascadingReferenceDetector */ \"./src/core/references/cascadingReferenceDetector.js\");\n/* harmony import */ var _core_ledger_identityProposal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/ledger/identityProposal */ \"./src/core/ledger/identityProposal.js\");\n/**\n Iterates through the provided plugins, runs their `graph` and `identities`\n processes, and updates the ledger with any new IdentityProposals.\n \n Might mutate the ledger that is passed in.\n */async function graph(input,// Specifies which of the plugins in the GraphInput should be run.\n// If omitted, all plugins in the GraphInput are run.\nscope){let taskReporter=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new _util_taskReporter__WEBPACK_IMPORTED_MODULE_2__[\"SilentTaskReporter\"]();// Build Reference Detector\nconst rds=[];for(const{pluginId,plugin,directoryContext}of input.plugins){const task=\"reference detector for \".concat(pluginId);taskReporter.start(task);const rd=await plugin.referenceDetector(directoryContext,taskReporter);rds.push(rd);taskReporter.finish(task);}rds.push(_hackyIdentityNameReferenceDetector(input.ledger));const rd=new _core_references_cascadingReferenceDetector__WEBPACK_IMPORTED_MODULE_3__[\"CascadingReferenceDetector\"](rds);// Build graphs\nconst pluginGraphs=[];for(const{pluginId,plugin,directoryContext}of input.plugins){if(!scope||scope.includes(pluginId)){const task=\"generating graph for \".concat(pluginId);taskReporter.start(task);pluginGraphs.push({pluginId:pluginId,weightedGraph:await plugin.graph(directoryContext,rd,taskReporter)});const identities=await plugin.identities(directoryContext,taskReporter);for(const identityProposal of identities){Object(_core_ledger_identityProposal__WEBPACK_IMPORTED_MODULE_4__[\"ensureIdentityExists\"])(input.ledger,identityProposal);}taskReporter.finish(task);}}return{pluginGraphs,ledger:input.ledger};}// Hack to support old-school (deprecated) \"initiatives files\":\n// We need to be able to parse references to usernames, e.g. \"@yalor\", so\n// we need a reference detector that will match these to identities in the\n// Ledger. This isn't a robust addressing scheme, since identities are re-nameable;\n// in v2 the initiatives plugin will be re-written to use identity node addresses instead.\n// This hack can be safely deleted once we no longer support initiatives files that refer\n// to identities by their names instead of their IDs.\nfunction _hackyIdentityNameReferenceDetector(ledger){const usernameToAddress=new Map(ledger.accounts().map(a=>[a.identity.name.toLowerCase(),a.identity.address]));function addressFromUrl(potentialUsername){const prepped=potentialUsername.replace(\"@\",\"\").toLowerCase();return usernameToAddress.get(prepped);}return{addressFromUrl};}\n\n//# sourceURL=webpack:///./src/api/main/graph.js?");

/***/ }),

/***/ "./src/api/plugin.js":
/*!***************************!*\
  !*** ./src/api/plugin.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./src/api/plugin.js?");

/***/ }),

/***/ "./src/api/pluginBudgetConfig.js":
/*!***************************************!*\
  !*** ./src/api/pluginBudgetConfig.js ***!
  \***************************************/
/*! exports provided: rawParser, upgrade */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rawParser\", function() { return rawParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"upgrade\", function() { return upgrade; });\n/* harmony import */ var _core_mintBudget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/mintBudget */ \"./src/core/mintBudget.js\");\n/* harmony import */ var _pluginId__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluginId */ \"./src/api/pluginId.js\");\n/* harmony import */ var _util_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/timestamp */ \"./src/util/timestamp.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _bundledDeclarations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bundledDeclarations */ \"./src/api/bundledDeclarations.js\");\n/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/storage */ \"./src/core/storage/index.js\");\n/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_core_storage__WEBPACK_IMPORTED_MODULE_5__);\n/**\n * This module contains logic for setting Cred minting budgets over time on a per-plugin basis.\n * As an example, suppose we want to limit the GitHub plugin to mint only 200 Cred per week,\n * and we want the Discord plugin to mint 100 Cred per Week until Jan 1, 2020 and 200 Cred per\n * week thereafter. We could do so with the following config:\n * ```json\n * {\n *   \"intervalLength\": \"WEEKLY\",\n *   \"plugins\": {\n *     \"sourcecred/github\": [\n *        {\"startTime\": \"2018-01-01\", \"budget\": 200}\n *     ],\n *     \"sourcecred/discord\": [\n *       {\"startTime\": \"2018-01-01\", \"budget\": 100},\n *       {\"startTime\": \"2020-01-01\", \"budget\": 200},\n *     ],\n *   }\n * }\n * ```\n */const rawPeriodParser=_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"object\"]({startTime:_util_timestamp__WEBPACK_IMPORTED_MODULE_2__[\"timestampISOParser\"],budget:_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"number\"]});const rawParser=_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"object\"]({intervalLength:_core_mintBudget__WEBPACK_IMPORTED_MODULE_0__[\"intervalLengthParser\"],plugins:_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"dict\"](_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"array\"](rawPeriodParser),_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"parser\"])});function upgradeRawPeriod(p){return{budgetValue:p.budget,startTimeMs:Object(_util_timestamp__WEBPACK_IMPORTED_MODULE_2__[\"fromISO\"])(p.startTime)};}async function upgrade(config,storage){const entries=await Promise.all(Object.keys(config.plugins).map(async key=>{const id=Object(_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"fromString\"])(key);const declaration=await Object(_bundledDeclarations__WEBPACK_IMPORTED_MODULE_4__[\"getPluginDeclaration\"])(id,storage);if(id==null){throw new Error(\"No available plugin with id \".concat(id));}const prefix=declaration.nodePrefix;const periods=config.plugins[id].map(upgradeRawPeriod);return{prefix,periods};}));return{entries,intervalLength:config.intervalLength};}\n\n//# sourceURL=webpack:///./src/api/pluginBudgetConfig.js?");

/***/ }),

/***/ "./src/api/pluginId.js":
/*!*****************************!*\
  !*** ./src/api/pluginId.js ***!
  \*****************************/
/*! exports provided: fromString, getPluginOwner, getPluginName, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromString\", function() { return fromString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPluginOwner\", function() { return getPluginOwner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPluginName\", function() { return getPluginName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/**\n * A PluginId uniquely identifies a Plugin.\n *\n * Each PluginId takes a `owner/name` format, as in\n * `sourcecred/github`.\n *\n * PluginIds are canonically lower-case.\n */const regex=/^[a-z0-9-]+$/;function fromString(s){s=s.toLowerCase();const pieces=s.split(\"/\");if(pieces.length!==2){throw new Error(\"PluginId must have exactly one \\\"/\\\" separator; got \\\"\".concat(s,\"\\\"\"));}if(!pieces[0].match(regex)){throw new Error(\"plugin owner not valid: \\\"\".concat(pieces[0],\"\\\"\"));}if(!pieces[1].match(regex)){throw new Error(\"plugin name not valid: \\\"\".concat(pieces[1],\"\\\"\"));}return s;}function getPluginOwner(id){return id.split(\"/\")[0];}function getPluginName(id){return id.split(\"/\")[1];}const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],fromString);\n\n//# sourceURL=webpack:///./src/api/pluginId.js?");

/***/ }),

/***/ "./src/api/rawInstanceConfig.js":
/*!**************************************!*\
  !*** ./src/api/rawInstanceConfig.js ***!
  \**************************************/
/*! exports provided: rawParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rawParser\", function() { return rawParser; });\n/* harmony import */ var _pluginId__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginId */ \"./src/api/pluginId.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\nconst rawParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({bundledPlugins:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"array\"](_pluginId__WEBPACK_IMPORTED_MODULE_0__[\"parser\"])});\n\n//# sourceURL=webpack:///./src/api/rawInstanceConfig.js?");

/***/ }),

/***/ "./src/cli/analysis.js":
/*!*****************************!*\
  !*** ./src/cli/analysis.js ***!
  \*****************************/
/*! exports provided: analysisHelp, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analysisHelp\", function() { return analysisHelp; });\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var _api_instance_instance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/instance/instance */ \"./src/api/instance/instance.js\");\n/* harmony import */ var _api_instance_localInstance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/instance/localInstance */ \"./src/api/instance/localInstance.js\");\n/* harmony import */ var _api_main_analysis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../api/main/analysis */ \"./src/api/main/analysis.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_4__);\nvar _templateObject,_templateObject2;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const analysisCommand=async(args,std)=>{const baseDir=process.cwd();let neo4j=false;args.forEach(arg=>{switch(arg){case\"--neo4j\":case\"-n\":neo4j=true;return;}});const instance=new _api_instance_localInstance__WEBPACK_IMPORTED_MODULE_2__[\"LocalInstance\"](baseDir);const analysisInput=_objectSpread(_objectSpread({},await instance.readAnalysisInput()),{},{featureFlags:{neo4j}});const output=await Object(_api_main_analysis__WEBPACK_IMPORTED_MODULE_3__[\"analysis\"])(analysisInput);await instance.writeAnalysisOutput(output);if(neo4j&&output.neo4j)printNeo4jCommandHelp(output.neo4j,std);return 0;};const analysisHelp=async(args,std)=>{std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"      usage: sourcecred analysis [options]\\n\\n      options:\\n      -n, --neo4j     Generates CSV files that can be used to import the CredGraph into Neo4j\\n\\n      Generates data structures useful for data analysis and writes them to\\n      disk.\\n      \"],[\"\\\\\\n      usage: sourcecred analysis [options]\\n\\n      options:\\n      -n, --neo4j     Generates CSV files that can be used to import the CredGraph into Neo4j\\n\\n      Generates data structures useful for data analysis and writes them to\\n      disk.\\n      \"]))).trimRight());return 0;};function printNeo4jCommandHelp(neo4jOutput,std){std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"\\n    Neo4j CSV files generated. Now you just need to import them into a Neo4j\\n    database using neo4j-admin. Here's some help with the commands. These are\\n    our best-effort constructions, please verify their correctness before use.\\n\\n    # You must manually construct this template command.\\n    export NEO=/path/to/directory/of/your/neo4j/DBMS\\n\\n    export NEO_CSV_FOLDER=\",\"\\n\\n    # CAREFUL, this command wipes the Neo4j DB. This prepares it for a fresh import.\\n    rm -r $NEO/data/databases/neo4j ; rm -r $NEO/data/transactions/neo4j\\n\\n    $NEO/bin/neo4j-admin import --database=neo4j \\\\\\n    \",\" \\\\\\n    \",\"\\n    \"],[\"\\n    Neo4j CSV files generated. Now you just need to import them into a Neo4j\\n    database using neo4j-admin. Here's some help with the commands. These are\\n    our best-effort constructions, please verify their correctness before use.\\n\\n    # You must manually construct this template command.\\n    export NEO=/path/to/directory/of/your/neo4j/DBMS\\n\\n    export NEO_CSV_FOLDER=\",\"\\n\\n    # CAREFUL, this command wipes the Neo4j DB. This prepares it for a fresh import.\\n    rm -r $NEO/data/databases/neo4j ; rm -r $NEO/data/transactions/neo4j\\n\\n    $NEO/bin/neo4j-admin import --database=neo4j \\\\\\\\\\n    \",\" \\\\\\\\\\n    \",\"\\n    \"])),Object(path__WEBPACK_IMPORTED_MODULE_4__[\"join\"])(process.cwd(),\"output\",\"neo4j\"),[...Array(neo4jOutput.nodes.iterationsCompleted()).keys()].map(i=>\"--nodes=$NEO_CSV_FOLDER/nodes_\".concat(i+1,\".csv\")).join(\" \\\\\\n\"),[...Array(neo4jOutput.edges.iterationsCompleted()).keys()].map(i=>\"--relationships=$NEO_CSV_FOLDER/edges_\".concat(i+1,\".csv\")).join(\" \\\\\\n\")));}/* harmony default export */ __webpack_exports__[\"default\"] = (analysisCommand);\n\n//# sourceURL=webpack:///./src/cli/analysis.js?");

/***/ }),

/***/ "./src/cli/command.js":
/*!****************************!*\
  !*** ./src/cli/command.js ***!
  \****************************/
/*! exports provided: handlingErrors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"handlingErrors\", function() { return handlingErrors; });\nfunction handlingErrors(command){return async(args,stdio)=>{function die(e){stdio.err(e instanceof Error?e.stack:JSON.stringify(e));return Promise.resolve(1);}try{return command(args,stdio).catch(e=>die(e));}catch(e){return die(e);}};}\n\n//# sourceURL=webpack:///./src/cli/command.js?");

/***/ }),

/***/ "./src/cli/common.js":
/*!***************************!*\
  !*** ./src/cli/common.js ***!
  \***************************/
/*! exports provided: loadInstanceConfig, makePluginDir, makeRelativePluginDir, pluginDirectoryContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadInstanceConfig\", function() { return loadInstanceConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makePluginDir\", function() { return makePluginDir; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeRelativePluginDir\", function() { return makeRelativePluginDir; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pluginDirectoryContext\", function() { return pluginDirectoryContext; });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_disk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/disk */ \"./src/util/disk.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/storage/disk */ \"./src/core/storage/disk.js\");\n/* harmony import */ var _api_instanceConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../api/instanceConfig */ \"./src/api/instanceConfig.js\");\n/* harmony import */ var _api_pluginId__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../api/pluginId */ \"./src/api/pluginId.js\");\nfunction loadInstanceConfig(baseDir){const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_3__[\"DiskStorage\"](baseDir);const projectFilePath=Object(path__WEBPACK_IMPORTED_MODULE_0__[\"join\"])(\"sourcecred.json\");return Object(_util_storage__WEBPACK_IMPORTED_MODULE_2__[\"loadJson\"])(storage,projectFilePath,_api_instanceConfig__WEBPACK_IMPORTED_MODULE_4__[\"parser\"]);}function makePluginDir(baseDir,prefix,pluginId){const{absolutePath}=_makeDirectories(baseDir,prefix,pluginId);return absolutePath;}// For use with DataStorage implementations\nfunction makeRelativePluginDir(baseDir,prefix,pluginId){const{relativePath}=_makeDirectories(baseDir,prefix,pluginId);return relativePath;}function _makeDirectories(baseDir,prefix,pluginId){Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_5__[\"fromString\"])(pluginId);const idParts=pluginId.split(\"/\");const[pluginOwner,pluginName]=idParts;const pathComponents=[...prefix,pluginOwner,pluginName];let path=baseDir;for(const pc of pathComponents){path=Object(path__WEBPACK_IMPORTED_MODULE_0__[\"join\"])(path,pc);Object(_util_disk__WEBPACK_IMPORTED_MODULE_1__[\"mkdirx\"])(path);}return{absolutePath:path,relativePath:Object(path__WEBPACK_IMPORTED_MODULE_0__[\"join\"])(...pathComponents)};}function pluginDirectoryContext(baseDir,pluginName){const cacheDir=makePluginDir(baseDir,[\"cache\"],pluginName);const configDir=makePluginDir(baseDir,[\"config\",\"plugins\"],pluginName);return{configDirectory(){return configDir;},cacheDirectory(){return cacheDir;}};}\n\n//# sourceURL=webpack:///./src/cli/common.js?");

/***/ }),

/***/ "./src/cli/credrank.js":
/*!*****************************!*\
  !*** ./src/cli/credrank.js ***!
  \*****************************/
/*! exports provided: credRankHelp, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"credRankHelp\", function() { return credRankHelp; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ \"d3-format\");\n/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3_format__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var _util_sortBy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/sortBy */ \"./src/util/sortBy.js\");\n/* harmony import */ var _api_main_credrank__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../api/main/credrank */ \"./src/api/main/credrank.js\");\n/* harmony import */ var _core_credrank_credGraph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/credrank/credGraph */ \"./src/core/credrank/credGraph.js\");\n/* harmony import */ var _util_taskReporter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/taskReporter */ \"./src/util/taskReporter.js\");\n/* harmony import */ var _api_instance_instance__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../api/instance/instance */ \"./src/api/instance/instance.js\");\n/* harmony import */ var _api_instance_localInstance__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../api/instance/localInstance */ \"./src/api/instance/localInstance.js\");\nvar _templateObject;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}function die(std,message){std.err(\"fatal: \"+message);return 1;}const credrankCommand=async(args,std)=>{let shouldIncludeDiff=false;let isSimulation=false;let shouldRunStealth=false;let shouldZipOutput=true;const processedArgs=args.filter(arg=>{switch(arg){case\"-d\":shouldIncludeDiff=true;return false;case\"--stealth\":shouldRunStealth=true;return false;case\"-s\":case\"--simulation\":isSimulation=true;return false;case\"--no-zip\":shouldZipOutput=false;return false;default:return true;}});if(processedArgs.length!==0){return die(std,\"usage: sourcecred credrank [-d] [-s | --simulation] [--stealth] [--no-zip]\");}const taskReporter=new _util_taskReporter__WEBPACK_IMPORTED_MODULE_6__[\"LoggingTaskReporter\"]();taskReporter.start(\"credrank\");taskReporter.start(\"load data\");const baseDir=process.cwd();const instance=await new _api_instance_localInstance__WEBPACK_IMPORTED_MODULE_8__[\"LocalInstance\"](baseDir);const credrankInput=await instance.readCredrankInput();taskReporter.finish(\"load data\");taskReporter.start(\"run CredRank\");const credrankOutput=await Object(_api_main_credrank__WEBPACK_IMPORTED_MODULE_4__[\"credrank\"])(credrankInput);const{credGraph}=credrankOutput;taskReporter.finish(\"run CredRank\");if(shouldIncludeDiff){taskReporter.start(\"load prior graph\");try{const priorCredGraph=await instance.readCredGraph();printCredDiffTable(credGraph,priorCredGraph,std);}catch(e){std.out(\"Could not load or compare existing credGraph.json. Skipping diff. Error: \".concat(e.message));printCredSummaryTable(credGraph,std);}taskReporter.finish(\"load prior graph\");}else if(!shouldRunStealth){printCredSummaryTable(credGraph,std);}if(!isSimulation){taskReporter.start(\"writing changes\");instance.writeCredrankOutput(credrankOutput,shouldZipOutput);taskReporter.finish(\"writing changes\");}taskReporter.finish(\"credrank\");return 0;};function printCredSummaryTable(credGraph,std){std.out(\"# Top Participants By Cred\");std.out(\"\");std.out(\"| Description | Cred | % |\");std.out(\"| --- | --- | --- |\");const credParticipants=Array.from(credGraph.participants());const sortedParticipants=Object(_util_sortBy__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(credParticipants,p=>-p.cred);const totalCred=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(sortedParticipants,p=>p.cred);function row(_ref){let{cred,description}=_ref;const percentage=100*cred/totalCred;return\"| \".concat(description,\" | \").concat(cred.toFixed(1),\" | \").concat(percentage.toFixed(1),\"% |\");}sortedParticipants.slice(0,20).forEach(n=>std.out(row(n)));}function printCredDiffTable(credGraph,priorCredGraph,std){std.out(\"# Top Participants By New Cred\");const priorParticipants=new Map();for(const participant of priorCredGraph.participants())priorParticipants.set(participant.id,participant);const credParticipants=Array.from(credGraph.participants());const sortedParticipants=Object(_util_sortBy__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(credParticipants,p=>-p.cred);if(credParticipants.length!==Array.from(priorParticipants.keys()).length)throw Error(\"Number of participants has changed. Rerun without -d to refresh.\");function row(_ref2){let{cred,description,id}=_ref2;const prior=priorParticipants.get(id);if(!prior)throw Error(\"Participant [\".concat(description,\", \").concat(id,\"] exists in the new scores but not in the old. Rerun without -d to refresh.\"));const changeFactor=(cred-prior.cred)/prior.cred;const percentageChangeStr=changeFactor>100?\">10,000%\":Object(d3_format__WEBPACK_IMPORTED_MODULE_1__[\"format\"])(\",.1%\")(changeFactor);return{\"Name\":description,\"Prior Cred\":prior.cred.toFixed(1),\"New Cred\":cred.toFixed(1),\"% Change\":percentageChangeStr};}console.table(sortedParticipants.slice(0,20).map(n=>row(n)));}const credRankHelp=async(args,std)=>{std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"      usage: sourcecred credrank [options] \\n\\n      options:\\n      -d                    outputs a comparison table between the current graph and the prior graph        \\n      -s, --simulation      doesn't update the current graph and ledger json\\n          --stealth         skip the output of the summary table\\n          --no-zip          write the output as JSON without compressing large files\\n\\n      Calculate cred scores from existing graph\\n      \"],[\"\\\\\\n      usage: sourcecred credrank [options] \\n\\n      options:\\n      -d                    outputs a comparison table between the current graph and the prior graph        \\n      -s, --simulation      doesn't update the current graph and ledger json\\n          --stealth         skip the output of the summary table\\n          --no-zip          write the output as JSON without compressing large files\\n\\n      Calculate cred scores from existing graph\\n      \"]))).trimRight());return 0;};/* harmony default export */ __webpack_exports__[\"default\"] = (credrankCommand);\n\n//# sourceURL=webpack:///./src/cli/credrank.js?");

/***/ }),

/***/ "./src/cli/go.js":
/*!***********************!*\
  !*** ./src/cli/go.js ***!
  \***********************/
/*! exports provided: goHelp, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"goHelp\", function() { return goHelp; });\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var _load__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./load */ \"./src/cli/load.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graph */ \"./src/cli/graph.js\");\n/* harmony import */ var _credrank__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./credrank */ \"./src/cli/credrank.js\");\nvar _templateObject;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}function die(std,message){std.err(\"fatal: \"+message);return 1;}const NO_LOAD_ARG=\"--no-load\";const goCommand=async(args,std)=>{let noLoad=false;if(args.length===1&&args[0]===NO_LOAD_ARG){noLoad=true;}else if(args.length!==0){return die(std,\"usage: sourcecred go [--no-load]\");}const commandSequence=[{name:\"load\",command:_load__WEBPACK_IMPORTED_MODULE_1__[\"default\"],args:[]},{name:\"graph\",command:_graph__WEBPACK_IMPORTED_MODULE_2__[\"default\"],args:[]},{name:\"credrank\",command:_credrank__WEBPACK_IMPORTED_MODULE_3__[\"default\"],args:[]}];for(const{name,command,args}of commandSequence){if(name===\"load\"&&noLoad)continue;const ret=await command(args,std);if(ret!==0){return die(std,\"go: failed on command \".concat(name));}}return 0;};const goHelp=async(args,std)=>{std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"      usage: sourcecred go [--no-load]\\n\\n      Load data from plugins, build a graph and generate cred scores.\\n\\n      Under the hood, this runs 'sourcecred load', 'sourcecred graph' and\\n      'sourcecred credrank' in sequence. If the '--no-load' argument is\\n      provided, then the load step will be skipped, using data from cache\\n      instead.\\n\\n      If any command in the sequence fails, the sequence will bail and\\n      subsequent commands will not be executed.\\n      \"],[\"\\\\\\n      usage: sourcecred go [--no-load]\\n\\n      Load data from plugins, build a graph and generate cred scores.\\n\\n      Under the hood, this runs 'sourcecred load', 'sourcecred graph' and\\n      'sourcecred credrank' in sequence. If the '--no-load' argument is\\n      provided, then the load step will be skipped, using data from cache\\n      instead.\\n\\n      If any command in the sequence fails, the sequence will bail and\\n      subsequent commands will not be executed.\\n      \"]))).trimRight());return 0;};/* harmony default export */ __webpack_exports__[\"default\"] = (goCommand);\n\n//# sourceURL=webpack:///./src/cli/go.js?");

/***/ }),

/***/ "./src/cli/grain.js":
/*!**************************!*\
  !*** ./src/cli/grain.js ***!
  \**************************/
/*! exports provided: grainHelp, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"grainHelp\", function() { return grainHelp; });\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var _core_ledger_distributionSummary_distributionSummary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ledger/distributionSummary/distributionSummary */ \"./src/core/ledger/distributionSummary/distributionSummary.js\");\n/* harmony import */ var _core_ledger_distributionSummary_allocationSummary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ledger/distributionSummary/allocationSummary */ \"./src/core/ledger/distributionSummary/allocationSummary.js\");\n/* harmony import */ var _core_ledger_grain__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/ledger/grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _api_instance_instance__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../api/instance/instance */ \"./src/api/instance/instance.js\");\n/* harmony import */ var _api_instance_localInstance__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../api/instance/localInstance */ \"./src/api/instance/localInstance.js\");\n/* harmony import */ var _api_main_grain__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../api/main/grain */ \"./src/api/main/grain.js\");\nvar _templateObject;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}function die(std,message){std.err(\"fatal: \"+message);return 1;}const grainCommand=async(args,std)=>{let simulation=false;let allowMultipleDistributionsPerInterval=false;const processedArgs=args.filter(arg=>{switch(arg){case\"-f\":case\"--force\":allowMultipleDistributionsPerInterval=true;return false;case\"-s\":case\"--simulation\":simulation=true;return false;default:return true;}});if(processedArgs.length){return die(std,\"usage: sourcecred grain [--simulation | -s] [--force | -f]\");}const baseDir=process.cwd();const instance=new _api_instance_localInstance__WEBPACK_IMPORTED_MODULE_5__[\"LocalInstance\"](baseDir);const grainInput=await instance.readGrainInput();grainInput.allowMultipleDistributionsPerInterval=allowMultipleDistributionsPerInterval;const{distributions,ledger:ledgerBeforeIntegrations}=await Object(_api_main_grain__WEBPACK_IMPORTED_MODULE_6__[\"grain\"])(grainInput);const{results,ledger}=Object(_api_main_grain__WEBPACK_IMPORTED_MODULE_6__[\"executeGrainIntegrationsFromGrainInput\"])(grainInput,ledgerBeforeIntegrations,distributions);for(const result of results){instance.writeGrainIntegrationOutput(result);}let totalDistributed=_core_ledger_grain__WEBPACK_IMPORTED_MODULE_3__[\"ZERO\"];const recipientIdentities=new Set();for(const{allocations}of distributions){for(const{receipts}of allocations){for(const{amount,id}of receipts){totalDistributed=_core_ledger_grain__WEBPACK_IMPORTED_MODULE_3__[\"add\"](amount,totalDistributed);recipientIdentities.add(id);}}}std.out((simulation?\"\\u2014\\u2014SIMULATED DISTRIBUTION\\u2014\\u2014\\n\":\"\")+\"Distributed \".concat(_core_ledger_grain__WEBPACK_IMPORTED_MODULE_3__[\"formatAndTrim\"](totalDistributed),\" to \").concat(recipientIdentities.size,\" identities in \").concat(distributions.length,\" distributions\")+\"\\n\");distributions.map(d=>{std.out(Object(_core_ledger_distributionSummary_distributionSummary__WEBPACK_IMPORTED_MODULE_1__[\"distributionMarkdownSummary\"])(d,ledger,grainInput.currencyDetails));d.allocations.map(a=>{std.out(Object(_core_ledger_distributionSummary_allocationSummary__WEBPACK_IMPORTED_MODULE_2__[\"allocationMarkdownSummary\"])(d,a,ledger));});});if(!simulation){instance.writeLedger(ledger);}return 0;};const grainHelp=async(args,std)=>{std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"      usage: sourcecred grain [--simulation | -s] [--force | -f]\\n\\n      Distribute Grain (or whatever currency this Cred instance is tracking)\\n      for Cred intervals in which Grain was not already distributed.\\n\\n      When the '--simulation' (-s) flag is provided, no grain will actually be distributed,\\n      allowing for testing the output of various configurations.\\n\\n      When the '--force' (-f) flag is provided, it will overwrite the last distribution\\n      if a distribution already exists for the past interval.\\n\\n      When run, this will identify all the completed Cred intervals (currently, weeks)\\n      and find the latest Cred interval for which there was no Grain distribution.\\n      Then, it will distribute Grain for all of them, making a corresponding change\\n      to the Ledger. This could result in zero or more distributions, depending on how\\n      many recent Cred intervals had no corresponding Grain distribution.\\n\\n      Grain is distributed based on the configuration in the config/grain.json\\n      file. The fields are as follows:\\n\\n      immediatePerWeek: The amount of grain to distribute for activity in the most\\n      recent period. (value type: integer)\\n\\n      balancedPerWeek: The amount of grain to distribute according to all-time cred\\n      scores. (value type: integer)\\n\\n      maxSimultaneousDistributions: The maximum number of distributions to create in\\n      a single 'sourcecred grain' call if distributions have been missed. If set to\\n      1, then the command will create at most one distribution. If unset, defaults\\n      to Infinity.\\n      (value type: integer)\\n      \"],[\"\\\\\\n      usage: sourcecred grain [--simulation | -s] [--force | -f]\\n\\n      Distribute Grain (or whatever currency this Cred instance is tracking)\\n      for Cred intervals in which Grain was not already distributed.\\n\\n      When the '--simulation' (-s) flag is provided, no grain will actually be distributed,\\n      allowing for testing the output of various configurations.\\n\\n      When the '--force' (-f) flag is provided, it will overwrite the last distribution\\n      if a distribution already exists for the past interval.\\n\\n      When run, this will identify all the completed Cred intervals (currently, weeks)\\n      and find the latest Cred interval for which there was no Grain distribution.\\n      Then, it will distribute Grain for all of them, making a corresponding change\\n      to the Ledger. This could result in zero or more distributions, depending on how\\n      many recent Cred intervals had no corresponding Grain distribution.\\n\\n      Grain is distributed based on the configuration in the config/grain.json\\n      file. The fields are as follows:\\n\\n      immediatePerWeek: The amount of grain to distribute for activity in the most\\n      recent period. (value type: integer)\\n\\n      balancedPerWeek: The amount of grain to distribute according to all-time cred\\n      scores. (value type: integer)\\n\\n      maxSimultaneousDistributions: The maximum number of distributions to create in\\n      a single 'sourcecred grain' call if distributions have been missed. If set to\\n      1, then the command will create at most one distribution. If unset, defaults\\n      to Infinity.\\n      (value type: integer)\\n      \"]))).trimRight());return 0;};/* harmony default export */ __webpack_exports__[\"default\"] = (grainCommand);\n\n//# sourceURL=webpack:///./src/cli/grain.js?");

/***/ }),

/***/ "./src/cli/graph.js":
/*!**************************!*\
  !*** ./src/cli/graph.js ***!
  \**************************/
/*! exports provided: graphHelp, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"graphHelp\", function() { return graphHelp; });\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_taskReporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/taskReporter */ \"./src/util/taskReporter.js\");\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _core_weights__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/weights */ \"./src/core/weights.js\");\n/* harmony import */ var _api_pluginId__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../api/pluginId */ \"./src/api/pluginId.js\");\n/* harmony import */ var _api_instance_instance__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../api/instance/instance */ \"./src/api/instance/instance.js\");\n/* harmony import */ var _api_instance_localInstance__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../api/instance/localInstance */ \"./src/api/instance/localInstance.js\");\n/* harmony import */ var _api_main_graph__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../api/main/graph */ \"./src/api/main/graph.js\");\nvar _templateObject;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}function die(std,message){std.err(\"fatal: \"+message);return 1;}const graphCommand=async(args,std)=>{let shouldIncludeDiff=false;let isSimulation=false;let shouldZipOutput=true;const processedArgs=args.filter(arg=>{switch(arg){case\"-d\":shouldIncludeDiff=true;return false;case\"--simulation\":case\"-s\":isSimulation=true;return false;case\"--no-zip\":shouldZipOutput=false;return false;default:return true;}});const taskReporter=new _util_taskReporter__WEBPACK_IMPORTED_MODULE_1__[\"LoggingTaskReporter\"]();taskReporter.start(\"graph\");const baseDir=process.cwd();const instance=await new _api_instance_localInstance__WEBPACK_IMPORTED_MODULE_7__[\"LocalInstance\"](baseDir);const graphInput=await instance.readGraphInput();const availablePlugins=graphInput.plugins.map(_ref=>{let{pluginId}=_ref;return pluginId;});let pluginsToLoad=[];if(processedArgs.length===0){pluginsToLoad=availablePlugins;}else{for(const arg of processedArgs){const id=_api_pluginId__WEBPACK_IMPORTED_MODULE_5__[\"fromString\"](arg);if(availablePlugins.includes(id)){pluginsToLoad.push(id);}else{return die(std,\"can't find plugin \".concat(id,\"; remember to use fully scoped name, as in sourcecred/github\"));}}}const graphOutput=await Object(_api_main_graph__WEBPACK_IMPORTED_MODULE_8__[\"graph\"])(graphInput,pluginsToLoad,taskReporter);if(shouldIncludeDiff){for(const{pluginId,weightedGraph}of graphOutput.pluginGraphs){const diffTask=\"\".concat(pluginId,\": diffing with existing graph\");taskReporter.start(diffTask);try{const oldWeightedGraph=await instance.readWeightedGraphForPlugin(pluginId);computeAndLogDiff(oldWeightedGraph,weightedGraph,pluginId,std);}catch(error){std.out(\"Could not find or compare existing graph.json for \".concat(pluginId,\". \").concat(error));}taskReporter.finish(diffTask);}}if(!isSimulation){taskReporter.start(\"writing files\");await instance.writeGraphOutput(graphOutput,shouldZipOutput);taskReporter.finish(\"writing files\");}taskReporter.finish(\"graph\");return 0;};const graphHelp=async(args,std)=>{std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"      usage: sourcecred graph [options]\\n\\n      options:\\n      -d  Outputs the diff of changes compared to the last saved graph.\\n      -s, --simulation  Skips writing changes to the graph and ledger jsons.\\n      --no-zip  Writes the output as JSON without compressing large files\\n\\n      Generate a graph from cached plugin data\\n\\n      Either 'sourcecred load' must immediately precede this command or\\n      a cache directory must exist for all plugins specified in sourcecred.json\\n      \"],[\"\\\\\\n      usage: sourcecred graph [options]\\n\\n      options:\\n      -d  Outputs the diff of changes compared to the last saved graph.\\n      -s, --simulation  Skips writing changes to the graph and ledger jsons.\\n      --no-zip  Writes the output as JSON without compressing large files\\n\\n      Generate a graph from cached plugin data\\n\\n      Either 'sourcecred load' must immediately precede this command or\\n      a cache directory must exist for all plugins specified in sourcecred.json\\n      \"]))).trimRight());return 0;};function computeAndLogDiff(oldWeightedGraph,newWeightedGraph,pluginName,std){const graphDiff=Object(_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"compareGraphs\"])(oldWeightedGraph.graph,newWeightedGraph.graph);const weightDiff=Object(_core_weights__WEBPACK_IMPORTED_MODULE_4__[\"compareWeights\"])(oldWeightedGraph.weights,newWeightedGraph.weights);const horizontalRule=\"=============================================================\";if(graphDiff.nodeDiffs.length>0){std.out(\"\".concat(horizontalRule,\"\\n  \").concat(pluginName,\" - Node Diffs\\n\").concat(horizontalRule));for(const nodeDiff of graphDiff.nodeDiffs){std.out(\"Old:\\t\".concat(nodeDiff.first?Object(_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"nodeToString\"])(nodeDiff.first):\"No matching address\"));std.out(\"New:\\t\".concat(nodeDiff.second?Object(_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"nodeToString\"])(nodeDiff.second):\"No matching address\",\"\\n\"));}}if(weightDiff.nodeWeightDiffs.length>0){std.out(\"\".concat(horizontalRule,\"\\n  \").concat(pluginName,\" - Node Weight Diffs\\n\").concat(horizontalRule));for(const nodeWeightDiff of weightDiff.nodeWeightDiffs){std.out(\"\".concat(_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"NodeAddress\"].toString(nodeWeightDiff.address)));std.out(\"Old:\\t\".concat(nodeWeightDiff.first!=null?nodeWeightDiff.first.toString():\"No matching address\"));std.out(\"New:\\t\".concat(nodeWeightDiff.second!=null?nodeWeightDiff.second.toString():\"No matching address\",\"\\n\"));}}if(graphDiff.edgeDiffs.length>0){std.out(\"\".concat(horizontalRule,\"\\n  \").concat(pluginName,\" - Edge Diffs\\n\").concat(horizontalRule));for(const edgeDiff of graphDiff.edgeDiffs){std.out(\"Old:\\t\".concat(edgeDiff.first?Object(_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"edgeToString\"])(edgeDiff.first):\"No matching address\"));std.out(\"New:\\t\".concat(edgeDiff.second?Object(_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"edgeToString\"])(edgeDiff.second):\"No matching address\",\"\\n\"));}}if(weightDiff.edgeWeightDiffs.length>0){std.out(\"\".concat(horizontalRule,\"\\n  \").concat(pluginName,\" - Edge Weight Diffs\\n\").concat(horizontalRule));for(const edgeWeightDiff of weightDiff.edgeWeightDiffs){std.out(\"\".concat(_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"EdgeAddress\"].toString(edgeWeightDiff.address)));std.out(\"Old:\\t\".concat(edgeWeightDiff.first?json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(edgeWeightDiff.first):\"No matching address\"));std.out(\"New:\\t\".concat(edgeWeightDiff.second?json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(edgeWeightDiff.second):\"No matching address\",\"\\n\"));}}if(graphDiff.graphsAreEqual&&weightDiff.weightsAreEqual)std.out(\"\".concat(horizontalRule,\"\\n  \").concat(pluginName,\" - Unchanged\\n\").concat(horizontalRule));else std.out(\"\".concat(horizontalRule,\"\\n  \").concat(pluginName,\" - Summary of Changes\\n\").concat(horizontalRule,\"\\nNode Diffs: \").concat(graphDiff.nodeDiffs.length,\"\\nNode Weight Diffs: \").concat(weightDiff.nodeWeightDiffs.length,\"\\nEdge Diffs: \").concat(graphDiff.edgeDiffs.length,\"\\nEdge Weight Diffs: \").concat(weightDiff.edgeWeightDiffs.length));}/* harmony default export */ __webpack_exports__[\"default\"] = (graphCommand);\n\n//# sourceURL=webpack:///./src/cli/graph.js?");

/***/ }),

/***/ "./src/cli/help.js":
/*!*************************!*\
  !*** ./src/cli/help.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _go__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./go */ \"./src/cli/go.js\");\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grain */ \"./src/cli/grain.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graph */ \"./src/cli/graph.js\");\n/* harmony import */ var _load__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./load */ \"./src/cli/load.js\");\n/* harmony import */ var _serve__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./serve */ \"./src/cli/serve.js\");\n/* harmony import */ var _site__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./site */ \"./src/cli/site.js\");\n/* harmony import */ var _credrank__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./credrank */ \"./src/cli/credrank.js\");\n/* harmony import */ var _analysis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./analysis */ \"./src/cli/analysis.js\");\n/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./update */ \"./src/cli/update.js\");\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\nvar _templateObject,_templateObject2;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}// Implementation of `sourcecred help`.\nconst help=async(args,std)=>{if(args.length===0){usage(std.out);return 0;}const command=args[0];const subHelps={help:metaHelp,go:_go__WEBPACK_IMPORTED_MODULE_0__[\"goHelp\"],load:_load__WEBPACK_IMPORTED_MODULE_3__[\"loadHelp\"],graph:_graph__WEBPACK_IMPORTED_MODULE_2__[\"graphHelp\"],grain:_grain__WEBPACK_IMPORTED_MODULE_1__[\"grainHelp\"],site:_site__WEBPACK_IMPORTED_MODULE_5__[\"siteHelp\"],credrank:_credrank__WEBPACK_IMPORTED_MODULE_6__[\"credRankHelp\"],serve:_serve__WEBPACK_IMPORTED_MODULE_4__[\"serveHelp\"],analysis:_analysis__WEBPACK_IMPORTED_MODULE_7__[\"analysisHelp\"],update:_update__WEBPACK_IMPORTED_MODULE_8__[\"updateHelp\"]};if(subHelps[command]!==undefined){return subHelps[command](args.slice(1),std);}else{usage(std.err);return 1;}};function usage(print){// TODO: Make the usage function pull its list of commands\n// from the sub-helps, to ensure that it is comprehensive\nprint(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"    usage: sourcecred COMMAND [ARGS...]\\n           sourcecred [--version] [--help]\\n\\n    Commands:\\n\\n      MAIN\\n      go            load plugin data and generate cred scores\\n      serve         serve admin site locally to update Ledger and Identities\\n      grain         calculate and record grain distribution(s) in the ledger\\n\\n      AUXILIARY\\n      load          load plugin data into cache\\n      graph         build Cred graph from cached plugin data\\n      site          update your cred site with the latest changes\\n      credrank      calculate cred scores from existing graph\\n      analysis      generates useful data analysis structures\\n      help          show this help message\\n\\n    Use 'sourcecred help COMMAND' for help about an individual command.\\n    \"],[\"\\\\\\n    usage: sourcecred COMMAND [ARGS...]\\n           sourcecred [--version] [--help]\\n\\n    Commands:\\n\\n      MAIN\\n      go            load plugin data and generate cred scores\\n      serve         serve admin site locally to update Ledger and Identities\\n      grain         calculate and record grain distribution(s) in the ledger\\n\\n      AUXILIARY\\n      load          load plugin data into cache\\n      graph         build Cred graph from cached plugin data\\n      site          update your cred site with the latest changes\\n      credrank      calculate cred scores from existing graph\\n      analysis      generates useful data analysis structures\\n      help          show this help message\\n\\n    Use 'sourcecred help COMMAND' for help about an individual command.\\n    \"]))).trimRight());}const metaHelp=async(args,std)=>{if(args.length===0){std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"      usage: sourcecred help [COMMAND]\\n\\n      Use 'sourcecred help' for general help and a list of commands.\\n      Use 'sourcecred help COMMAND' for help about COMMAND.\\n      \"],[\"\\\\\\n      usage: sourcecred help [COMMAND]\\n\\n      Use 'sourcecred help' for general help and a list of commands.\\n      Use 'sourcecred help COMMAND' for help about COMMAND.\\n      \"]))).trimRight());return 0;}else{usage(std.err);return 1;}};/* harmony default export */ __webpack_exports__[\"default\"] = (help);\n\n//# sourceURL=webpack:///./src/cli/help.js?");

/***/ }),

/***/ "./src/cli/load.js":
/*!*************************!*\
  !*** ./src/cli/load.js ***!
  \*************************/
/*! exports provided: loadHelp, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadHelp\", function() { return loadHelp; });\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./src/cli/common.js\");\n/* harmony import */ var _util_taskReporter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/taskReporter */ \"./src/util/taskReporter.js\");\n/* harmony import */ var _api_pluginId__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../api/pluginId */ \"./src/api/pluginId.js\");\n/* harmony import */ var _util_disk__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/disk */ \"./src/util/disk.js\");\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! fs-extra */ \"fs-extra\");\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(fs_extra__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! chalk */ \"chalk\");\n/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(chalk__WEBPACK_IMPORTED_MODULE_7__);\nvar _templateObject;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}function die(std,message){std.err(\"fatal: \"+message);return 1;}function warn(std,task,message){const label=chalk__WEBPACK_IMPORTED_MODULE_7___default.a.bgYellow.bold.white(\" WARN \");std.err(\"\".concat(label,\" \").concat(task,\": \").concat(message));}function fail(std,task){let message=arguments.length>2&&arguments[2]!==undefined?arguments[2]:\"\";const label=chalk__WEBPACK_IMPORTED_MODULE_7___default.a.bgRed.bold.white(\" FAIL \");std.err(\"\".concat(label,\" \").concat(task).concat(message?\": \".concat(message):\"\"));}const loadCommand=async(args,std)=>{let pluginsToLoad=[];const baseDir=process.cwd();const config=await Object(_common__WEBPACK_IMPORTED_MODULE_1__[\"loadInstanceConfig\"])(baseDir);if(args.length===0){pluginsToLoad=Array.from(config.bundledPlugins.keys());if(pluginsToLoad.length===0){std.err(\"No plugins configured; Please set up at least one plugin: \"+\"https://github.com/sourcecred/template-instance#supported-plugins\");}}else{for(const arg of args){const id=_api_pluginId__WEBPACK_IMPORTED_MODULE_3__[\"parser\"].parseOrThrow(arg);if(config.bundledPlugins.has(id)){pluginsToLoad.push(id);}else{return die(std,\"can't find plugin \".concat(id,\"; remember to use fully scoped name, as in sourcecred/github\"));}}}const taskReporter=new _util_taskReporter__WEBPACK_IMPORTED_MODULE_2__[\"LoggingTaskReporter\"](std.out);taskReporter.start(\"load\");const failedPlugins=[];const loadPromises=[];const cacheEmpty=new Map();for(const name of pluginsToLoad){const plugin=_util_null__WEBPACK_IMPORTED_MODULE_0__[\"get\"](config.bundledPlugins.get(name));const task=\"loading \".concat(name);taskReporter.start(task);const dirContext=Object(_common__WEBPACK_IMPORTED_MODULE_1__[\"pluginDirectoryContext\"])(baseDir,name);const childTaskReporter=new _util_taskReporter__WEBPACK_IMPORTED_MODULE_2__[\"ScopedTaskReporter\"](taskReporter,name);const loadPlugin=()=>plugin.load(dirContext,childTaskReporter).then(()=>taskReporter.finish(task));const endChildRunners=()=>{// create static array of taskIds from activeTasks map\nArray.from(taskReporter.activeTasks.keys()).filter(taskId=>taskId.startsWith(name)).forEach(taskId=>{taskReporter.finish(taskId);warn(std,taskId,\"Parent task restarting. Retrying\");});};const restartParentRunner=error=>{taskReporter.finish(task);warn(std,task,\"Error updating cache. clearing cache and restarting.\\n        This is the error from the plugin:\\n\\n        \".concat(error));taskReporter.start(task);};cacheEmpty.set(name,Object(_util_disk__WEBPACK_IMPORTED_MODULE_4__[\"isDirEmpty\"])(dirContext.cacheDirectory()));const loadWithPossibleRetry=loadPlugin().catch(e=>{if(!cacheEmpty.get(name)){// remove child runner entries\nendChildRunners();restartParentRunner(e);// clear the cache and try again\nfs_extra__WEBPACK_IMPORTED_MODULE_6___default.a.emptyDirSync(dirContext.cacheDirectory());return loadPlugin();}throw e;}).catch(e=>{const output=e instanceof Error?e:JSON.stringify(e);fail(std,name,output);failedPlugins.push(name);});loadPromises.push(loadWithPossibleRetry);}await Promise.all(loadPromises);taskReporter.finish(\"load\");if(failedPlugins.length){return die(std,\"load failed for plugins: \".concat(failedPlugins.join(\", \")));}return 0;};const loadHelp=async(args,std)=>{std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"      usage: sourcecred load\\n\\n      Load user activity into the cache via plugins\\n\\n      load pulls user data from each plugin listed in sourcecred.json\\n      \"],[\"\\\\\\n      usage: sourcecred load\\n\\n      Load user activity into the cache via plugins\\n\\n      load pulls user data from each plugin listed in sourcecred.json\\n      \"]))).trimRight());return 0;};/* harmony default export */ __webpack_exports__[\"default\"] = (loadCommand);\n\n//# sourceURL=webpack:///./src/cli/load.js?");

/***/ }),

/***/ "./src/cli/main.js":
/*!*************************!*\
  !*** ./src/cli/main.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return main; });\n/* harmony import */ var _command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./command */ \"./src/cli/command.js\");\n/* harmony import */ var _sourcecred__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sourcecred */ \"./src/cli/sourcecred.js\");\n__webpack_require__(/*! ../tools/entry */ \"./src/tools/entry.js\");function main(){return Object(_command__WEBPACK_IMPORTED_MODULE_0__[\"handlingErrors\"])(_sourcecred__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(process.argv.slice(2),{out:x=>console.log(x),err:x=>console.error(x)}).then(exitCode=>{process.exitCode=exitCode;});}// Only run in the Webpack bundle, not as a Node module (during tests).\n/* istanbul ignore next */ /*:: declare var __webpack_require__: mixed; */ // eslint-disable-next-line camelcase\nif(true){main();}\n\n//# sourceURL=webpack:///./src/cli/main.js?");

/***/ }),

/***/ "./src/cli/serve.js":
/*!**************************!*\
  !*** ./src/cli/serve.js ***!
  \**************************/
/*! exports provided: serveHelp, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"serveHelp\", function() { return serveHelp; });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/cli/common.js\");\n/* harmony import */ var _site__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./site */ \"./src/cli/site.js\");\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\nvar _templateObject;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}const fs=__webpack_require__(/*! fs */ \"fs\");const express=__webpack_require__(/*! express */ \"express\");function die(std,message){std.err(\"fatal: \"+message);return 1;}const serveCommand=async(args,std)=>{const returnVal=await Object(_site__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([],std);if(returnVal!==0){return die(std,\"site: SourceCred site instance failed to update\");}const basedir=process.cwd();// check to ensure service is running within an instance directory\nawait Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"loadInstanceConfig\"])(basedir);if(args.length!==0){return die(std,\"usage: sourcecred admin\");}const server=express();// override static config to enable ledger updates\nserver.get(\"/static/server-info.json\",(_unused_req,res)=>{res.status(200).send({hasBackend:true});});// serve the static admin site and all subdirectories\n// also enables GETing data/ledger.json\nserver.use(express.static(\"./site\"));// middleware that parses text request bodies for us\nserver.use(express.text({limit:\"50mb\"}));// write posted ledger.json files to disk\nserver.post(\"/data/ledger.json\",(req,res)=>{try{fs.writeFileSync(\"./data/ledger.json\",req.body,\"utf8\");}catch(e){res.status(500).send(\"error saving ledger.json file: \".concat(e));}res.status(201).end();});server.listen(6006,()=>{console.info(\"admin server running: navigate to http://localhost:6006\");});return 0;};const serveHelp=async(args,std)=>{std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"      usage: sourcecred serve\\n\\n      Serve the admin site locally\\n\\n      Creates an express server that enables users to create\\n      grain transfers between users, and update user identities. It also shows\\n      the dashboards available on the publicly available static site generated\\n      by the instance.\\n\\n      Running serve will automatically run site first, so that the version of the\\n      site being served matches the version of SourceCred currently being used.\\n      \"],[\"\\\\\\n      usage: sourcecred serve\\n\\n      Serve the admin site locally\\n\\n      Creates an express server that enables users to create\\n      grain transfers between users, and update user identities. It also shows\\n      the dashboards available on the publicly available static site generated\\n      by the instance.\\n\\n      Running serve will automatically run site first, so that the version of the\\n      site being served matches the version of SourceCred currently being used.\\n      \"]))).trimRight());return 0;};/* harmony default export */ __webpack_exports__[\"default\"] = (serveCommand);\n\n//# sourceURL=webpack:///./src/cli/serve.js?");

/***/ }),

/***/ "./src/cli/site.js":
/*!*************************!*\
  !*** ./src/cli/site.js ***!
  \*************************/
/*! exports provided: siteHelp, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"siteHelp\", function() { return siteHelp; });\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs-extra */ \"fs-extra\");\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs_extra__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ \"./src/cli/common.js\");\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\nvar _templateObject;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}const SITE_TEMPLATE_DIR=\"site-template\";const SITE_OUTPUT=\"site\";// under instance dir\n// Targets to symlink from the instance into the site dir\nconst SYMLINK_TARGETS=[\"sourcecred.json\",\"data\",\"config\",\"output\"];function die(std,message){std.err(\"fatal: \"+message);return 1;}const siteCommand=async(args,std)=>{if(args.length!==0){return die(std,\"usage: sourcecred site\");}const siteTemplate=Object(path__WEBPACK_IMPORTED_MODULE_1__[\"join\"])(__dirname,SITE_TEMPLATE_DIR);await fs_extra__WEBPACK_IMPORTED_MODULE_0___default.a.copy(siteTemplate,SITE_OUTPUT,{dereference:true});const instanceDir=process.cwd();// Will error if we aren't in a valid SourceCred instance.\nawait Object(_common__WEBPACK_IMPORTED_MODULE_2__[\"loadInstanceConfig\"])(instanceDir);// Link in all the instance data that is referenced by the site.\nfor(const target of SYMLINK_TARGETS){const src=Object(path__WEBPACK_IMPORTED_MODULE_1__[\"join\"])(instanceDir,target);const dst=Object(path__WEBPACK_IMPORTED_MODULE_1__[\"join\"])(SITE_OUTPUT,target);await lnsf(src,dst);}return 0;};// Create a symlink, overwriting if it exists, like `ln -sf`.\nasync function lnsf(src,dst){try{await fs_extra__WEBPACK_IMPORTED_MODULE_0___default.a.symlink(src,dst);}catch(e){if(e.code!==\"EEXIST\"){throw e;}}await fs_extra__WEBPACK_IMPORTED_MODULE_0___default.a.unlink(dst);await fs_extra__WEBPACK_IMPORTED_MODULE_0___default.a.symlink(src,dst);}const siteHelp=async(args,std)=>{std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"      usage: sourcecred site\\n\\n      Update your instance site to the latest release.\\n\\n      Running 'sourcecred site' will copy the latest frontend from the sourcecred \\n      CLI into the current sourcecred instance.\\n      \"],[\"\\\\\\n      usage: sourcecred site\\n\\n      Update your instance site to the latest release.\\n\\n      Running 'sourcecred site' will copy the latest frontend from the sourcecred \\n      CLI into the current sourcecred instance.\\n      \"]))).trimRight());return 0;};/* harmony default export */ __webpack_exports__[\"default\"] = (siteCommand);\n\n//# sourceURL=webpack:///./src/cli/site.js?");

/***/ }),

/***/ "./src/cli/sourcecred.js":
/*!*******************************!*\
  !*** ./src/cli/sourcecred.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/version */ \"./src/core/version.js\");\n/* harmony import */ var _load__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./load */ \"./src/cli/load.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graph */ \"./src/cli/graph.js\");\n/* harmony import */ var _site__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./site */ \"./src/cli/site.js\");\n/* harmony import */ var _go__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./go */ \"./src/cli/go.js\");\n/* harmony import */ var _serve__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./serve */ \"./src/cli/serve.js\");\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./grain */ \"./src/cli/grain.js\");\n/* harmony import */ var _credrank__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./credrank */ \"./src/cli/credrank.js\");\n/* harmony import */ var _analysis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./analysis */ \"./src/cli/analysis.js\");\n/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./update */ \"./src/cli/update.js\");\n/* harmony import */ var _help__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./help */ \"./src/cli/help.js\");\nconst sourcecred=async(args,std)=>{if(args.length===0){Object(_help__WEBPACK_IMPORTED_MODULE_10__[\"default\"])([],{out:std.err,err:std.err});return 1;}switch(args[0]){case\"--version\":std.out(\"sourcecred \"+_core_version__WEBPACK_IMPORTED_MODULE_0__[\"VERSION_SHORT\"]);return 0;case\"--help\":case\"help\":return Object(_help__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(args.slice(1),std);case\"load\":return Object(_load__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(args.slice(1),std);case\"graph\":return Object(_graph__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(args.slice(1),std);case\"site\":return Object(_site__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(args.slice(1),std);case\"go\":return Object(_go__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(args.slice(1),std);case\"serve\":return Object(_serve__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(args.slice(1),std);case\"grain\":return Object(_grain__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(args.slice(1),std);case\"credrank\":return Object(_credrank__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(args.slice(1),std);case\"analysis\":return Object(_analysis__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(args.slice(1),std);case\"update\":return Object(_update__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(args.slice(1),std);default:std.err(\"fatal: unknown command: \"+JSON.stringify(args[0]));std.err(\"fatal: run 'sourcecred help' for commands and usage\");return 1;}};/* harmony default export */ __webpack_exports__[\"default\"] = (sourcecred);\n\n//# sourceURL=webpack:///./src/cli/sourcecred.js?");

/***/ }),

/***/ "./src/cli/update.js":
/*!***************************!*\
  !*** ./src/cli/update.js ***!
  \***************************/
/*! exports provided: updateHelp, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateHelp\", function() { return updateHelp; });\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/storage/disk */ \"./src/core/storage/disk.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/storage/textEncoding */ \"./src/core/storage/textEncoding.js\");\n/* harmony import */ var _update_v0_9_0__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./update/v0_9_0 */ \"./src/cli/update/v0_9_0.js\");\n/* harmony import */ var _update_v0_10_0__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./update/v0_10_0 */ \"./src/cli/update/v0_10_0.js\");\nvar _templateObject;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}/**\n  The `update` CLI can be used by instance maintainers to magically update\n  files in their instance after bumping the sourcecred version. This allows us\n  to be more liberal in making breaking changes, as long as we provide updaters\n  in this module to making the transition super easy for instance maintainers.\n\n  To add an updater, create a new function for it in the cli/update folder and\n  then register your updater by appending it to the `updatesRegistry` const \n  defined below.\n */ /**\n  Ascending order registry of updaters of type:\n  [updaterName, updaterFunction]\n  New updaters should be added append-only.\n */const updatesRegistry=[[\"0.9.0\",_update_v0_9_0__WEBPACK_IMPORTED_MODULE_5__[\"v0_9_0\"]],[\"0.10.0\",_update_v0_10_0__WEBPACK_IMPORTED_MODULE_6__[\"v0_10_0\"]]];///\n///\n///\n///\n///\nconst validNames=()=>{return updatesRegistry.map(_ref=>{let[name]=_ref;return name;});};function die(std,message){std.err(\"fatal: \"+message);return 1;}const UPDATER_FILE_FIRST_LINE=\"Auto-generated. Commit changes, do not edit, do not delete.\";const UPDATER_FILE_PATH=[\"data\",\"updater.txt\"];const run=async(std,storage,updaters)=>{for(const[name,f]of updaters){await f();await storage.set(Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...UPDATER_FILE_PATH),Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_4__[\"encode\"])(UPDATER_FILE_FIRST_LINE+\"\\n\"+name));std.out(\"Found and successfully ran updater for \".concat(name));}std.out(\"\\nRemember to commit and push changes to data/updater.txt\");};const updateCommand=async(args,std)=>{const baseDir=process.cwd();const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_1__[\"DiskStorage\"](baseDir);if(args.length<0||args.length>1){return die(std,\"usage: sourcecred update [updaterName]\\nRecommended usage: sourcecred update\");}if(args.length){const updater=updatesRegistry.find(_ref2=>{let[name]=_ref2;return args[0]===name;});if(!updater)return die(std,\"\".concat(args[0],\" is not a valid updater name. Valid names: \").concat(validNames().join(\", \")));run(std,storage,[updater]);return 0;}const updaterFile=await Object(_util_storage__WEBPACK_IMPORTED_MODULE_2__[\"loadFileWithDefault\"])(storage,Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(...UPDATER_FILE_PATH),()=>\"\");const startingName=updaterFile.split(\"\\n\")[1];const selectedUpdates=updatesRegistry.slice(updatesRegistry.findIndex(_ref3=>{let[name]=_ref3;return name===startingName;})+1);if(selectedUpdates.length){run(std,storage,selectedUpdates);}else std.out(startingName?\"No updaters found since \".concat(startingName,\".\"):\"No updaters found.\");return 0;};const updateHelp=async(args,std)=>{std.out(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"      Recommended usage: sourcecred update\\n\\n      usage: sourcecred update [updaterName]\\n      valid names:\\n      \",\"\\n\\n      If [updaterName] omitted, it will try to load the last updater ran from\\n        data/updater.txt and either run all updaters after the last, or\\n        run all updaters if the file is not found.\\n\\n      Generates data structures useful for data analysis and writes them to\\n      disk.\\n      \"],[\"\\\\\\n      Recommended usage: sourcecred update\\n\\n      usage: sourcecred update [updaterName]\\n      valid names:\\n      \",\"\\n\\n      If [updaterName] omitted, it will try to load the last updater ran from\\n        data/updater.txt and either run all updaters after the last, or\\n        run all updaters if the file is not found.\\n\\n      Generates data structures useful for data analysis and writes them to\\n      disk.\\n      \"])),validNames().join(\"\\n\")).trimRight());return 0;};/* harmony default export */ __webpack_exports__[\"default\"] = (updateCommand);\n\n//# sourceURL=webpack:///./src/cli/update.js?");

/***/ }),

/***/ "./src/cli/update/v0_10_0.js":
/*!***********************************!*\
  !*** ./src/cli/update/v0_10_0.js ***!
  \***********************************/
/*! exports provided: oldParser, v0_10_0, transform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"oldParser\", function() { return oldParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v0_10_0\", function() { return v0_10_0; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transform\", function() { return transform; });\n/* harmony import */ var _util_buildObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/buildObject */ \"./src/util/buildObject.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _core_ledger_grain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/ledger/grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _core_ledger_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/ledger/nonnegativeGrain */ \"./src/core/ledger/nonnegativeGrain.js\");\n/* harmony import */ var _core_ledger_policies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/ledger/policies */ \"./src/core/ledger/policies/index.js\");\n/* harmony import */ var _core_identity_name__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/identity/name */ \"./src/core/identity/name.js\");\n/* harmony import */ var _api_bundledGrainIntegrations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../api/bundledGrainIntegrations */ \"./src/api/bundledGrainIntegrations.js\");\n/* harmony import */ var _core_ledger_policies_recent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/ledger/policies/recent */ \"./src/core/ledger/policies/recent.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/storage/disk */ \"./src/core/storage/disk.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/storage/textEncoding */ \"./src/core/storage/textEncoding.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _api_grainConfig__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../api/grainConfig */ \"./src/api/grainConfig.js\");\nconst oldParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({},{allocationPolicies:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"array\"](_core_ledger_policies__WEBPACK_IMPORTED_MODULE_4__[\"allocationConfigParser\"]),maxSimultaneousDistributions:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],immediatePerWeek:_core_ledger_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__[\"numberOrFloatStringParser\"],balancedPerWeek:_core_ledger_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__[\"numberOrFloatStringParser\"],recentPerWeek:_core_ledger_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__[\"numberOrFloatStringParser\"],recentWeeklyDecayRate:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],sinkIdentity:_core_identity_name__WEBPACK_IMPORTED_MODULE_5__[\"parser\"],processDistributions:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"boolean\"],integration:_api_bundledGrainIntegrations__WEBPACK_IMPORTED_MODULE_6__[\"parser\"]});function toDistributionPolicy(x){const allocationPolicies=_util_null__WEBPACK_IMPORTED_MODULE_13__[\"orElse\"](x.allocationPolicies,[]);const POSITIVE_ZERO=Object(_core_ledger_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__[\"fromInteger\"])(0);const immediatePerWeek=_util_null__WEBPACK_IMPORTED_MODULE_13__[\"orElse\"](x.immediatePerWeek,POSITIVE_ZERO);const recentPerWeek=_util_null__WEBPACK_IMPORTED_MODULE_13__[\"orElse\"](x.recentPerWeek,POSITIVE_ZERO);const balancedPerWeek=_util_null__WEBPACK_IMPORTED_MODULE_13__[\"orElse\"](x.balancedPerWeek,POSITIVE_ZERO);const allocationPoliciesDeprecated=[];if(_core_ledger_grain__WEBPACK_IMPORTED_MODULE_2__[\"gt\"](immediatePerWeek,_core_ledger_grain__WEBPACK_IMPORTED_MODULE_2__[\"ZERO\"])){allocationPoliciesDeprecated.push({budget:_core_ledger_grain__WEBPACK_IMPORTED_MODULE_2__[\"toFloatString\"](immediatePerWeek),policyType:\"IMMEDIATE\",numIntervalsLookback:1});}if(_core_ledger_grain__WEBPACK_IMPORTED_MODULE_2__[\"gt\"](recentPerWeek,_core_ledger_grain__WEBPACK_IMPORTED_MODULE_2__[\"ZERO\"])){const{recentWeeklyDecayRate}=x;if(recentWeeklyDecayRate==null){throw new Error(\"no recentWeeklyDecayRate specified for recent policy\");}allocationPoliciesDeprecated.push({budget:_core_ledger_grain__WEBPACK_IMPORTED_MODULE_2__[\"toFloatString\"](recentPerWeek),policyType:\"RECENT\",discount:Object(_core_ledger_policies_recent__WEBPACK_IMPORTED_MODULE_7__[\"toDiscount\"])(recentWeeklyDecayRate)});}if(_core_ledger_grain__WEBPACK_IMPORTED_MODULE_2__[\"gt\"](balancedPerWeek,_core_ledger_grain__WEBPACK_IMPORTED_MODULE_2__[\"ZERO\"])){allocationPoliciesDeprecated.push({budget:_core_ledger_grain__WEBPACK_IMPORTED_MODULE_2__[\"toFloatString\"](balancedPerWeek),policyType:\"BALANCED\",numIntervalsLookback:0});}return allocationPolicies.concat(allocationPoliciesDeprecated);}const v0_10_0=async()=>{const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_9__[\"DiskStorage\"](process.cwd());const path=Object(path__WEBPACK_IMPORTED_MODULE_11__[\"join\"])(\"config\",\"grain.json\");const oldConfig=await Object(_util_storage__WEBPACK_IMPORTED_MODULE_10__[\"loadJsonWithDefault\"])(storage,path,oldParser,()=>null);if(!oldConfig)return;const newConfig=transform(oldConfig);storage.set(path,Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_12__[\"encode\"])(json_stable_stringify__WEBPACK_IMPORTED_MODULE_8___default()(newConfig,{space:2})));};const transform=oldConfig=>{const legacyIntegratedPolicies=toDistributionPolicy(oldConfig);const newConfig=Object(_util_buildObject__WEBPACK_IMPORTED_MODULE_0__[\"buildObject\"])({allocationPolicies:legacyIntegratedPolicies},{sinkIdentity:oldConfig.sinkIdentity,processDistributions:oldConfig.processDistributions,integration:oldConfig.integration,maxSimultaneousDistributions:oldConfig.maxSimultaneousDistributions});//Verification\n_api_grainConfig__WEBPACK_IMPORTED_MODULE_14__[\"parser\"].parseOrThrow(newConfig);_api_grainConfig__WEBPACK_IMPORTED_MODULE_14__[\"rawParser\"].parseOrThrow(newConfig);return newConfig;};\n\n//# sourceURL=webpack:///./src/cli/update/v0_10_0.js?");

/***/ }),

/***/ "./src/cli/update/v0_9_0.js":
/*!**********************************!*\
  !*** ./src/cli/update/v0_9_0.js ***!
  \**********************************/
/*! exports provided: v0_9_0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v0_9_0\", function() { return v0_9_0; });\n/* harmony import */ var _plugins_discord_update__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../plugins/discord/update */ \"./src/plugins/discord/update.js\");\nconst v0_9_0=async()=>{return Object(_plugins_discord_update__WEBPACK_IMPORTED_MODULE_0__[\"v0_9_0\"])();};\n\n//# sourceURL=webpack:///./src/cli/update/v0_9_0.js?");

/***/ }),

/***/ "./src/core/address.js":
/*!*****************************!*\
  !*** ./src/core/address.js ***!
  \*****************************/
/*! exports provided: makeAddressModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeAddressModule\", function() { return makeAddressModule; });\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/map */ \"./src/util/map.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\nfunction makeAddressModule(options){// for readability and interface consistency\nconst{name,nonce}=options;const otherNonces=new Map(options.otherNonces||new Map());const separator=\"\\0\";if(nonce.indexOf(separator)!==-1){throw new Error(\"invalid nonce (contains NUL): \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(nonce)));}const nonceWithSeparator=nonce+separator;const otherNoncesWithSeparators=_util_map__WEBPACK_IMPORTED_MODULE_2__[\"mapKeys\"](otherNonces,otherNonce=>{if(otherNonce===nonce){throw new Error(\"primary nonce listed as otherNonce: \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(nonce)));}if(otherNonce.indexOf(separator)!==-1){throw new Error(\"invalid otherNonce (contains NUL): \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(otherNonce)));}return otherNonce+separator;});function assertValid(address,what){// istanbul ignore if\nif(true){// Catching invalid addresses in test code should be sufficient\nreturn;}const prefix=what==null?\"\":\"\".concat(what,\": \");if(address==null){throw new Error(prefix+\"expected \".concat(name,\", got: \").concat(String(address)));}if(!address.endsWith(separator)){throw new Error(prefix+\"expected \".concat(name,\", got: \").concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(address)));}if(!address.startsWith(nonceWithSeparator)){for(const[otherNonceWithSeparator,otherName]of otherNoncesWithSeparators){if(address.startsWith(otherNonceWithSeparator)){throw new Error(prefix+\"expected \".concat(name,\", got \").concat(otherName,\": \").concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(address)));}}throw new Error(prefix+\"expected \".concat(name,\", got: \").concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(address)));}}function partsString(parts){// This is needed to properly print arrays containing `undefined`.\nreturn\"[\"+parts.map(p=>String(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(p))).join(\",\")+\"]\";}function assertValidParts(parts,what){// istanbul ignore if\nif(true){// Catching invalid parts in test code should be sufficient\nreturn;}const prefix=what==null?\"\":\"\".concat(what,\": \");if(parts==null){throw new Error(prefix+\"expected array of parts, got: \".concat(String(parts)));}parts.forEach(s=>{if(s==null){throw new Error(prefix+\"expected array of parts, got \".concat(String(s),\" in: \").concat(partsString(parts)));}if(s.indexOf(separator)!==-1){const where=\"\".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(s),\" in \").concat(partsString(parts));throw new Error(prefix+\"part contains NUL character: \".concat(where));}});}function nullDelimited(components){return[...components,\"\"].join(separator);}function fromParts(parts){assertValidParts(parts);return nonce+separator+nullDelimited(parts);}const empty=fromParts([]);function toParts(address){assertValid(address);const parts=address.split(separator);return parts.slice(1,parts.length-1);}function toString(address){const parts=toParts(address);return\"\".concat(name).concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(parts));}function append(address){assertValid(address);for(var _len=arguments.length,parts=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){parts[_key-1]=arguments[_key];}assertValidParts(parts);return address+nullDelimited(parts);}function hasPrefix(address,prefix){assertValid(address,\"address\");assertValid(prefix,\"prefix\");return address.startsWith(prefix);}function fromRaw(address){if(!address.endsWith(separator)){throw new Error(\"address does not end with separator: \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(address)));}if(!address.startsWith(nonceWithSeparator)){for(const[otherNonceWithSeparator,otherName]of otherNoncesWithSeparators){if(address.startsWith(otherNonceWithSeparator)){throw new Error(\"expected \".concat(name,\", got \").concat(otherName,\": \").concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(address)));}}throw new Error(\"expected \".concat(name,\", got: \").concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(address)));}return address;}const parser=_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_3__[\"string\"],fromRaw);const result={assertValid,assertValidParts,empty,fromParts,toParts,toString,append,hasPrefix,fromRaw,parser};return deep_freeze__WEBPACK_IMPORTED_MODULE_1___default()(result);}\n\n//# sourceURL=webpack:///./src/core/address.js?");

/***/ }),

/***/ "./src/core/algorithm/distribution.js":
/*!********************************************!*\
  !*** ./src/core/algorithm/distribution.js ***!
  \********************************************/
/*! exports provided: uniformDistribution, computeDelta */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uniformDistribution\", function() { return uniformDistribution; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeDelta\", function() { return computeDelta; });\n/**\n * A distribution over the integers `0` through `n - 1`, where `n` is\n * the length of the array. The value at index `i` is the probability of\n * `i` in the distribution. The values should sum to 1.\n */function uniformDistribution(n){if(isNaN(n)||!isFinite(n)||n!==Math.floor(n)||n<=0){throw new Error(\"expected positive integer, but got: \"+n);}return new Float64Array(n).fill(1/n);}/**\n * Compute the maximum difference (in absolute value) between components in two\n * distributions.\n *\n * Equivalent to $\\norm{pi0 - pi1}_\\infty$.\n */function computeDelta(pi0,pi1){if(pi0.length===0||pi0.length!==pi1.length){throw new Error(\"invalid input\");}let maxDelta=-Infinity;// Here, we assume that `pi0.nodeOrder` and `pi1.nodeOrder` are the\n// same (i.e., there has been no permutation).\npi0.forEach((x,i)=>{const delta=Math.abs(x-pi1[i]);maxDelta=Math.max(delta,maxDelta);});return maxDelta;}\n\n//# sourceURL=webpack:///./src/core/algorithm/distribution.js?");

/***/ }),

/***/ "./src/core/algorithm/graphToMarkovChain.js":
/*!**************************************************!*\
  !*** ./src/core/algorithm/graphToMarkovChain.js ***!
  \**************************************************/
/*! exports provided: adjacencySource, createConnections, createOrderedSparseMarkovChain, permute, normalizeNeighbors, normalize, distributionToNodeDistribution */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjacencySource\", function() { return adjacencySource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createConnections\", function() { return createConnections; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createOrderedSparseMarkovChain\", function() { return createOrderedSparseMarkovChain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"permute\", function() { return permute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeNeighbors\", function() { return normalizeNeighbors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distributionToNodeDistribution\", function() { return distributionToNodeDistribution; });\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/map */ \"./src/util/map.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\nfunction adjacencySource(target,adjacency){switch(adjacency.type){case\"SYNTHETIC_LOOP\":return target;case\"IN_EDGE\":return adjacency.edge.src;case\"OUT_EDGE\":return adjacency.edge.dst;default:throw new Error(adjacency.type);}}function createConnections(graph,edgeWeight,syntheticLoopWeight){const result=new Map();const totalOutWeight=new Map();for(const node of graph.nodes()){result.set(node.address,[]);totalOutWeight.set(node.address,0);}function processConnection(target,connection){const connections=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](result.get(target));connections.push(connection);const source=adjacencySource(target,connection.adjacency);const priorOutWeight=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](totalOutWeight.get(source));totalOutWeight.set(source,priorOutWeight+connection.weight);}// Add self-loops.\nfor(const node of graph.nodes()){processConnection(node.address,{adjacency:{type:\"SYNTHETIC_LOOP\"},weight:syntheticLoopWeight});}// Process edges.\nfor(const edge of graph.edges({showDangling:false})){const{forwards,backwards}=edgeWeight(edge);const{src,dst}=edge;processConnection(dst,{adjacency:{type:\"IN_EDGE\",edge},weight:forwards});processConnection(src,{adjacency:{type:\"OUT_EDGE\",edge},weight:backwards});}// Normalize in-weights.\nfor(const[target,connections]of result.entries()){for(const connection of connections){const source=adjacencySource(target,connection.adjacency);const normalization=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](totalOutWeight.get(source));const newWeight=connection.weight/normalization;// (any-cast because property is not writable)\nconnection.weight=newWeight;}}return result;}function createNodeAddressMarkovChain(ntc){return _util_map__WEBPACK_IMPORTED_MODULE_0__[\"mapValues\"](ntc,(target,connections)=>{const inNeighbors=new Map();for(const connection of connections){const source=adjacencySource(target,connection.adjacency);inNeighbors.set(source,connection.weight+_util_null__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"](inNeighbors.get(source),0));}return inNeighbors;});}function nodeAddressMarkovChainToOrderedSparseMarkovChain(chain){const nodeOrder=Array.from(chain.keys());const addressToIndex=new Map();nodeOrder.forEach((node,index)=>{addressToIndex.set(node,index);});return{nodeOrder,chain:nodeOrder.map(dst=>{const theseNeighbors=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](chain.get(dst));const result={neighbor:new Uint32Array(theseNeighbors.size),weight:new Float64Array(theseNeighbors.size)};let i=0;for(const[src,weight]of theseNeighbors.entries()){const srcIndex=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](addressToIndex.get(src));result.neighbor[i]=srcIndex;result.weight[i]=weight;i++;}return result;})};}function createOrderedSparseMarkovChain(connections){const chain=createNodeAddressMarkovChain(connections);return nodeAddressMarkovChainToOrderedSparseMarkovChain(chain);}/**\n * Return an equivalent form of the given chain whose `nodeOrder` is the\n * provided array, which must be a permutation of the node order of the\n * original chain.\n */function permute(old,newOrder){const newIndices={};const oldIndices={};newOrder.forEach((node,i)=>{newIndices[node]=i;});old.nodeOrder.forEach((node,i)=>{oldIndices[node]=i;});const newChain=[];for(const node of newOrder){const{neighbor:oldNeighbors,weight}=old.chain[oldIndices[node]];const newNeighbors=oldNeighbors.map(oldIndex=>newIndices[old.nodeOrder[oldIndex]]);newChain.push({neighbor:newNeighbors,weight});}return{nodeOrder:newOrder,chain:newChain};}/**\n * Return an equivalent form of the given chain such that for for each\n * node, the entries in `chain[node].neighbors` are sorted.\n */function normalizeNeighbors(old){return{nodeOrder:old.nodeOrder,chain:old.chain.map(_ref=>{let{neighbor,weight}=_ref;if(neighbor.length!==weight.length){throw new Error(\"\".concat(neighbor.length,\" !== \").concat(weight.length));}const entries=Array(neighbor.length).fill(null).map((_,i)=>({neighbor:neighbor[i],weight:weight[i]}));entries.sort((a,b)=>a.neighbor-b.neighbor);return{neighbor:new Uint32Array(entries.map(x=>x.neighbor)),weight:new Float64Array(entries.map(x=>x.weight))};})};}function normalize(old){return normalizeNeighbors(permute(old,old.nodeOrder.slice().sort()));}function distributionToNodeDistribution(nodeOrder,pi){const result=new Map();nodeOrder.forEach((node,i)=>{const probability=pi[i];result.set(node,probability);});return result;}\n\n//# sourceURL=webpack:///./src/core/algorithm/graphToMarkovChain.js?");

/***/ }),

/***/ "./src/core/algorithm/markovChain.js":
/*!*******************************************!*\
  !*** ./src/core/algorithm/markovChain.js ***!
  \*******************************************/
/*! exports provided: sparseMarkovChainFromTransitionMatrix, sparseMarkovChainAction, findStationaryDistribution */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sparseMarkovChainFromTransitionMatrix\", function() { return sparseMarkovChainFromTransitionMatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sparseMarkovChainAction\", function() { return sparseMarkovChainAction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findStationaryDistribution\", function() { return findStationaryDistribution; });\n/* harmony import */ var _distribution__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distribution */ \"./src/core/algorithm/distribution.js\");\n/**\n * The data inputs to running PageRank.\n *\n * We keep these separate from the PagerankOptions below,\n * because we expect that within a given context, every call to\n * findStationaryDistribution (or other Pagerank functions) will\n * have different PagerankParams, but often have the same PagerankOptions.\n */function sparseMarkovChainFromTransitionMatrix(matrix){const n=matrix.length;matrix.forEach((row,i)=>{if(row.length!==n){throw new Error(\"expected rows to have length \".concat(n,\", but row \").concat(i,\" has \").concat(row.length));}});matrix.forEach((row,i)=>{row.forEach((value,j)=>{if(isNaN(value)||!isFinite(value)||value<0){throw new Error(\"expected positive real entries, but [\".concat(i,\"][\").concat(j,\"] is \").concat(value));}});});matrix.forEach((row,i)=>{const rowsum=row.reduce((a,b)=>a+b,0);if(Math.abs(rowsum-1)>1e-6){throw new Error(\"expected rows to sum to 1, but row \".concat(i,\" sums to \").concat(rowsum));}});return matrix.map((_,j)=>{const column=matrix.map((row,i)=>[i,row[j]]).filter(_ref=>{let[_,p]=_ref;return p>0;});return{neighbor:new Uint32Array(column.map(_ref2=>{let[i,_]=_ref2;return i;})),weight:new Float64Array(column.map(_ref3=>{let[_,p]=_ref3;return p;}))};});}function sparseMarkovChainActionInto(chain,seed,alpha,input,output){chain.forEach((_ref4,dst)=>{let{neighbor,weight}=_ref4;const inDegree=neighbor.length;// (also `weight.length`)\nlet probability=alpha*seed[dst];for(let i=0;i<inDegree;i++){const src=neighbor[i];probability+=(1-alpha)*input[src]*weight[i];}output[dst]=probability;});}function sparseMarkovChainAction(chain,seed,alpha,pi){const result=new Float64Array(pi.length);sparseMarkovChainActionInto(chain,seed,alpha,pi,result);return result;}function*findStationaryDistributionGenerator(params,options){const{chain,pi0,seed,alpha}=params;let pi=new Float64Array(pi0);let scratch=new Float64Array(pi.length);let nIterations=0;while(true){if(nIterations>=options.maxIterations){if(options.verbose){console.log(\"[\".concat(nIterations,\"] FAILED to converge\"));}// We need to do one more step so that we can compute the empirical convergence\n// delta for the returned distribution.\nsparseMarkovChainActionInto(chain,seed,alpha,pi,scratch);const convergenceDelta=Object(_distribution__WEBPACK_IMPORTED_MODULE_0__[\"computeDelta\"])(pi,scratch);return{pi,convergenceDelta};}nIterations++;sparseMarkovChainActionInto(chain,seed,alpha,pi,scratch);// We compute the convergenceDelta between 'scratch' (the newest\n// distribution) and 'pi' (the distribution from the previous step). If the\n// delta is below threshold, then the distribution from the last step was\n// already converged and we return it (not scratch). Otherwise, we assign\n// `scratch` to `distribution` and try again.\nconst convergenceDelta=Object(_distribution__WEBPACK_IMPORTED_MODULE_0__[\"computeDelta\"])(pi,scratch);if(options.verbose){console.log(\"[\".concat(nIterations,\"] delta = \").concat(convergenceDelta));}if(convergenceDelta<options.convergenceThreshold){if(options.verbose){console.log(\"[\".concat(nIterations,\"] CONVERGED\"));}return{pi,convergenceDelta};}[scratch,pi]=[pi,scratch];yield;}// ESLint knows that this next line is unreachable, but Flow doesn't. :-)\n// eslint-disable-next-line no-unreachable\nthrow new Error(\"Unreachable.\");}function findStationaryDistribution(params,options){const gen=findStationaryDistributionGenerator(params,{verbose:options.verbose,convergenceThreshold:options.convergenceThreshold,maxIterations:options.maxIterations});return new Promise((resolve,_unused_reject)=>{const{yieldAfterMs}=options;const tick=()=>{const start=Date.now();do{const result=gen.next();if(result.done){if(result.value==null){// Should never happen.\nthrow new Error(String(result.value));}resolve(result.value);return;}}while(Date.now()-start<yieldAfterMs);setTimeout(tick,0);};tick();});}\n\n//# sourceURL=webpack:///./src/core/algorithm/markovChain.js?");

/***/ }),

/***/ "./src/core/algorithm/weightEvaluator.js":
/*!***********************************************!*\
  !*** ./src/core/algorithm/weightEvaluator.js ***!
  \***********************************************/
/*! exports provided: nodeWeightEvaluator, edgeWeightEvaluator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodeWeightEvaluator\", function() { return nodeWeightEvaluator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeWeightEvaluator\", function() { return edgeWeightEvaluator; });\n/* harmony import */ var _trie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../trie */ \"./src/core/trie.js\");\n/**\n * Given the weights and types, produce a NodeWeightEvaluator, which assigns a\n * numerical weight to any node.\n *\n * The weights are interpreted as prefixes, i.e. a given address may match\n * multiple weights. When this is the case, the matching weights are multiplied\n * together. When no weights match, a default weight of 1 is returned.\n *\n * We currently take the NodeTypes and use them to 'fill in' default type\n * weights if no weight for the type's prefix is explicitly set. This is a\n * legacy affordance; shortly we will remove the NodeTypes and require that the\n * plugins provide the type weights when the Weights object is constructed.\n */function nodeWeightEvaluator(weights){const nodeTrie=new _trie__WEBPACK_IMPORTED_MODULE_0__[\"NodeTrie\"]();for(const[prefix,weight]of weights.nodeWeights.entries()){nodeTrie.add(prefix,weight);}return function nodeWeight(a){const matchingWeights=nodeTrie.get(a);return matchingWeights.reduce((a,b)=>a*b,1);};}/**\n * Given the weights and the types, produce an EdgeWeightEvaluator,\n * which will assign an EdgeWeight to any edge.\n *\n * The edge weights are interpreted as prefix matchers, so a single edge may\n * match zero or more EdgeWeights. The weight for the edge will be the product\n * of all matching EdgeWeights (with 1 as the default forwards and backwards\n * weight.)\n *\n * The types are used to 'fill in' extra type weights. This is a temporary\n * state of affairs; we will change plugins to include the type weights\n * directly in the weights object, so that producing weight evaluators will no\n * longer depend on having plugin declarations on hand.\n */function edgeWeightEvaluator(weights){const edgeTrie=new _trie__WEBPACK_IMPORTED_MODULE_0__[\"EdgeTrie\"]();for(const[prefix,weight]of weights.edgeWeights.entries()){edgeTrie.add(prefix,weight);}return function evaluator(address){const weights=edgeTrie.get(address);return weights.reduce((a,b)=>({forwards:a.forwards*b.forwards,backwards:a.backwards*b.backwards}),{forwards:1,backwards:1});};}\n\n//# sourceURL=webpack:///./src/core/algorithm/weightEvaluator.js?");

/***/ }),

/***/ "./src/core/bonusMinting.js":
/*!**********************************!*\
  !*** ./src/core/bonusMinting.js ***!
  \**********************************/
/*! exports provided: computeBonusMinting, _bonusIntervals, createBonusGraph, BONUS_NODE_PREFIX, bonusNodeAddress, bonusNode, BONUS_EDGE_PREFIX, BONUS_EDGE_WEIGHT, bonusEdgeAddress, bonusEdge, _computeMintIntervals, processBonusPolicy, _alignPeriodsToIntervals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeBonusMinting\", function() { return computeBonusMinting; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_bonusIntervals\", function() { return _bonusIntervals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createBonusGraph\", function() { return createBonusGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BONUS_NODE_PREFIX\", function() { return BONUS_NODE_PREFIX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bonusNodeAddress\", function() { return bonusNodeAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bonusNode\", function() { return bonusNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BONUS_EDGE_PREFIX\", function() { return BONUS_EDGE_PREFIX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BONUS_EDGE_WEIGHT\", function() { return BONUS_EDGE_WEIGHT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bonusEdgeAddress\", function() { return bonusEdgeAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bonusEdge\", function() { return bonusEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_computeMintIntervals\", function() { return _computeMintIntervals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processBonusPolicy\", function() { return processBonusPolicy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_alignPeriodsToIntervals\", function() { return _alignPeriodsToIntervals; });\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph */ \"./src/core/graph.js\");\n/* harmony import */ var _weights__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./weights */ \"./src/core/weights.js\");\n/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval */ \"./src/core/interval.js\");\n/* harmony import */ var _algorithm_weightEvaluator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./algorithm/weightEvaluator */ \"./src/core/algorithm/weightEvaluator.js\");\n/**\n * This module adds a system for specifying \"bonus minting\" policies. The core\n * idea for bonus minting is that extra Cred is conjured out of thin air (as a\n * \"bonus\") and distributed to a chosen recipient. This system is intended to\n * be used for minting Cred for project-level dependencies. For example, we\n * would like users of SourceCred to mint some extra Cred and flow it to the\n * SourceCred project.\n *\n * In CredRank, we handle this by creating extra nodes in the graph which mint\n * the bonus Cred, and it flows directly from those nodes to the intended\n * recipients.\n *\n * The total amount of Cred that may be minted is unbounded; for example, if\n * the dependencies have a total weight of 0.2, then the total Cred will be\n * 120% of the base Cred, but if the dependencies had a total weight of 1, then\n * the total Cred would be double the base Cred. This was a deliberate design\n * decision so that dependency minting would feel \"non-rival\", i.e. there is\n * not a fixed budget of dependency cred that must be split between the\n * dependencies. In some cases, it may be reasonable for the total Cred flowing\n * to a project's dependencies to be larger than the total Cred flowing\n * directly to the project's contributors; consider that the total amount of\n * time/effort invested in building all the dependencies may be orders of\n * magnitude larger than investment in the project itself.\n */function computeBonusMinting(wg,policies){const mintIntervals=_computeMintIntervals(wg);return policies.map(policy=>{const recipient=wg.graph.node(policy.address);if(recipient==null){throw new Error(\"bonus recipient not in graph: \".concat(_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toString(policy.address)));}return{recipient,bonusIntervals:_bonusIntervals(mintIntervals,policy.periods)};});}function _bonusIntervals(mintIntervals,periods){let nextIndex=0;let weight=0;return mintIntervals.map(_ref=>{let{interval,totalMint}=_ref;while(nextIndex<periods.length&&periods[nextIndex].startTimeMs<=interval.startTimeMs){weight=periods[nextIndex].weight;nextIndex++;}return{interval,amount:totalMint*weight};});}function createBonusGraph(bonusMints){const graph=new _graph__WEBPACK_IMPORTED_MODULE_0__[\"Graph\"]();const weights=Object(_weights__WEBPACK_IMPORTED_MODULE_1__[\"empty\"])();for(const{recipient,bonusIntervals}of bonusMints){graph.addNode(recipient);for(const{interval,amount}of bonusIntervals){if(amount===0){continue;}graph.addNode(bonusNode(recipient,interval));graph.addEdge(bonusEdge(recipient,interval));weights.nodeWeights.set(bonusNodeAddress(recipient,interval),amount);}}weights.edgeWeights.set(BONUS_EDGE_PREFIX,BONUS_EDGE_WEIGHT);return{graph,weights};}const BONUS_NODE_PREFIX=_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].fromParts([\"sourcecred\",\"core\",\"BONUS\"]);function bonusNodeAddress(recipient,interval){return _graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(BONUS_NODE_PREFIX,String(interval.startTimeMs),..._graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toParts(recipient.address));}function bonusNode(recipient,interval){return{address:bonusNodeAddress(recipient,interval),timestampMs:interval.startTimeMs,description:\"bonus minting for \".concat(recipient.description,\" starting \").concat(interval.startTimeMs)};}const BONUS_EDGE_PREFIX=_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].fromParts([\"sourcecred\",\"core\",\"BONUS\"]);const BONUS_EDGE_WEIGHT=Object.freeze({forwards:1,// setting the backward weight to non-zero has a material effect on the\n// resultant Cred scores, since it means that the bonus minting node acts as\n// a mini Cred accumulator in a tight loop with the recipient. Setting this\n// to 0 results in somewhat lower Cred for the mint recipient, and I like\n// biasing conservatively here.\nbackwards:0});function bonusEdgeAddress(recipient,interval){return _graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(BONUS_EDGE_PREFIX,String(interval.startTimeMs),..._graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toParts(recipient.address));}function bonusEdge(recipient,interval){return{src:bonusNodeAddress(recipient,interval),dst:recipient.address,address:bonusEdgeAddress(recipient,interval),timestampMs:interval.startTimeMs};}// How much total Cred minting occured in a particular interval, for a particular graph?\nfunction _computeMintIntervals(wg){const nwe=Object(_algorithm_weightEvaluator__WEBPACK_IMPORTED_MODULE_3__[\"nodeWeightEvaluator\"])(wg.weights);const partition=Object(_interval__WEBPACK_IMPORTED_MODULE_2__[\"partitionGraph\"])(wg.graph);return partition.map(_ref2=>{let{interval,nodes}=_ref2;let totalMint=0;for(const{address}of nodes){totalMint+=nwe(address);}return{interval,totalMint};});}// ========================= DEPRECATED =========================\n// Everything below this line has TimelineCred specific logic, and will be\n// removed when we switch to CredRank.\n/**\n * The ProcessedBonusPolicy is a BonusPolicy which has\n * been transformed so that it matches the abstractions available when\n * we're doing raw cred computation: instead of an address, we track an index\n * into the canonical node order, and rather than arbitrary client-provided\n * periods, we compute the weight for each Interval.\n *\n * TODO(#1686, @decentralion): Remove this once we switch to CredRank.\n */function processBonusPolicy(policy,nodeOrder,intervals){const{address,periods}=policy;const nodeIndex=nodeOrder.indexOf(address);if(nodeIndex===-1){throw new Error(\"address not in nodeOrder: \".concat(_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toString(address)));}const intervalStarts=intervals.map(i=>i.startTimeMs);const intervalWeights=_alignPeriodsToIntervals(periods,intervalStarts);return{nodeIndex,intervalWeights};}function _alignPeriodsToIntervals(periods,intervalStarts){if(periods.length===0){return intervalStarts.map(()=>0);}// Validate the periods to make sure they are in order and the weights\n// are finite and non-negative\nlet currentStartTimeMs=periods[0].startTimeMs;for(const{startTimeMs,weight}of periods){if(currentStartTimeMs>startTimeMs){throw new Error(\"mint periods out of order: \".concat(currentStartTimeMs,\" > \").concat(startTimeMs));}currentStartTimeMs=startTimeMs;if(weight<0||!Number.isFinite(weight)){throw new Error(\"invalid mint weight: \".concat(weight));}}let currentPeriodIndex=-1;let currentWeight=0;// We always return the weight of the latest period whose startTimeMs was\n// less than or equal to the interval's start.\nreturn intervalStarts.map(s=>{while(currentPeriodIndex<periods.length-1&&periods[currentPeriodIndex+1].startTimeMs<=s){currentPeriodIndex++;currentWeight=periods[currentPeriodIndex].weight;}return currentWeight;});}\n\n//# sourceURL=webpack:///./src/core/bonusMinting.js?");

/***/ }),

/***/ "./src/core/credGrainView.js":
/*!***********************************!*\
  !*** ./src/core/credGrainView.js ***!
  \***********************************/
/*! exports provided: credGrainViewParser, CredGrainView, TimeScopedCredGrainView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"credGrainViewParser\", function() { return credGrainViewParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CredGrainView\", function() { return CredGrainView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeScopedCredGrainView\", function() { return TimeScopedCredGrainView; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _credrank_credGraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./credrank/credGraph */ \"./src/core/credrank/credGraph.js\");\n/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./identity */ \"./src/core/identity/index.js\");\n/* harmony import */ var _ledger_grain__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ledger/grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _ledger_ledger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ledger/ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var lodash_findlastindex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash.findlastindex */ \"lodash.findlastindex\");\n/* harmony import */ var lodash_findlastindex__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_findlastindex__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interval */ \"./src/core/interval.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * This module exposes a class that accesses participant data, aggregating\n * between a CredGraph and a Ledger.\n *\n * It is useful for cases where you want to view a participant's Cred and Grain\n * data simultaneously, for example for creating summary dashboards.\n *//**\n * Cred and Grain data for a given participant.\n *\n * Implicitly has an associated time scope, which will\n * be the time scope of the CredGrainView or TimeScopedCredGrainView that\n * generated this.\n *\n * The indices of credPerInterval/grainEarnedPerInterval correspond to the\n * same indices in the IntervalSequence of the CredGrainView or\n * TimeScopedCredGrainView that generated this.\n */const credGrainViewParser=_util_combo__WEBPACK_IMPORTED_MODULE_8__[\"object\"]({participants:_util_combo__WEBPACK_IMPORTED_MODULE_8__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_8__[\"object\"]({active:_util_combo__WEBPACK_IMPORTED_MODULE_8__[\"boolean\"],identity:_identity__WEBPACK_IMPORTED_MODULE_3__[\"identityParser\"],cred:_util_combo__WEBPACK_IMPORTED_MODULE_8__[\"number\"],credPerInterval:_util_combo__WEBPACK_IMPORTED_MODULE_8__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_8__[\"number\"]),grainEarned:_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"parser\"],grainEarnedPerInterval:_util_combo__WEBPACK_IMPORTED_MODULE_8__[\"array\"](_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"parser\"])})),intervals:_interval__WEBPACK_IMPORTED_MODULE_7__[\"intervalSequenceParser\"]}).fmap(json=>CredGrainView.fromJSON(json));/**\n * Aggregates data across a CredGraph and Ledger.\n *\n * By default, it includes data across all time present in the instance.\n * Callers can call `withTimeScope` to get a `TimeScopedCredGrainView` which\n * returns data that only includes a continuous subset of cred and grain data\n * across time.\n */class CredGrainView{constructor(participants,intervals){_defineProperty(this,\"_participants\",void 0);_defineProperty(this,\"_intervals\",void 0);_defineProperty(this,\"_credTotals\",void 0);_defineProperty(this,\"_grainTotals\",void 0);this._participants=participants;this._intervals=intervals;this._credTotals=[];this._grainTotals=[];participants.forEach(participant=>{for(let i=0;i<this._intervals.length;i++){this._credTotals[i]=participant.credPerInterval[i]+(this._credTotals[i]||0);this._grainTotals[i]=Object(_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"add\"])(participant.grainEarnedPerInterval[i],this._grainTotals[i]||_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"ZERO\"]);}});}static _calculateGrainEarnedPerInterval(account,intervals){let allocationIndex=0;return intervals.map(interval=>{let grain=_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"ZERO\"];while(account.allocationHistory.length-1>=allocationIndex&&interval.startTimeMs<account.allocationHistory[allocationIndex].credTimestampMs&&account.allocationHistory[allocationIndex].credTimestampMs<=interval.endTimeMs){grain=_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"add\"](grain,account.allocationHistory[allocationIndex].grainReceipt.amount);allocationIndex++;}return grain;});}validateForGrainAllocation(){if(this.activeParticipants().length===0){throw new Error(\"must have at least one identity to allocate grain to\");}this.activeParticipants().forEach(p=>{p.credPerInterval.forEach(c=>{if(typeof c!==\"number\"){throw new Error(\"Non numeric cred value found\");}if(c<0){throw new Error(\"negative cred in interval data\");}});if(typeof p.cred!==\"number\"){throw new Error(\"Non numeric cred value found\");}if(p.credPerInterval.length!==this.intervals().length){throw new Error(\"participant cred per interval length mismatch\");}if(p.grainEarnedPerInterval.length!==this.intervals().length){throw new Error(\"participant grain per interval length mismatch\");}if(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(p.credPerInterval)!==p.cred){throw new Error(\"participant cred per interval mismatched with participant cred total\");}if(!_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"eq\"](_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"sum\"](p.grainEarnedPerInterval),p.grainEarned)){throw new Error(\"participant grain per interval mismatched with participant grain total:\");}p.grainEarnedPerInterval.forEach(g=>{if(g<_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"ZERO\"]){throw new Error(\"negative grain paid in interval data\");}});});if(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(this.totalCredPerInterval())<1)throw new Error(\"cred is zero. Make sure your plugins are configured correctly and remember to run 'yarn go' to calculate the cred scores.\");}withTimeScope(startTimeMs,endTimeMs){return new TimeScopedCredGrainView(this,startTimeMs,endTimeMs);}withTimeScopeFromLookback(effectiveTimestamp,numIntervalsLookback){const intervalsBeforeEffective=this._intervals.filter(interval=>interval.endTimeMs<=effectiveTimestamp);if(!numIntervalsLookback)return new TimeScopedCredGrainView(this,-Infinity,effectiveTimestamp);if(!intervalsBeforeEffective||intervalsBeforeEffective.length<=numIntervalsLookback)return new TimeScopedCredGrainView(this,-Infinity,effectiveTimestamp);return new TimeScopedCredGrainView(this,intervalsBeforeEffective[intervalsBeforeEffective.length-numIntervalsLookback].startTimeMs,effectiveTimestamp);}intervals(){return this._intervals;}participants(){return this._participants;}activeParticipants(){return this._participants.filter(participant=>participant.active);}// This is imprecise, due to floating point rounding.\ntotalCredPerInterval(){return this._credTotals;}totalGrainPerInterval(){return this._grainTotals;}toJSON(){return{participants:this._participants,intervals:this._intervals};}static fromJSON(json){return new CredGrainView(json.participants,json.intervals);}static fromCredGraphAndLedger(credGraph,ledger){const intervals=deep_freeze__WEBPACK_IMPORTED_MODULE_1___default()(credGraph.intervals());const graphParticipants=new Map();for(const participant of credGraph.participants()){graphParticipants.set(participant.id,participant);}const participants=deep_freeze__WEBPACK_IMPORTED_MODULE_1___default()(ledger.accounts().map(account=>{const graphParticipant=graphParticipants.get(account.identity.id);if(!graphParticipant)throw new Error(\"The graph is missing account [\".concat(account.identity.name,\": \").concat(account.identity.id,\"] that exists in the ledger. Try recalculating the scores.\"));const grainEarnedPerInterval=this._calculateGrainEarnedPerInterval(account,intervals);return{active:account.active,identity:account.identity,cred:graphParticipant.cred,credPerInterval:graphParticipant.credPerInterval,grainEarned:account.paid,grainEarnedPerInterval};}));return new CredGrainView(participants,intervals);}}/**\n * This class's contructor stores a continuous subset of the originalIntervals\n * and participant cred/grain data where intervals are only included if their\n * start and end times are both within the provided startTimeMs and endTimeMs,\n * inclusively.\n */class TimeScopedCredGrainView{constructor(credGrainView,startTimeMs,endTimeMs){_defineProperty(this,\"_participants\",void 0);_defineProperty(this,\"_intervals\",void 0);_defineProperty(this,\"_credTotals\",void 0);_defineProperty(this,\"_grainTotals\",void 0);const originalIntervals=credGrainView.intervals();let inclusiveStartIndex=originalIntervals.findIndex(interval=>startTimeMs<=interval.startTimeMs);if(inclusiveStartIndex===-1)inclusiveStartIndex=originalIntervals.length;const exclusiveEndIndex=lodash_findlastindex__WEBPACK_IMPORTED_MODULE_6___default()(originalIntervals,interval=>interval.endTimeMs<=endTimeMs)+1;this._intervals=deep_freeze__WEBPACK_IMPORTED_MODULE_1___default()(Object(_interval__WEBPACK_IMPORTED_MODULE_7__[\"intervalSequence\"])(originalIntervals.slice(inclusiveStartIndex,exclusiveEndIndex)));this._participants=deep_freeze__WEBPACK_IMPORTED_MODULE_1___default()(credGrainView.participants().map(participant=>{const credPerInterval=participant.credPerInterval.slice(inclusiveStartIndex,exclusiveEndIndex);const grainEarnedPerInterval=participant.grainEarnedPerInterval.slice(inclusiveStartIndex,exclusiveEndIndex);return{active:participant.active,identity:participant.identity,cred:credPerInterval.reduce((a,b)=>a+b,0),credPerInterval,grainEarned:grainEarnedPerInterval.reduce((a,b)=>_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"add\"](a,b||_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"ZERO\"]),_ledger_grain__WEBPACK_IMPORTED_MODULE_4__[\"ZERO\"]),grainEarnedPerInterval};}));this._credTotals=credGrainView.totalCredPerInterval().slice(inclusiveStartIndex,exclusiveEndIndex);this._grainTotals=credGrainView.totalGrainPerInterval().slice(inclusiveStartIndex,exclusiveEndIndex);}intervals(){return this._intervals;}participants(){return this._participants;}activeParticipants(){return this._participants.filter(participant=>participant.active);}// This is imprecise, due to floating point rounding.\ntotalCredPerInterval(){return this._credTotals;}totalGrainPerInterval(){return this._grainTotals;}}\n\n//# sourceURL=webpack:///./src/core/credGrainView.js?");

/***/ }),

/***/ "./src/core/credrank/compute.js":
/*!**************************************!*\
  !*** ./src/core/credrank/compute.js ***!
  \**************************************/
/*! exports provided: DEFAULT_MAX_ITERATIONS, DEFAULT_CONVERGENCE_THRESHOLD, DEFAULT_YIELD_AFTER_MS, DEFAULT_VERBOSE, credrank, markovProcessGraphPagerank */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_MAX_ITERATIONS\", function() { return DEFAULT_MAX_ITERATIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_CONVERGENCE_THRESHOLD\", function() { return DEFAULT_CONVERGENCE_THRESHOLD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_YIELD_AFTER_MS\", function() { return DEFAULT_YIELD_AFTER_MS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_VERBOSE\", function() { return DEFAULT_VERBOSE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"credrank\", function() { return credrank; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"markovProcessGraphPagerank\", function() { return markovProcessGraphPagerank; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _algorithm_markovChain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../algorithm/markovChain */ \"./src/core/algorithm/markovChain.js\");\n/* harmony import */ var _algorithm_graphToMarkovChain__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../algorithm/graphToMarkovChain */ \"./src/core/algorithm/graphToMarkovChain.js\");\n/* harmony import */ var _algorithm_distribution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../algorithm/distribution */ \"./src/core/algorithm/distribution.js\");\n/* harmony import */ var _nodeGadgets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nodeGadgets */ \"./src/core/credrank/nodeGadgets.js\");\n/* harmony import */ var _markovProcessGraph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./markovProcessGraph */ \"./src/core/credrank/markovProcessGraph.js\");\n/* harmony import */ var _credGraph__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./credGraph */ \"./src/core/credrank/credGraph.js\");\n/* harmony import */ var _ledger_ledger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../ledger/ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../interval */ \"./src/core/interval.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const DEFAULT_MAX_ITERATIONS=255;const DEFAULT_CONVERGENCE_THRESHOLD=1e-7;const DEFAULT_YIELD_AFTER_MS=30;const DEFAULT_VERBOSE=false;const DEFAULT_ALPHA=0.1;const DEFAULT_BETA=0.4;const DEFAULT_GAMMA_FORWARD=0.1;const DEFAULT_GAMMA_BACKWARD=0.1;/**\n * Compute CredRank results given a WeightedGraph, a Ledger, and optional\n * parameters.\n */function credrank(weightedGraph,ledger){let personalAttributions=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];let markovProcessGraphParameters=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};let pagerankOptions=arguments.length>4?arguments[4]:undefined;const defaultParameters={alpha:DEFAULT_ALPHA,beta:DEFAULT_BETA,gammaForward:DEFAULT_GAMMA_FORWARD,gammaBackward:DEFAULT_GAMMA_BACKWARD};const parameters=_objectSpread(_objectSpread({},defaultParameters),markovProcessGraphParameters);const participants=ledger.accounts().map(_ref=>{let{identity}=_ref;return{description:identity.name,address:identity.address,id:identity.id};});const intervals=Object(_interval__WEBPACK_IMPORTED_MODULE_9__[\"graphIntervals\"])(weightedGraph.graph);const mpg=_markovProcessGraph__WEBPACK_IMPORTED_MODULE_6__[\"MarkovProcessGraph\"].new({weightedGraph,participants,parameters,intervals,personalAttributions});return markovProcessGraphPagerank(mpg,pagerankOptions);}/**\n * Given a MarkovProcessGraph, compute PageRank scores on it.\n */async function markovProcessGraphPagerank(mpg){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const defaultOptions={maxIterations:DEFAULT_MAX_ITERATIONS,convergenceThreshold:DEFAULT_CONVERGENCE_THRESHOLD,yieldAfterMs:DEFAULT_YIELD_AFTER_MS,verbose:DEFAULT_VERBOSE};options=_objectSpread(_objectSpread({},defaultOptions),options);const osmc=mpg.toMarkovChain();const params={chain:osmc.chain,pi0:Object(_algorithm_distribution__WEBPACK_IMPORTED_MODULE_4__[\"uniformDistribution\"])(osmc.nodeOrder.length),seed:Object(_algorithm_distribution__WEBPACK_IMPORTED_MODULE_4__[\"uniformDistribution\"])(osmc.nodeOrder.length),alpha:0};const distributionResult=await Object(_algorithm_markovChain__WEBPACK_IMPORTED_MODULE_2__[\"findStationaryDistribution\"])(params,options);const pi=Object(_algorithm_graphToMarkovChain__WEBPACK_IMPORTED_MODULE_3__[\"distributionToNodeDistribution\"])(osmc.nodeOrder,distributionResult.pi);const matchingScore=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(Array.from(mpg.nodes({prefix:_nodeGadgets__WEBPACK_IMPORTED_MODULE_5__[\"accumulatorGadget\"].prefix})).map(n=>_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](pi.get(n.address))));let totalNodeWeight=0;for(const{mint:weight}of mpg.nodes()){totalNodeWeight+=weight;}const scores=osmc.nodeOrder.map((_,i)=>distributionResult.pi[i]/matchingScore*totalNodeWeight);return new _credGraph__WEBPACK_IMPORTED_MODULE_7__[\"CredGraph\"](mpg,scores);}\n\n//# sourceURL=webpack:///./src/core/credrank/compute.js?");

/***/ }),

/***/ "./src/core/credrank/credGraph.js":
/*!****************************************!*\
  !*** ./src/core/credrank/credGraph.js ***!
  \****************************************/
/*! exports provided: CredGraph, jsonParser, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CredGraph\", function() { return CredGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"jsonParser\", function() { return jsonParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _markovProcessGraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./markovProcessGraph */ \"./src/core/credrank/markovProcessGraph.js\");\n/* harmony import */ var _edgeGadgets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./edgeGadgets */ \"./src/core/credrank/edgeGadgets.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}class CredGraph{// Scores for each node, tracked in the MPG node order\nconstructor(markovProcessGraph,scores){_defineProperty(this,\"_mpg\",void 0);_defineProperty(this,\"_scores\",void 0);this._mpg=markovProcessGraph;this._scores=scores;}_cred(addr){const index=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](this._mpg.nodeIndex(addr));return this._scores[index];}_credFlow(edge){const srcCred/* heh */=this._cred(edge.src);return srcCred*edge.transitionProbability;}node(addr){const node=this._mpg.node(addr);if(node==null)return undefined;return _objectSpread(_objectSpread({},node),{},{cred:this._cred(addr)});}*nodes(){for(const node of this._mpg.nodes()){yield _objectSpread(_objectSpread({},node),{},{cred:this._cred(node.address)});}}*edges(){for(const edge of this._mpg.edges()){yield _objectSpread(_objectSpread({},edge),{},{credFlow:this._credFlow(edge)});}}*participants(){for(const{address,description,id}of this._mpg.participants()){const epochs=this._mpg.epochStarts().map(epochStart=>({owner:id,epochStart}));let totalCred=0;const credPerInterval=epochs.map(e=>{const payoutAddress=_edgeGadgets__WEBPACK_IMPORTED_MODULE_3__[\"payoutGadget\"].toRaw(e);const payoutMarkovEdge=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](this._mpg.edge(payoutAddress));const cred=this._credFlow(payoutMarkovEdge);totalCred+=cred;return cred;});yield{address,description,credPerInterval,cred:totalCred,id};}}intervals(){return this._mpg.intervals();}*inNeighbors(addr){for(const edge of this._mpg.inNeighbors(addr)){yield _objectSpread(_objectSpread({},edge),{},{credFlow:this._credFlow(edge)});}}toJSON(){const mpgJson=this._mpg.toJSON();return{mpg:mpgJson,scores:this._scores};}static fromJSON(j){return new CredGraph(_markovProcessGraph__WEBPACK_IMPORTED_MODULE_2__[\"MarkovProcessGraph\"].fromJSON(j.mpg),j.scores);}}const jsonParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({mpg:_markovProcessGraph__WEBPACK_IMPORTED_MODULE_2__[\"jsonParser\"],scores:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"])});const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](jsonParser,CredGraph.fromJSON);\n\n//# sourceURL=webpack:///./src/core/credrank/credGraph.js?");

/***/ }),

/***/ "./src/core/credrank/edgeGadgets.js":
/*!******************************************!*\
  !*** ./src/core/credrank/edgeGadgets.js ***!
  \******************************************/
/*! exports provided: GADGET_EDGE_PREFIX, radiationGadget, seedMintGadget, payoutGadget, forwardWebbingGadget, backwardWebbingGadget, personalAttributionGadget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GADGET_EDGE_PREFIX\", function() { return GADGET_EDGE_PREFIX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"radiationGadget\", function() { return radiationGadget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"seedMintGadget\", function() { return seedMintGadget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"payoutGadget\", function() { return payoutGadget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forwardWebbingGadget\", function() { return forwardWebbingGadget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"backwardWebbingGadget\", function() { return backwardWebbingGadget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"personalAttributionGadget\", function() { return personalAttributionGadget; });\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/uuid */ \"./src/util/uuid.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph */ \"./src/core/graph.js\");\n/* harmony import */ var _markovEdge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./markovEdge */ \"./src/core/credrank/markovEdge.js\");\n/* harmony import */ var _nodeGadgets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nodeGadgets */ \"./src/core/credrank/nodeGadgets.js\");\n/**\n * A helper function for creating a gadget only produces edges incident to seed.\n * We assume that it has a function for converting from the target type into node address parts, which will\n * be used to produce a unique edge address, and which are the address parts for the src or dst.\n * If seedIsSrc is true, then the seed is the src and the dst will be the target. Otherwise, the seed is the dst\n * and the target will be the src.\n * These markov edges are never reversed.\n */function makeSeedGadget(_ref){let{edgePrefix,seedIsSrc,toParts,fromParts}=_ref;const prefix=Object(_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"markovEdgeAddress\"])(edgePrefix,\"F\");const prefixLength=_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].toParts(prefix).length;const toRaw=target=>_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].append(prefix,...toParts(target));const fromRaw=addr=>fromParts(_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].toParts(addr).slice(prefixLength));const markovEdge=(target,transitionProbability)=>{const seed=_nodeGadgets__WEBPACK_IMPORTED_MODULE_3__[\"seedGadget\"].prefix;const targetAddress=_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(toParts(target));return{address:_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,...toParts(target)),reversed:false,src:seedIsSrc?seed:targetAddress,dst:seedIsSrc?targetAddress:seed,transitionProbability};};return Object.freeze({prefix,toRaw,fromRaw,markovEdge});}const GADGET_EDGE_PREFIX=_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].fromParts([\"sourcecred\",\"core\",\"gadget\"]);const radiationGadget=makeSeedGadget({edgePrefix:_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(GADGET_EDGE_PREFIX,\"RADIATION\"),seedIsSrc:false,toParts:x=>_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(x),fromParts:x=>_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(x)});const seedMintGadget=makeSeedGadget({edgePrefix:_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(GADGET_EDGE_PREFIX,\"SEED_MINT\"),seedIsSrc:true,toParts:x=>_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(x),fromParts:x=>_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(x)});/**\n * The payout gadget creates edges that connect participant epoch nodes to the\n * epoch accumulator nodes. Each payout edge represents the flow of Cred from a\n * participant's epoch back to the seed (by means of the accumulator). Thus,\n * the Cred flow on this edge actually represents Cred score for the\n * participant. (The Cred score of the epoch node can't be seen as the user's\n * score, because some of it flows to other contributions, to other epoch\n * nodes, etc.)\n */const payoutGadget=(()=>{const edgePrefix=_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(GADGET_EDGE_PREFIX,\"PAYOUT\");const prefix=Object(_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"markovEdgeAddress\"])(edgePrefix,\"F\");const prefixLength=_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].toParts(prefix).length;const toRaw=_ref2=>{let{epochStart,owner}=_ref2;return _markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].append(prefix,String(epochStart),owner);};const fromRaw=addr=>{const parts=_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].toParts(addr).slice(prefixLength);const epochStart=+parts[0];const owner=Object(_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"fromString\"])(parts[1]);return{epochStart,owner};};const markovEdge=(_ref3,transitionProbability)=>{let{owner,epochStart}=_ref3;return{address:_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,String(epochStart),owner),reversed:false,src:_nodeGadgets__WEBPACK_IMPORTED_MODULE_3__[\"epochGadget\"].toRaw({owner,epochStart}),dst:_nodeGadgets__WEBPACK_IMPORTED_MODULE_3__[\"accumulatorGadget\"].toRaw({epochStart}),transitionProbability};};return Object.freeze({prefix,toRaw,fromRaw,markovEdge});})();const webbingEdgePrefix=_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(GADGET_EDGE_PREFIX,\"EPOCH_WEBBING\");/**\n * The forward webbing edges flow Cred forwards from participant epoch nodes to\n * the temporally next epoch node from the same participant. The intention is\n * to \"smooth out\" Cred over time by having some of it flow forwards in time.\n */const forwardWebbingGadget=(()=>{const prefix=Object(_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"markovEdgeAddress\"])(webbingEdgePrefix,\"F\");const prefixLength=_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].toParts(prefix).length;const toRaw=_ref4=>{let{thisStart,lastStart,owner}=_ref4;return _markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].append(prefix,String(lastStart),String(thisStart),owner);};const fromRaw=address=>{const parts=_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].toParts(address).slice(prefixLength);const lastStart=+parts[0];const thisStart=+parts[1];const owner=Object(_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"fromString\"])(parts[2]);return{lastStart,thisStart,owner};};const markovEdge=(_ref5,transitionProbability)=>{let{thisStart,lastStart,owner}=_ref5;const thisEpoch={epochStart:thisStart,owner};const lastEpoch={epochStart:lastStart,owner};return{address:_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(webbingEdgePrefix,String(lastStart),String(thisStart),owner),reversed:false,src:_nodeGadgets__WEBPACK_IMPORTED_MODULE_3__[\"epochGadget\"].toRaw(lastEpoch),dst:_nodeGadgets__WEBPACK_IMPORTED_MODULE_3__[\"epochGadget\"].toRaw(thisEpoch),transitionProbability};};return{prefix,toRaw,fromRaw,markovEdge};})();/**\n * The backward webbing edges flow Cred backwards from participant epoch nodes\n * to the temporally previous epoch node from the same participant. The\n * intention is to \"smooth out\" Cred over time by having some of it flow\n * backwards in time.\n */const backwardWebbingGadget=(()=>{const prefix=Object(_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"markovEdgeAddress\"])(webbingEdgePrefix,\"B\");const prefixLength=_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].toParts(prefix).length;const toRaw=_ref6=>{let{thisStart,lastStart,owner}=_ref6;return _markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].append(prefix,String(lastStart),String(thisStart),owner);};const fromRaw=address=>{const parts=_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].toParts(address).slice(prefixLength);const lastStart=+parts[0];const thisStart=+parts[1];const owner=Object(_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"fromString\"])(parts[2]);return{lastStart,thisStart,owner};};const markovEdge=(_ref7,transitionProbability)=>{let{thisStart,lastStart,owner}=_ref7;const thisEpoch={epochStart:thisStart,owner};const lastEpoch={epochStart:lastStart,owner};return{address:_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(webbingEdgePrefix,String(lastStart),String(thisStart),owner),reversed:true,src:_nodeGadgets__WEBPACK_IMPORTED_MODULE_3__[\"epochGadget\"].toRaw(thisEpoch),dst:_nodeGadgets__WEBPACK_IMPORTED_MODULE_3__[\"epochGadget\"].toRaw(lastEpoch),transitionProbability};};return{prefix,toRaw,fromRaw,markovEdge};})();const personalAttributionGadget=(()=>{const edgePrefix=_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(GADGET_EDGE_PREFIX,\"ATTRIBUTION\");const prefix=Object(_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"markovEdgeAddress\"])(edgePrefix,\"F\");const prefixLength=_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].toParts(prefix).length;const toRaw=_ref8=>{let{epochStart,fromParticipantId,toParticipantId}=_ref8;return _markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].append(prefix,String(epochStart),fromParticipantId,toParticipantId);};const fromRaw=addr=>{const parts=_markovEdge__WEBPACK_IMPORTED_MODULE_2__[\"MarkovEdgeAddress\"].toParts(addr).slice(prefixLength);const epochStart=+parts[0];const fromParticipantId=Object(_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"fromString\"])(parts[1]);const toParticipantId=Object(_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"fromString\"])(parts[2]);return{epochStart,fromParticipantId,toParticipantId};};const markovEdge=(_ref9,transitionProbability)=>{let{epochStart,fromParticipantId,toParticipantId}=_ref9;return{address:_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,String(epochStart),fromParticipantId,toParticipantId),reversed:false,src:_nodeGadgets__WEBPACK_IMPORTED_MODULE_3__[\"epochGadget\"].toRaw({owner:fromParticipantId,epochStart}),dst:_nodeGadgets__WEBPACK_IMPORTED_MODULE_3__[\"epochGadget\"].toRaw({owner:toParticipantId,epochStart}),transitionProbability};};return Object.freeze({prefix,toRaw,fromRaw,markovEdge});})();\n\n//# sourceURL=webpack:///./src/core/credrank/edgeGadgets.js?");

/***/ }),

/***/ "./src/core/credrank/markovEdge.js":
/*!*****************************************!*\
  !*** ./src/core/credrank/markovEdge.js ***!
  \*****************************************/
/*! exports provided: MarkovEdgeAddress, markovEdgeAddress, markovEdgeAddressFromMarkovEdge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MarkovEdgeAddress\", function() { return MarkovEdgeAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"markovEdgeAddress\", function() { return markovEdgeAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"markovEdgeAddressFromMarkovEdge\", function() { return markovEdgeAddressFromMarkovEdge; });\n/* harmony import */ var _address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address */ \"./src/core/address.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph */ \"./src/core/graph.js\");\nconst MarkovEdgeAddress=Object(_address__WEBPACK_IMPORTED_MODULE_0__[\"makeAddressModule\"])({name:\"MarkovEdgeAddress\",nonce:\"ME\",otherNonces:new Map().set(\"N\",\"NodeAddress\").set(\"E\",\"EdgeAddress\")});function markovEdgeAddress(edgeAddress,direction){return MarkovEdgeAddress.fromParts([direction,..._graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].toParts(edgeAddress)]);}function markovEdgeAddressFromMarkovEdge(edge){return markovEdgeAddress(edge.address,edge.reversed?\"B\"/* Backward */:\"F\"/* Forward */);}\n\n//# sourceURL=webpack:///./src/core/credrank/markovEdge.js?");

/***/ }),

/***/ "./src/core/credrank/markovNode.js":
/*!*****************************************!*\
  !*** ./src/core/credrank/markovNode.js ***!
  \*****************************************/
/*! exports provided: parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph */ \"./src/core/graph.js\");\nconst parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({address:_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].parser,description:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],mint:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"]});\n\n//# sourceURL=webpack:///./src/core/credrank/markovNode.js?");

/***/ }),

/***/ "./src/core/credrank/markovProcessGraph.js":
/*!*************************************************!*\
  !*** ./src/core/credrank/markovProcessGraph.js ***!
  \*************************************************/
/*! exports provided: participantParser, parametersParser, MarkovProcessGraph, jsonParser, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"participantParser\", function() { return participantParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parametersParser\", function() { return parametersParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MarkovProcessGraph\", function() { return MarkovProcessGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"jsonParser\", function() { return jsonParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/uuid */ \"./src/util/uuid.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var lodash_sortedindex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash.sortedindex */ \"lodash.sortedindex\");\n/* harmony import */ var lodash_sortedindex__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_sortedindex__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../graph */ \"./src/core/graph.js\");\n/* harmony import */ var _algorithm_weightEvaluator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../algorithm/weightEvaluator */ \"./src/core/algorithm/weightEvaluator.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/map */ \"./src/util/map.js\");\n/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../interval */ \"./src/core/interval.js\");\n/* harmony import */ var _personalAttribution__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./personalAttribution */ \"./src/core/credrank/personalAttribution.js\");\n/* harmony import */ var _markovNode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./markovNode */ \"./src/core/credrank/markovNode.js\");\n/* harmony import */ var _markovEdge__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./markovEdge */ \"./src/core/credrank/markovEdge.js\");\n/* harmony import */ var _nodeGadgets__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./nodeGadgets */ \"./src/core/credrank/nodeGadgets.js\");\n/* harmony import */ var _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./edgeGadgets */ \"./src/core/credrank/edgeGadgets.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * Data structure representing a particular kind of Markov process, as\n * kind of a middle ground between the semantic SourceCred graph (in the\n * `core/graph` module) and a literal transition matrix. Unlike the core\n * graph, edges in a Markov process graph are unidirectional, edge\n * weights are raw transition probabilities (which must sum to 1) rather\n * than unnormalized weights, and there are no dangling edges. Unlike a\n * fully general transition matrix, parallel edges are still reified,\n * not collapsed; nodes have weights, representing sources of flow; and\n * a few SourceCred-specific concepts are made first-class:\n * specifically, cred minting and time period fibration. The\n * \"teleportation vector\" from PageRank is also made explicit via the\n * \"adjoined seed node\" graph transformation strategy, so this data\n * structure can form well-defined Markov processes even from graphs\n * with nodes with no out-weight. Because the graph reifies the\n * teleportation and temporal fibration, the associated parameters are\n * \"baked in\" to weights of the Markov process graph.\n *\n * We use the term \"fibration\" to refer to a graph transformation where\n * each scoring node is split into one node per epoch, and incident\n * edges are rewritten to point to the appropriate epoch nodes. The term\n * is vaguely inspired from the notion of a fiber bundle, though the\n * analogy is not precise.\n *\n * The Markov process graphs in this module have three kinds of nodes:\n *\n *   - *base nodes*, which are in 1-to-1 correspondence with the nodes\n *     in the underlying core graph that are not scoring nodes;\n *   - *user-epoch nodes*, which are created for each time period for\n *     each scoring node; and\n *   - *epoch accumulators*, which are created once for each epoch to\n *     aggregate over the epoch nodes,\n *   - the *seed node*, which reifies the teleportation vector and\n *     forces well-definedness and ergodicity of the Markov process (for\n *     nonzero alpha, and assuming that there is at least one edge in\n *     the underlying graph).\n *\n * The edges include:\n *\n *   - *base edges* due to edges in the underlying graph, whose\n *     endpoints are lifted to the corresponding base nodes or to\n *     user-epoch nodes for endpoints that have been fibrated;\n *   - *radiation edges* edges from nodes to the seed node;\n *   - *minting edges* from the seed node to cred-minting nodes;\n *   - *webbing edges* between temporally adjacent user-epoch nodes; and\n *   - *payout edges* from a user-epoch node to the accumulator for its\n *     epoch.\n *\n * A Markov process graph can be converted to a pure Markov chain for\n * spectral analysis via the `toMarkovChain` method.\n */const participantParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({address:_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].parser,description:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"string\"],id:_util_uuid__WEBPACK_IMPORTED_MODULE_1__[\"parser\"]});const parametersParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({alpha:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],beta:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],gammaForward:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],gammaBackward:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]});// A MarkovEdge in which the src and dst have been replaced with indices instead\n// of full addresses. The indexing is based on the order of nodes in the MarkovProcessGraphJSON.\nconst indexedEdgeParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({address:_graph__WEBPACK_IMPORTED_MODULE_4__[\"EdgeAddress\"].parser,reversed:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"boolean\"],src:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],dst:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],transitionProbability:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]});class MarkovProcessGraph{constructor(nodes,edges,participants,epochStarts,lastEpochEndMs,parameters,// Map from each node address to the proportion of total minting (i.e. its\n// transition probability from the seed node). Must sum to about 1.\nmintTransitionProbabilities,// Transition probabilities for radiation edges, in node order\nradiationTransitionProbabilities,indexedPersonalAttributions){_defineProperty(this,\"_nodes\",void 0);_defineProperty(this,\"_edges\",void 0);_defineProperty(this,\"_participants\",void 0);_defineProperty(this,\"_epochStarts\",void 0);_defineProperty(this,\"_lastEpochEndMs\",void 0);_defineProperty(this,\"_parameters\",void 0);_defineProperty(this,\"_mintTransitionProbabilties\",void 0);_defineProperty(this,\"_radiationTransitionProbabilties\",void 0);_defineProperty(this,\"_nodeIndex\",void 0);_defineProperty(this,\"_edgeIndex\",void 0);_defineProperty(this,\"_indexedPersonalAttributions\",void 0);this._nodes=nodes;this._edges=edges;this._epochStarts=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()(epochStarts);this._lastEpochEndMs=lastEpochEndMs;this._participants=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()(participants);this._parameters=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()(parameters);this._radiationTransitionProbabilties=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()(radiationTransitionProbabilities);this._mintTransitionProbabilties=mintTransitionProbabilities;// Precompute the index maps\nthis._nodeIndex=new Map([..._nodeOrder(nodes,epochStarts,participants)].map((a,i)=>[a,i]));this._edgeIndex=new Map([...edges.keys(),...virtualizedMarkovEdgeAddresses(epochStarts,participants,mintTransitionProbabilities,_nodeOrder(nodes,epochStarts,participants),indexedPersonalAttributions)].map((a,i)=>[a,i]));this._indexedPersonalAttributions=indexedPersonalAttributions;}static new(args){const{weightedGraph,participants,parameters,intervals,personalAttributions}=args;const{alpha,beta,gammaForward,gammaBackward}=parameters;const _nodes=new Map();const _edges=new Map();const _scoringAddressToId=new Map(participants.map(p=>[p.address,p.id]));const _scoringAddresses=new Set(participants.map(p=>p.address));// _nodeOutMasses[a] = sum(e.pr for e in edges if e.src == a)\n// Used for computing remainder-to-seed edges.\nconst _nodeOutMasses=new Map();// Amount of mass allocated to contribution edges flowing from epoch\n// nodes.\nconst epochTransitionRemainder=(()=>{const valid=x=>x>=0&&x<=1;if(!valid(beta)||!valid(gammaForward)||!valid(gammaBackward)||!valid(alpha)){throw new Error(\"Invalid transition probability: \"+[beta,gammaForward,gammaBackward,alpha].join(\" or \"));}const result=1-(alpha+beta+gammaForward+gammaBackward);if(result<0){throw new Error(\"Overlarge transition probability: \"+(1-result));}return result;})();if(intervals.length===0){throw new Error(\"need at least one interval\");}const epochStarts=intervals.map(x=>x.startTimeMs);const lastEpochEndMs=intervals[intervals.length-1].endTimeMs;const addNode=node=>{if(_nodes.has(node.address)){throw new Error(\"Node conflict: \"+node.address);}_nodes.set(node.address,node);};const addEdge=edge=>{const mae=Object(_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"markovEdgeAddressFromMarkovEdge\"])(edge);if(_edges.has(mae)){throw new Error(\"Edge conflict: \"+mae);}_edges.set(mae,edge);recordTransitionProbability(edge);};const recordTransitionProbability=edge=>{const pr=edge.transitionProbability;if(pr<0||pr>1){const mae=Object(_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"markovEdgeAddressFromMarkovEdge\"])(edge);const name=_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"MarkovEdgeAddress\"].toString(mae);throw new Error(\"Invalid transition probability for \".concat(name,\": \").concat(pr));}_nodeOutMasses.set(edge.src,(_nodeOutMasses.get(edge.src)||0)+pr);};const indexedPersonalAttributions=new _personalAttribution__WEBPACK_IMPORTED_MODULE_9__[\"IndexedPersonalAttributions\"](personalAttributions,epochStarts);// Add graph nodes\nconst nwe=Object(_algorithm_weightEvaluator__WEBPACK_IMPORTED_MODULE_5__[\"nodeWeightEvaluator\"])(weightedGraph.weights);for(const node of weightedGraph.graph.nodes()){if(_scoringAddresses.has(node.address)){// Scoring nodes are not included in the Markov process graph:\n// the cred for a scoring node is given implicitly by the\n// weight-sum of its epoch accumulation edges.\ncontinue;}const weight=nwe(node.address);if(weight<0||!Number.isFinite(weight)){const name=_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].toString(node.address);throw new Error(\"Bad node weight for \".concat(name,\": \").concat(weight));}if(_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].hasPrefix(node.address,_nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"GADGET_NODE_PREFIX\"])){throw new Error(\"Unexpected core node in underlying graph: \"+_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].toString(node.address));}addNode({address:node.address,description:node.description,mint:weight});}// Add epoch nodes, epoch accumulators, payout edges, and epoch webbing\nlet lastEpochStart=null;for(const epochStart of epochStarts){for(const participant of participants){const thisEpoch={owner:participant.id,epochStart};recordTransitionProbability(_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"payoutGadget\"].markovEdge(thisEpoch,beta));if(lastEpochStart!=null){const webbingAddress={thisStart:epochStart,lastStart:lastEpochStart,owner:participant.id};recordTransitionProbability(_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"forwardWebbingGadget\"].markovEdge(webbingAddress,gammaForward));recordTransitionProbability(_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"backwardWebbingGadget\"].markovEdge(webbingAddress,gammaBackward));}else{// There is no lastEpochStart, which means this is the first epoch. We will instead create a \"backwards\"\n// edge which is actually a loop, so as to avoid Cred distortion where scores are biased downward\n// for the first epoch.\nconst webbingAddress={thisStart:epochStart,lastStart:epochStart,owner:participant.id};const edge=_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"backwardWebbingGadget\"].markovEdge(webbingAddress,gammaBackward);recordTransitionProbability(edge);}}lastEpochStart=epochStart;}if(lastEpochStart==null){// Just to satisfy flow when adding the final \"forward\" webbing edges (which are loops).\nthrow new Error(\"invariant violation: there were no epochs\");}// Now for the last epochStart, we create a \"forwards\" webbing edge which is actually a loop, as as to\n// avoid Cred distortion where the scores are biased downward for the last epoch.\nfor(const participant of participants){const webbingAddress={thisStart:lastEpochStart,lastStart:lastEpochStart,owner:participant.id};const edge=_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"forwardWebbingGadget\"].markovEdge(webbingAddress,gammaForward);recordTransitionProbability(edge);}const mintTransitionProbabilities=new Map();// Add minting edges, from the seed to positive-weight graph nodes\n{let totalNodeWeight=0.0;const positiveNodeWeights=new Map();for(const{address,mint}of _nodes.values()){if(mint>0){totalNodeWeight+=mint;positiveNodeWeights.set(address,mint);}}if(!(totalNodeWeight>0)){throw new Error(\"No outflow from seed; add cred-minting nodes\");}for(const[address,weight]of positiveNodeWeights){mintTransitionProbabilities.set(address,weight/totalNodeWeight);}}/**\n     * Find an epoch node, or just the original node if it's not a\n     * scoring address.\n     */const rewriteEpochNode=(address,edgeTimestampMs)=>{const owner=_scoringAddressToId.get(address);if(owner==null){return address;}const epochEndIndex=lodash_sortedindex__WEBPACK_IMPORTED_MODULE_3___default()(epochStarts,edgeTimestampMs);const epochStartIndex=epochEndIndex-1;const epochTimestampMs=epochStarts[epochStartIndex];return _nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"epochGadget\"].toRaw({owner,epochStart:epochTimestampMs});};// Add graph edges. First, split by direction.\nconst unidirectionalGraphEdges=function*unidirectionalGraphEdges(){const ewe=Object(_algorithm_weightEvaluator__WEBPACK_IMPORTED_MODULE_5__[\"edgeWeightEvaluator\"])(weightedGraph.weights);for(const edge of function*(){for(const edge of weightedGraph.graph.edges({showDangling:false})){const weight=ewe(edge.address);yield{address:edge.address,reversed:false,src:edge.src,dst:edge.dst,timestamp:edge.timestampMs,weight:weight.forwards};yield{address:edge.address,reversed:true,src:edge.dst,dst:edge.src,timestamp:edge.timestampMs,weight:weight.backwards};}}()){if(edge.weight>0){yield edge;}}};const srcNodes=new Map();for(const graphEdge of unidirectionalGraphEdges()){const src=rewriteEpochNode(graphEdge.src,graphEdge.timestamp);let datum=srcNodes.get(src);if(datum==null){datum={totalOutWeight:0,outEdges:[]};srcNodes.set(src,datum);}datum.totalOutWeight+=graphEdge.weight;datum.outEdges.push(graphEdge);}for(const[src,{totalOutWeight,outEdges}]of srcNodes){const totalOutPr=_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].hasPrefix(src,_nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"epochGadget\"].prefix)?epochTransitionRemainder:1-alpha;for(const outEdge of outEdges){const pr=outEdge.weight/totalOutWeight*totalOutPr;addEdge({address:outEdge.address,reversed:outEdge.reversed,src:rewriteEpochNode(outEdge.src,outEdge.timestamp),dst:rewriteEpochNode(outEdge.dst,outEdge.timestamp),transitionProbability:pr});}}function*realAndVirtualNodes(){yield*_nodes.values();for(const nodeAddress of virtualizedNodeAddresses(epochStarts,participants)){yield _util_null__WEBPACK_IMPORTED_MODULE_6__[\"get\"](virtualizedNode(nodeAddress));}}const radiationTransitionProbabilities=[...realAndVirtualNodes()].map(node=>{return 1-_util_null__WEBPACK_IMPORTED_MODULE_6__[\"orElse\"](_nodeOutMasses.get(node.address),0);});return new MarkovProcessGraph(_nodes,_edges,participants,epochStarts,lastEpochEndMs,parameters,mintTransitionProbabilities,radiationTransitionProbabilities,indexedPersonalAttributions);}epochStarts(){return this._epochStarts;}intervals(){const es=this._epochStarts;const intervals=[];for(let i=0;i<es.length;i++){const startTimeMs=es[i];const endTimeMs=i+1<es.length?es[i+1]:this._lastEpochEndMs;intervals.push({startTimeMs,endTimeMs});}return Object(_interval__WEBPACK_IMPORTED_MODULE_8__[\"intervalSequence\"])(intervals);}participants(){return this._participants;}parameters(){return this._parameters;}/**\n   * Return the node address's canonical index in the\n   * node order, if it is present.\n   */nodeIndex(address){return _util_null__WEBPACK_IMPORTED_MODULE_6__[\"orElse\"](this._nodeIndex.get(address),null);}/**\n   * Returns a canonical ordering of the nodes in the graph.\n   *\n   * No assumptions should be made about the node order, other than\n   * that it is stable for any given MarkovProcessGraph.\n   */*nodeOrder(){yield*_nodeOrder(this._nodes,this._epochStarts,this._participants);}node(address){_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].assertValid(address);return this._nodes.get(address)||virtualizedNode(address);}/**\n   * Iterate over the nodes in the graph. If a prefix is provided,\n   * only nodes matching that prefix will be returned.\n   *\n   * The nodes are always iterated over in the node order.\n   */*nodes(options){const prefix=options?options.prefix:_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].empty;for(const[address,markovNode]of this._nodes){if(_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].hasPrefix(address,prefix)){yield markovNode;}}for(const address of virtualizedNodeAddresses(this._epochStarts,this._participants)){if(_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].hasPrefix(address,prefix)){yield _util_null__WEBPACK_IMPORTED_MODULE_6__[\"get\"](virtualizedNode(address));}}}/**\n   * Return the edge address's canonical index in the\n   * edge order, if it is present.\n   */edgeIndex(address){return _util_null__WEBPACK_IMPORTED_MODULE_6__[\"orElse\"](this._edgeIndex.get(address),null);}/**\n   * Returns a canonical ordering of the edges in the graph.\n   *\n   * No assumptions should be made about the edge order, other than\n   * that it is stable for any given MarkovProcessGraph.\n   */*edgeOrder(){yield*this._edges.keys();yield*virtualizedMarkovEdgeAddresses(this._epochStarts,this._participants,this._mintTransitionProbabilties,this.nodeOrder(),this._indexedPersonalAttributions);}edge(address){_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"MarkovEdgeAddress\"].assertValid(address);return this._edges.get(address)||virtualizedMarkovEdge(address,this._parameters,this._nodeIndex,this._mintTransitionProbabilties,this._radiationTransitionProbabilties,this._indexedPersonalAttributions);}/**\n   * Iterate over the edges in the graph.\n   *\n   * The edges are always iterated over in the edge order.\n   */*edges(){yield*this._edges.values();for(const addr of virtualizedMarkovEdgeAddresses(this._epochStarts,this._participants,this._mintTransitionProbabilties,this.nodeOrder(),this._indexedPersonalAttributions)){yield _util_null__WEBPACK_IMPORTED_MODULE_6__[\"get\"](virtualizedMarkovEdge(addr,this._parameters,this._nodeIndex,this._mintTransitionProbabilties,this._radiationTransitionProbabilties,this._indexedPersonalAttributions));}}*inNeighbors(nodeAddress){for(const edge of this.edges()){if(edge.dst!==nodeAddress){continue;}yield edge;}}toMarkovChain(){// We will need to map over the nodes, so we array-ify it upfront\nconst nodes=Array.from(this.nodes());// Check that out-edges sum to about 1.\nconst nodeOutMasses=new Map();for(const{address}of nodes){nodeOutMasses.set(address,0);}for(const edge of this.edges()){const a=edge.src;nodeOutMasses.set(a,_util_null__WEBPACK_IMPORTED_MODULE_6__[\"get\"](nodeOutMasses.get(a))+edge.transitionProbability);}for(const[node,outMass]of nodeOutMasses){const discrepancy=outMass-1;if(Math.abs(discrepancy)>1e-3){const name=_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].toString(node);throw new Error(\"Transition weights for \".concat(name,\" do not sum to 1.0: \").concat(outMass));}}const inNeighbors=new Map();for(const edge of this.edges()){_util_map__WEBPACK_IMPORTED_MODULE_7__[\"pushValue\"](inNeighbors,edge.dst,edge);}const chain=nodes.map(_ref=>{let{address}=_ref;const inEdges=_util_null__WEBPACK_IMPORTED_MODULE_6__[\"orElse\"](inNeighbors.get(address),[]);const inDegree=inEdges.length;const neighbor=new Uint32Array(inDegree);const weight=new Float64Array(inDegree);inEdges.forEach((e,i)=>{// Note: We don't group-by src, so there may be multiple `j`\n// such that `neighbor[j] === k` for a given `k` when there are\n// parallel edges in the source graph. This should just work\n// down the stack.\nconst srcIndex=this.nodeIndex(e.src);if(srcIndex==null){throw new Error(e.src);}neighbor[i]=srcIndex;weight[i]=e.transitionProbability;});return{neighbor,weight};});return{nodeOrder:nodes.map(x=>x.address),chain};}toJSON(){const indexedEdges=Array.from(this._edges.values()).map(e=>({address:e.address,reversed:e.reversed,src:_util_null__WEBPACK_IMPORTED_MODULE_6__[\"get\"](this.nodeIndex(e.src)),dst:_util_null__WEBPACK_IMPORTED_MODULE_6__[\"get\"](this.nodeIndex(e.dst)),transitionProbability:e.transitionProbability}));const indexedMints=Array.from(this._mintTransitionProbabilties).map(_ref2=>{let[addr,pr]=_ref2;return[_util_null__WEBPACK_IMPORTED_MODULE_6__[\"get\"](this.nodeIndex(addr)),pr];});return{nodes:[...this._nodes.values()],indexedEdges,participants:this._participants,epochStarts:this._epochStarts,lastEpochEndMs:this._lastEpochEndMs,parameters:this._parameters,radiationTransitionProbabilities:this._radiationTransitionProbabilties,indexedMints,personalAttributions:this._indexedPersonalAttributions.toPersonalAttributions()};}static fromJSON(j){const{nodes,indexedEdges,participants,epochStarts,lastEpochEndMs,parameters,radiationTransitionProbabilities,indexedMints,personalAttributions}=j;const nodeOrder=[...nodes.map(n=>n.address),...virtualizedNodeAddresses(epochStarts,participants)];const edges=indexedEdges.map(e=>({address:e.address,reversed:e.reversed,src:nodeOrder[e.src],dst:nodeOrder[e.dst],transitionProbability:e.transitionProbability}));const mintTransitionProbabilities=new Map(indexedMints.map(_ref3=>{let[i,pr]=_ref3;return[nodeOrder[i],pr];}));const indexedPersonalAttributions=new _personalAttribution__WEBPACK_IMPORTED_MODULE_9__[\"IndexedPersonalAttributions\"](personalAttributions,epochStarts);return new MarkovProcessGraph(new Map(nodes.map(n=>[n.address,n])),new Map(edges.map(e=>[Object(_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"markovEdgeAddressFromMarkovEdge\"])(e),e])),participants,epochStarts,lastEpochEndMs,parameters,mintTransitionProbabilities,radiationTransitionProbabilities,indexedPersonalAttributions);}}/**\n * Yield the canonical node order.\n * This has been separated from the class because we need it at construction time, etc.\n */function*_nodeOrder(nodes,epochStarts,participants){yield*nodes.keys();yield*virtualizedNodeAddresses(epochStarts,participants);}/**\n * Return an array containing the node addresses for every\n * virtualized node. The order must be stable.\n */function*virtualizedNodeAddresses(epochStarts,participants){yield _nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"seedGadget\"].prefix;for(const epochStart of epochStarts){yield _nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"accumulatorGadget\"].toRaw({epochStart});for(const{id}of participants){yield _nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"epochGadget\"].toRaw({owner:id,epochStart});}}}function virtualizedNode(address){// Perf tweak: Check the most common node types first, and rarest\n// last.\nif(_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].hasPrefix(address,_nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"epochGadget\"].prefix)){return _nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"epochGadget\"].node(_nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"epochGadget\"].fromRaw(address));}if(_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].hasPrefix(address,_nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"accumulatorGadget\"].prefix)){return _nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"accumulatorGadget\"].node(_nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"accumulatorGadget\"].fromRaw(address));}if(_graph__WEBPACK_IMPORTED_MODULE_4__[\"NodeAddress\"].hasPrefix(address,_nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"seedGadget\"].prefix)){return _nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"seedGadget\"].node();}return null;}function*virtualizedMarkovEdgeAddresses(epochStarts,participants,mintTransitionProbabilities,nodeOrder,indexedPersonalAttributions){let lastStart=null;for(const epochStart of epochStarts){for(const{id}of participants){yield _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"payoutGadget\"].toRaw({owner:id,epochStart});for(const toParticipantId of indexedPersonalAttributions.recipientsForEpochAndParticipant(epochStart,id)){yield _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"personalAttributionGadget\"].toRaw({epochStart,fromParticipantId:id,toParticipantId});}if(lastStart!=null){const webbingAddress={thisStart:epochStart,lastStart,owner:id};yield _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"forwardWebbingGadget\"].toRaw(webbingAddress);yield _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"backwardWebbingGadget\"].toRaw(webbingAddress);}else{const webbingAddress={thisStart:epochStart,lastStart:epochStart,owner:id};yield _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"backwardWebbingGadget\"].toRaw(webbingAddress);}}lastStart=epochStart;}if(lastStart==null){// Needed to satisfy flow when adding the final \"forward\" webbing edges (which are loops).\nthrow new Error(\"invariant violation: there were no epochs\");}for(const{id}of participants){const webbingAddress={thisStart:lastStart,lastStart,owner:id};yield _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"forwardWebbingGadget\"].toRaw(webbingAddress);}for(const addr of mintTransitionProbabilities.keys()){yield _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"seedMintGadget\"].toRaw(addr);}for(const addr of nodeOrder){if(addr===_nodeGadgets__WEBPACK_IMPORTED_MODULE_12__[\"seedGadget\"].prefix){continue;}yield _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"radiationGadget\"].toRaw(addr);}}function virtualizedMarkovEdge(address,parameters,nodeIndex,mintTransitionProbabilities,radiationTransitionProbabilities,indexedPersonalAttributions){if(_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"MarkovEdgeAddress\"].hasPrefix(address,_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"radiationGadget\"].prefix)){const nodeAddress=_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"radiationGadget\"].fromRaw(address);const index=_util_null__WEBPACK_IMPORTED_MODULE_6__[\"get\"](nodeIndex.get(nodeAddress));const probability=radiationTransitionProbabilities[index];return _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"radiationGadget\"].markovEdge(nodeAddress,probability);}if(_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"MarkovEdgeAddress\"].hasPrefix(address,_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"seedMintGadget\"].prefix)){const nodeAddress=_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"seedMintGadget\"].fromRaw(address);const probability=_util_null__WEBPACK_IMPORTED_MODULE_6__[\"get\"](mintTransitionProbabilities.get(nodeAddress));return _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"seedMintGadget\"].markovEdge(nodeAddress,probability);}if(_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"MarkovEdgeAddress\"].hasPrefix(address,_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"payoutGadget\"].prefix)){const payoutAddress=_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"payoutGadget\"].fromRaw(address);const sumOfPersonalAttributions=indexedPersonalAttributions.getSumProportionValue(payoutAddress.epochStart,payoutAddress.owner)||0;return _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"payoutGadget\"].markovEdge(_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"payoutGadget\"].fromRaw(address),parameters.beta-sumOfPersonalAttributions*parameters.beta);}if(_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"MarkovEdgeAddress\"].hasPrefix(address,_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"forwardWebbingGadget\"].prefix)){return _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"forwardWebbingGadget\"].markovEdge(_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"forwardWebbingGadget\"].fromRaw(address),parameters.gammaForward);}if(_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"MarkovEdgeAddress\"].hasPrefix(address,_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"backwardWebbingGadget\"].prefix)){return _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"backwardWebbingGadget\"].markovEdge(_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"backwardWebbingGadget\"].fromRaw(address),parameters.gammaBackward);}if(_markovEdge__WEBPACK_IMPORTED_MODULE_11__[\"MarkovEdgeAddress\"].hasPrefix(address,_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"personalAttributionGadget\"].prefix)){const personalAttributionAddress=_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"personalAttributionGadget\"].fromRaw(address);const proportionValue=indexedPersonalAttributions.getProportionValue(personalAttributionAddress.epochStart,personalAttributionAddress.fromParticipantId,personalAttributionAddress.toParticipantId)||0;if(proportionValue===0)return null;return _edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"personalAttributionGadget\"].markovEdge(_edgeGadgets__WEBPACK_IMPORTED_MODULE_13__[\"personalAttributionGadget\"].fromRaw(address),parameters.beta*proportionValue);}return null;}const jsonParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({nodes:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](_markovNode__WEBPACK_IMPORTED_MODULE_10__[\"parser\"]),indexedEdges:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](indexedEdgeParser),participants:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](participantParser),epochStarts:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]),lastEpochEndMs:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],parameters:parametersParser,radiationTransitionProbabilities:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]),indexedMints:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"tuple\"]([_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]])),personalAttributions:_personalAttribution__WEBPACK_IMPORTED_MODULE_9__[\"personalAttributionsParser\"]});const parser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"fmap\"](jsonParser,MarkovProcessGraph.fromJSON);\n\n//# sourceURL=webpack:///./src/core/credrank/markovProcessGraph.js?");

/***/ }),

/***/ "./src/core/credrank/nodeGadgets.js":
/*!******************************************!*\
  !*** ./src/core/credrank/nodeGadgets.js ***!
  \******************************************/
/*! exports provided: GADGET_NODE_PREFIX, seedGadget, accumulatorGadget, epochGadget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GADGET_NODE_PREFIX\", function() { return GADGET_NODE_PREFIX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"seedGadget\", function() { return seedGadget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"accumulatorGadget\", function() { return accumulatorGadget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"epochGadget\", function() { return epochGadget; });\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/uuid */ \"./src/util/uuid.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph */ \"./src/core/graph.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_2__);\n/**\n * This module contains logic for creating nodes and edges that act as \"gadgets\" in CredRank.\n * They are most directly used by markovProcessGraph.js\n */const GADGET_NODE_PREFIX=_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts([\"sourcecred\",\"core\",\"gadget\"]);const seedGadget=(()=>{const description=\"\\u{1f331}\";// U+1F331 SEEDLING\nconst prefix=_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(GADGET_NODE_PREFIX,\"SEED\");const toRaw=()=>prefix;const fromRaw=address=>{if(address!==prefix){throw new Error(\"not seed node: \".concat(address));}return;};const node=()=>({address:prefix,description,mint:0});return Object.freeze({prefix,toRaw,fromRaw,node});})();const accumulatorGadget=(()=>{const prefix=_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(GADGET_NODE_PREFIX,\"EPOCH_ACCUMULATOR\");const prefixLength=_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(prefix).length;function toRaw(addr){return _graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(prefix,String(addr.epochStart));}function fromRaw(addr){if(!_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].hasPrefix(addr,prefix)){throw new Error(\"Not an accumulator node address: \"+_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toString(addr));}const parts=_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(addr).slice(prefixLength);if(parts.length!==1){throw new Error(\"extra parts: \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_2___default()(parts)));}const epochStart=+parts[0];if(String(epochStart)!==parts[0]){throw new Error(\"bad epoch representation: \".concat(parts[0]));}return{epochStart};}function node(addr){return{address:toRaw(addr),description:\"Epoch accumulator starting \".concat(addr.epochStart,\" ms past epoch\"),mint:0};}return Object.freeze({prefix,toRaw,fromRaw,node});})();const epochGadget=(()=>{const prefix=_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(GADGET_NODE_PREFIX,\"USER_EPOCH\");const epochPrefixLength=_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(prefix).length;function toRaw(addr){return _graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(prefix,String(addr.epochStart),addr.owner);}function fromRaw(addr){if(!_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].hasPrefix(addr,prefix)){throw new Error(\"Not an epoch node address: \"+_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toString(addr));}const parts=_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(addr).slice(epochPrefixLength);const epochStart=+parts[0];const owner=Object(_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"fromString\"])(parts[1]);return{owner,epochStart};}function node(addr){return{address:toRaw(addr),description:\"Participant epoch for \".concat(addr.owner,\" starting \").concat(addr.epochStart,\" ms past epoch\"),mint:0};}return Object.freeze({prefix,toRaw,fromRaw,node});})();\n\n//# sourceURL=webpack:///./src/core/credrank/nodeGadgets.js?");

/***/ }),

/***/ "./src/core/credrank/personalAttribution.js":
/*!**************************************************!*\
  !*** ./src/core/credrank/personalAttribution.js ***!
  \**************************************************/
/*! exports provided: personalAttributionsParser, validatePersonalAttributions, IndexedPersonalAttributions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"personalAttributionsParser\", function() { return personalAttributionsParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validatePersonalAttributions\", function() { return validatePersonalAttributions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IndexedPersonalAttributions\", function() { return IndexedPersonalAttributions; });\n/* harmony import */ var lodash_findlast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.findlast */ \"lodash.findlast\");\n/* harmony import */ var lodash_findlast__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_findlast__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _identity_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity/id */ \"./src/core/identity/id.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n  This module allows participants to attribute their cred to other participants.\n  This feature should not be used to make cred sellable/transferable, but\n  instead is intended to allow participants to acknowledge that a portion of\n  their creditted outputs are directly generated/supported by the labor of\n  others. (e.g. when a contributor has a personal assistant working behind the \n  scenes)\n*/ /** \n  A timestamped configuration representing a decimal proportion of cred flow,\n  which can be applied to a participant pair.\n*/const personalAttributionsParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({fromParticipantId:_identity_id__WEBPACK_IMPORTED_MODULE_1__[\"identityIdParser\"],recipients:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({toParticipantId:_identity_id__WEBPACK_IMPORTED_MODULE_1__[\"identityIdParser\"],proportions:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({timestampMs:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],proportionValue:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]}))}))}));/**\n  Validates that:\n  1. There is only 1 entry per fromParticipantId.\n  1. Each fromParticipantId only has 1 entry per toParticipantId.\n  2. Proportions are in chronological order.\n  3. Proportions are a number between 0 and 1.\n*/function validatePersonalAttributions(personalAttributions){personalAttributions.forEach((pa,index)=>{if(personalAttributions.findIndex(x=>x.fromParticipantId===pa.fromParticipantId)!==index)throw\"More than one PersonalAttribution object found with fromParticipantId [\".concat(pa.fromParticipantId,\"]\");pa.recipients.forEach((ar,index)=>{if(pa.recipients.findIndex(x=>x.toParticipantId===ar.toParticipantId)!==index)throw\"More than one AttributionRecipient object found with toParticipantId [\".concat(ar.toParticipantId,\"] for fromParticipantId [\").concat(pa.fromParticipantId,\"] \");ar.proportions.forEach((proportion,index)=>{if(index>0&&proportion.timestampMs<ar.proportions[index-1].timestampMs)throw\"Personal Attribution proportions not in chronological order for [\".concat(pa.fromParticipantId,\"] to [\").concat(ar.toParticipantId,\"]\");if(proportion.proportionValue<0||1<proportion.proportionValue)throw\"Personal Attribution proportion value must be between 0 and 1, inclusive. Found [\".concat(proportion.proportionValue,\"].\");});});});}/**\n  This is the intermediary data structure used to index personal attributions\n  data, making lookups faster. It can be interpreted as:\n\n  $ReadOnlyMap<\n    fromParticipantId,\n    $ReadOnlyMap<toParticipantId, AttributionRecipient>\n  >\n */ /**\n  An indexed store of PersonalAttributions that includes optimized queries\n  needed by credrank.\n */class IndexedPersonalAttributions{/**\n    Validates and indexes the input.\n  */constructor(personalAttributions,epochStarts){_defineProperty(this,\"_index\",void 0);validatePersonalAttributions(personalAttributions);this._index=this._getIndexFromList(personalAttributions);this._validateIndex(this._index,epochStarts);}_getIndexFromList(personalAttributions){const index=new Map();for(const personalAttribution of personalAttributions){const recipientsIndex=new Map();for(const attributionRecipient of personalAttribution.recipients){recipientsIndex.set(attributionRecipient.toParticipantId,attributionRecipient);}index.set(personalAttribution.fromParticipantId,recipientsIndex);}return index;}/**\n    Validates that:\n    1. No participant is attributing more than 100% of their cred in any epoch.\n  */_validateIndex(index,epochStarts){for(const recipientsIndex of index.values()){for(const epochStart of epochStarts){const sum=this._getSumProportionValue(epochStart,Array.from(recipientsIndex.values()));if(sum&&sum>1)throw\"Sum of Personal Attributions for epoch [\".concat(epochStart,\"] is greater than 1. Found: [\").concat(sum,\"].\");}}}/**\n    Returns a non-indexed, json-friendly PersonalAttributions. The order\n    may be changed from the original PersonalAttributions that was used to\n    construct this object, but the elements are the same and the order is\n    generated consistently.\n   */toPersonalAttributions(){return Array.from(this._index.entries()).map(_ref=>{let[fromParticipantId,recipientsIndex]=_ref;return{fromParticipantId,recipients:Array.from(recipientsIndex.values())};});}/**\n    Return the IDs of all of the recipients that receive a non-zero proportion\n    of the given participant's cred in the given epoch.\n   */recipientsForEpochAndParticipant(epochStart,fromParticipantId){const recipientsIndex=this._index.get(fromParticipantId);if(!recipientsIndex)return[];return Array.from(recipientsIndex.values()).filter(_ref2=>{let{proportions}=_ref2;return this._getProportionValue(epochStart,proportions);}).map(_ref3=>{let{toParticipantId}=_ref3;return toParticipantId;});}/**\n    Returns the decimal proportion of the fromParticipant's cred that should \n    flow to the toParticipant in the given epoch.\n   */getProportionValue(epochStart,fromParticipantId,toParticipantId){const recipientsIndex=this._index.get(fromParticipantId);if(!recipientsIndex)throw\"Could not find PersonalAttribution from [\".concat(fromParticipantId,\"]\");const attributionRecipient=recipientsIndex.get(toParticipantId);if(!attributionRecipient)throw\"Could not find AttributionRecipient from [\".concat(fromParticipantId,\"] to [\").concat(toParticipantId,\"]\");return this._getProportionValue(epochStart,attributionRecipient.proportions);}_getProportionValue(epochStart,proportions){if(proportions.length&&epochStart<proportions[0].timestampMs)return null;const relevantProportion=lodash_findlast__WEBPACK_IMPORTED_MODULE_0___default()(proportions,proportion=>proportion.timestampMs<=epochStart);return relevantProportion?relevantProportion.proportionValue:null;}/**\n    Returns the total decimal proportion of the fromParticipant's cred that \n    should flow to other participants in the given epoch.\n   */getSumProportionValue(epochStart,fromParticipantId){const recipientsIndex=this._index.get(fromParticipantId);if(!recipientsIndex)return null;return this._getSumProportionValue(epochStart,Array.from(recipientsIndex.values()));}_getSumProportionValue(epochStart,attributionRecipients){const proportionValues=attributionRecipients.map(_ref4=>{let{proportions}=_ref4;return this._getProportionValue(epochStart,proportions);}).filter(proportionValue=>proportionValue!==null);if(proportionValues.length===0)return null;return proportionValues.reduce((a,b)=>b?a+b:a,0);}}\n\n//# sourceURL=webpack:///./src/core/credrank/personalAttribution.js?");

/***/ }),

/***/ "./src/core/graph.js":
/*!***************************!*\
  !*** ./src/core/graph.js ***!
  \***************************/
/*! exports provided: NodeAddress, EdgeAddress, Direction, Graph, nodeToString, edgeToString, edgeToStrings, edgeToParts, compareGraphs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NodeAddress\", function() { return NodeAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgeAddress\", function() { return EdgeAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Direction\", function() { return Direction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Graph\", function() { return Graph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodeToString\", function() { return nodeToString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeToString\", function() { return edgeToString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeToStrings\", function() { return edgeToStrings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeToParts\", function() { return edgeToParts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compareGraphs\", function() { return compareGraphs; });\n/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.isequal */ \"lodash.isequal\");\n/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./address */ \"./src/core/address.js\");\n/* harmony import */ var _util_compat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/compat */ \"./src/util/compat.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const NodeAddress=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"makeAddressModule\"])({name:\"NodeAddress\",nonce:\"N\",otherNonces:new Map().set(\"E\",\"EdgeAddress\")});const EdgeAddress=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"makeAddressModule\"])({name:\"EdgeAddress\",nonce:\"E\",otherNonces:new Map().set(\"N\",\"NodeAddress\")});/**\n * Represents a node in the graph.\n */const COMPAT_INFO={type:\"sourcecred/graph\",version:\"0.8.0\"};const Direction=deep_freeze__WEBPACK_IMPORTED_MODULE_1___default()({IN:Symbol(\"IN\"),OUT:Symbol(\"OUT\"),ANY:Symbol(\"ANY\")});class Graph{// Map every node address present in the graph to its inEdges (edges for\n// which it is a dst) and outEdges (edges for which it is a src)\n// Incremented each time that any change is made to the graph. Used to\n// check for comodification and to avoid needlessly checking\n// invariants.\nconstructor(){_defineProperty(this,\"_nodes\",void 0);_defineProperty(this,\"_edges\",void 0);_defineProperty(this,\"_incidentEdges\",void 0);_defineProperty(this,\"_modificationCount\",void 0);_defineProperty(this,\"_cachedOrder\",void 0);_defineProperty(this,\"_invariantsLastChecked\",void 0);this._modificationCount=0;this._invariantsLastChecked={when:-1,failure:\"Invariants never checked\"};this._cachedOrder={nodeOrder:[],edgeOrder:[],modificationCount:0};this._nodes=new Map();this._edges=new Map();this._incidentEdges=new Map();this._maybeCheckInvariants();}_checkForComodification(since){// TODO(perf): Consider eliding this in production.\nconst now=this._modificationCount;if(now===since){this._maybeCheckInvariants();return;}if(now>since){throw new Error(\"Concurrent modification detected\");}if(now<since){throw new Error(\"Invariant violation: expected modification count in the future\");}}_markModification(){// TODO(perf): Consider eliding this in production.\nif(this._modificationCount>=Number.MAX_SAFE_INTEGER){throw new Error(\"Graph cannot be modified more than \".concat(this._modificationCount,\" times.\"));}this._modificationCount++;this._maybeCheckInvariants();}/**\n   * A node address is 'referenced' if it is either present in the graph, or is\n   * the src or dst of some edge.\n   *\n   * Referenced nodes always have an entry in this._incidentEdges (regardless\n   * of whether they are incident to any edges).\n   *\n   * This method ensures that a given node address has a reference.\n   */_reference(n){if(!this._incidentEdges.has(n)){this._incidentEdges.set(n,{inEdges:[],outEdges:[]});}}/**\n   * A node stops being referenced as soon as it is both not in the graph, and is\n   * not incident to any edge. This method must be called after any operation which\n   * might cause a node address to no longer be referenced, so that the node can\n   * be unreferenced if appropriate.\n   */_unreference(n){const incidence=this._incidentEdges.get(n);if(incidence!=null){const{inEdges,outEdges}=incidence;if(!this._nodes.has(n)&&inEdges.length===0&&outEdges.length===0){this._incidentEdges.delete(n);}}}_getOrder(){const modificationCount=this._modificationCount;if(this._cachedOrder.modificationCount!==modificationCount){const edgeOrder=Array.from(this._edges.keys()).sort();const nodeOrder=Array.from(this._nodes.keys()).sort();this._cachedOrder={nodeOrder,edgeOrder,modificationCount};}return this._cachedOrder;}/**\n   * Returns how many times the graph has been modified.\n   *\n   * This value is exposed so that users of Graph can cache computations over\n   * the graph with confidence, knowing that they will be able to check the\n   * modification count to know when their cache is potentially invalid.\n   *\n   * This value may increase any time the graph is potentially modified, even\n   * if no modification actually occurs; for example, if a client calls\n   * `addNode`, the modification count may increase even if the added node was\n   * already present in the graph.\n   *\n   * This value is not serialized, and is ignored when checking equality, i.e.\n   * two graphs may be semantically equal even when they have different\n   * modification counts.\n   */modificationCount(){return this._modificationCount;}/**\n   * Adds a new node to the graph.\n   *\n   * If the node already exists in the graph, no action is taken and no error\n   * is thrown. (This operation is idempotent).\n   *\n   * Returns `this` for chaining.\n   */addNode(node){const{address}=node;NodeAddress.assertValid(address);this._reference(address);const existingNode=this._nodes.get(address);if(existingNode==null){this._nodes.set(address,node);}else{if(!lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(node,existingNode)){const strNode=nodeToString(node);const strExisting=nodeToString(existingNode);throw new Error(\"conflict between new node \".concat(strNode,\" and existing \").concat(strExisting));}}this._markModification();this._maybeCheckInvariants();return this;}/**\n   * Remove a node from the graph.\n   *\n   * If the node does not exist in the graph, no action is taken and no error\n   * is thrown. (This operation is idempotent.)\n   *\n   * Removing a node which is incident to some edges is allowed; such edges will\n   * become dangling edges. See the discussion of 'Dangling Edges' in the module docstring\n   * for details.\n   *\n   * Returns `this` for chaining.\n   */removeNode(a){NodeAddress.assertValid(a);this._nodes.delete(a);this._unreference(a);this._markModification();this._maybeCheckInvariants();return this;}/**\n   * Test whether there exists a Node corresponding to the given NodeAddress.\n   *\n   * This will return false for node addresses which are referenced by some\n   * edge, but not actually present in the graph.\n   */hasNode(a){NodeAddress.assertValid(a);const result=this._nodes.has(a);this._maybeCheckInvariants();return result;}/**\n   * Returns the Node matching a given NodeAddressT, if such a node exists,\n   * or undefined otherwise.\n   */node(address){NodeAddress.assertValid(address);const result=this._nodes.get(address);this._maybeCheckInvariants();return result;}/**\n   * Returns an iterator over all of the nodes in the graph.\n   *\n   * Optionally, the caller can provide a node prefix. If\n   * provided, the iterator will only contain nodes matching that\n   * prefix. See semantics of [Address.hasPrefix][1] for details.\n   *\n   * Clients must not modify the graph during iteration. If they do so, an\n   * error may be thrown at the iteration call site.\n   *\n   * Nodes are yielded in address-sorted order.\n   *\n   * [1]: https://github.com/sourcecred/sourcecred/blob/7c7fa2d83d4fd5ba38efb2b2f4e0244235ac1312/src/core/address.js#L74\n   */nodes(options){const prefix=options!=null?options.prefix:NodeAddress.empty;if(prefix==null){throw new Error(\"Invalid prefix: \".concat(String(prefix)));}const result=this._nodesIterator(this._modificationCount,prefix);this._maybeCheckInvariants();return result;}*_nodesIterator(initialModificationCount,prefix){for(const address of this._getOrder().nodeOrder){if(NodeAddress.hasPrefix(address,prefix)){const node=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._nodes.get(address));this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();yield node;}}this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();}/**\n   * Add an edge to the graph.\n   *\n   * It is permitted to add an edge if its src or dst are not in the graph. See\n   * the discussion of 'Dangling Edges' in the module docstring for semantics.\n   *\n   * It is an error to add an edge if a distinct edge with the same address\n   * already exists in the graph (i.e., if the source or destination are\n   * different).\n   *\n   * Adding an edge that already exists to the graph is a no-op. (This\n   * operation is idempotent.)\n   *\n   * Returns `this` for chaining.\n   */addEdge(edge){NodeAddress.assertValid(edge.src,\"edge.src\");NodeAddress.assertValid(edge.dst,\"edge.dst\");EdgeAddress.assertValid(edge.address,\"edge.address\");this._reference(edge.src);this._reference(edge.dst);const existingEdge=this._edges.get(edge.address);if(existingEdge!=null){if(existingEdge.src!==edge.src||existingEdge.dst!==edge.dst||existingEdge.address!==edge.address||existingEdge.timestampMs!==edge.timestampMs){const strEdge=edgeToString(edge);const strExisting=edgeToString(existingEdge);throw new Error(\"conflict between new edge \".concat(strEdge,\" and existing \").concat(strExisting));}}else{this._edges.set(edge.address,edge);const{inEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(edge.dst));const{outEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(edge.src));inEdges.push(edge);outEdges.push(edge);}this._edges.set(edge.address,edge);this._markModification();this._maybeCheckInvariants();return this;}/**\n   * Remove an edge from the graph.\n   *\n   * Calling removeEdge on an address that does not correspond to any edge in\n   * the graph is a no-op. (This method is idempotent.)\n   *\n   * Returns `this` for chaining.\n   */removeEdge(address){EdgeAddress.assertValid(address);const edge=this._edges.get(address);if(edge!=null){this._edges.delete(address);const{inEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(edge.dst));const{outEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(edge.src));// TODO(perf): This is linear in the degree of the endpoints of the\n// edge. Consider storing in non-list form (e.g., `inEdges` and\n// `outEdges` fields in `_incidentEdges` could be `Set<EdgeAddressT>`).\n[inEdges,outEdges].forEach(edges=>{const index=edges.findIndex(edge=>edge.address===address);if(index===-1){const strAddress=EdgeAddress.toString(address);throw new Error(\"Invariant violation when removing edge@\".concat(strAddress));}edges.splice(index,1);});this._unreference(edge.src);this._unreference(edge.dst);}this._markModification();this._maybeCheckInvariants();return this;}/**\n   * Test whether the graph contains an edge with the given address.\n   */hasEdge(address){EdgeAddress.assertValid(address);const result=this._edges.has(address);this._maybeCheckInvariants();return result;}/**\n   * Test whether there is a dangling edge at the given address.\n   *\n   * Returns true if the edge is present, and is dangling.\n   * Returns false if the edge is present, and is not dangling.\n   * Returns undefined if the edge is not present.\n   *\n   * See the module docstring for more details on dangling edges.\n   */isDanglingEdge(address){EdgeAddress.assertValid(address);const edge=this.edge(address);let result;if(edge!=null){const{src,dst}=edge;result=!this.hasNode(src)||!this.hasNode(dst);}this._maybeCheckInvariants();return result;}/**\n   * Returns the Edge matching a given EdgeAddressT, if such an edge exists, or\n   * null otherwise.\n   */edge(address){EdgeAddress.assertValid(address);const result=this._edges.get(address);this._maybeCheckInvariants();return result;}/**\n   * Returns an iterator over edges in the graph, optionally filtered by edge\n   * address prefix, source address prefix, and/or destination address prefix.\n   *\n   * The caller must pass an options object with a boolean field `showDangling`,\n   * which determines whether dangling edges will be included in the results.\n   * The caller may also pass fields `addressPrefix`, `srcPrefix`, and `dstPrefix`\n   * to perform prefix-based address filtering of edges that are returned.\n   * (See the module docstring for more context on dangling edges.)\n   *\n   * Suppose that you want to find every edge that represents authorship by a\n   * user. If all authorship edges have the `AUTHORS_EDGE_PREFIX` prefix, and\n   * all user nodes have the `USER_NODE_PREFIX` prefix, then you could call:\n   *\n   * graph.edges({\n   *  showDangling: true,  // or false, irrelevant for this example\n   *  addressPrefix: AUTHORS_EDGE_PREFIX,\n   *  srcPrefix: USER_NODE_PREFIX,\n   * });\n   *\n   * In this example, as `dstPrefix` was left unset, it will default to\n   * `NodeAddress.empty`, which is a prefix of every node address.\n   *\n   * Clients must not modify the graph during iteration. If they do so, an\n   * error may be thrown at the iteration call site.\n   *\n   * The edges are yielded in sorted address order.\n   */edges(options){if(options==null){throw new Error(\"Options are required for Graph.edges\");}const{showDangling}=options;const addressPrefix=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"orElse\"](options.addressPrefix,EdgeAddress.empty);const srcPrefix=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"orElse\"](options.srcPrefix,NodeAddress.empty);const dstPrefix=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"orElse\"](options.dstPrefix,NodeAddress.empty);const result=this._edgesIterator(this._modificationCount,showDangling,addressPrefix,srcPrefix,dstPrefix);this._maybeCheckInvariants();return result;}*_edgesIterator(initialModificationCount,showDangling,addressPrefix,srcPrefix,dstPrefix){for(const address of this._getOrder().edgeOrder){const edge=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._edges.get(address));if((showDangling||this.isDanglingEdge(edge.address)===false)&&EdgeAddress.hasPrefix(edge.address,addressPrefix)&&NodeAddress.hasPrefix(edge.src,srcPrefix)&&NodeAddress.hasPrefix(edge.dst,dstPrefix)){this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();yield edge;}}this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();}/**\n   * Find the `Neighbors` that are incident to a chosen root node.\n   *\n   * A `Neighbor` contains an edge that is incident to the root,\n   * and the node at the other endpoint of the edge. This may be\n   * either the source or destination of the edge, depending on whether the\n   * edge is an in-edge or an out-edge from the perspective of the root. For\n   * convenience, a `Neighbor` is thus an object that includes both the edge\n   * and the adjacent node.\n   *\n   * Every non-dangling edge incident to the root corresponds to exactly one\n   * neighbor, but note that multiple neighbors may have the same `node` in the\n   * case that there are multiple edges with the same source and destination.\n   *\n   * Callers to `neighbors` must provide `NeighborsOptions` as follows:\n   *\n   * - direction: one of Direction.IN, direction.OUT, or Direction.ANY.\n   *   - Direction.IN finds neigbhors where root is the destination of the\n   *     edge.\n   *   - Direction.OUT finds neigbhors where root is the source of the edge.\n   *   - Direction.ANY finds neigbhors where root is the source or destination\n   *     of the edge.\n   *\n   * - nodePrefix: A NodeAddressT to use as a prefix filter for the adjacent node.\n   *   If you want all nodes, use `NodeAddress`.empty.\n   *\n   * - edgePrefix: An EdgeAddressT to use as a prefix filter for the edge.\n   *   If you want all edges, use `EdgeAddress`.empty.\n   *\n   * Calling `neighbors` on a node that is not present in the graph is an error.\n   *\n   * If the root node has an edge for which it is both the source and the\n   * destination (a loop edge), there will be one `Neighbor` with the root node\n   * and the loop edge.\n   *\n   * No `Neighbors` will be created for dangling edges, as such edges do not\n   * correspond to any Node in the graph.\n   *\n   * Clients must not modify the graph during iteration. If they do so, an\n   * error may be thrown at the iteration call site. The iteration order is\n   * undefined.\n   */neighbors(node,options){if(!this.hasNode(node)){throw new Error(\"Node does not exist: \".concat(NodeAddress.toString(node)));}const result=this._neighbors(node,options,this._modificationCount);this._maybeCheckInvariants();return result;}*_neighbors(node,options,initialModificationCount){const nodeFilter=n=>NodeAddress.hasPrefix(n,options.nodePrefix);const edgeFilter=e=>EdgeAddress.hasPrefix(e,options.edgePrefix);const direction=options.direction;const adjacencies=[];if(direction===Direction.IN||direction===Direction.ANY){const{inEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(node));adjacencies.push({edges:inEdges,direction:\"IN\"});}if(direction===Direction.OUT||direction===Direction.ANY){const{outEdges}=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](this._incidentEdges.get(node));adjacencies.push({edges:outEdges,direction:\"OUT\"});}for(const adjacency of adjacencies){for(const edge of adjacency.edges){if(direction===Direction.ANY&&adjacency.direction===\"IN\"){if(edge.src===edge.dst){continue;// don't yield loop edges twice.\n}}const neighborNodeAddress=adjacency.direction===\"IN\"?edge.src:edge.dst;const neighborNode=this.node(neighborNodeAddress);if(nodeFilter(neighborNodeAddress)&&edgeFilter(edge.address)&&neighborNode!=null){this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();yield{edge,node:neighborNode};}}}this._checkForComodification(initialModificationCount);this._maybeCheckInvariants();}/**\n   * Checks whether this graph is equal to another graph.\n   *\n   * Two Graphs are considered equal if they have identical sets of nodes\n   * and edges. Insertion order is irrelevant.\n   *\n   * Runs in time `O(n + e)`, where `n` is the number of nodes and `e` is the\n   * number of edges.\n   */equals(that){if(!(that instanceof Graph)){throw new Error(\"Expected Graph, got \".concat(String(that)));}const result=lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(this._nodes,that._nodes)&&lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(this._edges,that._edges);this._maybeCheckInvariants();return result;}/**\n   * Produce a copy of this graph.\n   *\n   * The copy is equal to the original, but distinct, so that they may be\n   * modified independently.\n   */copy(){const result=Graph.merge([this]);this._maybeCheckInvariants();return result;}/**\n   * Serialize a Graph into a plain JavaScript object.\n   */toJSON(){// Unlike Array.from(this.nodes()).map((x) => x.address), this will include\n// node references. Including node references is necessary so that we can\n// index edges' src and dst consistently, even for dangling edges.\nconst sortedNodeAddresses=Array.from(this._incidentEdges.keys()).sort();const nodeAddressToSortedIndex=new Map();sortedNodeAddresses.forEach((address,i)=>{nodeAddressToSortedIndex.set(address,i);});const sortedEdges=Array.from(this.edges({showDangling:true}));const indexedEdges=sortedEdges.map(_ref=>{let{src,dst,address,timestampMs}=_ref;const srcIndex=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](nodeAddressToSortedIndex.get(src));const dstIndex=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](nodeAddressToSortedIndex.get(dst));return{srcIndex,dstIndex,address:EdgeAddress.toParts(address),timestampMs};});const sortedNodes=Array.from(this.nodes());const indexedNodes=sortedNodes.map(_ref2=>{let{address,description,timestampMs}=_ref2;const index=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](nodeAddressToSortedIndex.get(address));return{index,description,timestampMs};});const rawJSON={sortedNodeAddresses:sortedNodeAddresses.map(x=>NodeAddress.toParts(x)),edges:indexedEdges,nodes:indexedNodes};const result=Object(_util_compat__WEBPACK_IMPORTED_MODULE_3__[\"toCompat\"])(COMPAT_INFO,rawJSON);this._maybeCheckInvariants();return result;}/**\n   * Deserializes a GraphJSON into a new Graph.\n   */static fromJSON(compatJson){const{nodes:nodesJSON,edges:edgesJSON,sortedNodeAddresses:sortedNodeAddressesJSON}=Object(_util_compat__WEBPACK_IMPORTED_MODULE_3__[\"fromCompat\"])(COMPAT_INFO,compatJson);const sortedNodeAddresses=sortedNodeAddressesJSON.map(NodeAddress.fromParts);const result=new Graph();nodesJSON.forEach(j=>{const n={address:sortedNodeAddresses[j.index],description:j.description,timestampMs:j.timestampMs};result.addNode(n);});edgesJSON.forEach(_ref3=>{let{address,srcIndex,dstIndex,timestampMs}=_ref3;const src=sortedNodeAddresses[srcIndex];const dst=sortedNodeAddresses[dstIndex];result.addEdge({address:EdgeAddress.fromParts(address),src:src,dst:dst,timestampMs});});return result;}/**\n   * Compute the union of the given graphs. The result is a new graph that has\n   * all of the nodes and all of the edges from all the provided graphs.\n   *\n   * If two of the given graphs have edges with the same address, the edges\n   * must be equal (i.e. must have the same source and destination in each\n   * graph). If this is not the case, an error will be thrown.\n   *\n   * Example usage:\n   *\n   * const g1 = new Graph().addNode(a).addNode(b).addEdge(e);\n   * const g2 = new Graph().addNode(b).addNode(c).addEdge(f);\n   * const g3 = Graph.merge([g1, g2]);\n   * Array.from(g3.nodes()).length;  // 3\n   * Array.from(g3.edges()).length;  // 2\n   * const g1 = new Graph().addNode(a).addNode(b).addEdge(x);\n   * const g2 = new Graph().addNode(c);\n   * const g3 = Graph.merge([g1, g2]);\n   *\n   * The newly created graph is a separate instance from any of the input graphs,\n   * and may be mutated independently.\n   */static merge(graphs){const result=new Graph();for(const graph of graphs){for(const node of graph.nodes()){result.addNode(node);}for(const edge of graph.edges({showDangling:true})){result.addEdge(edge);}}return result;}/**\n   * Create a new graph, in which some nodes have been contracted together.\n   *\n   * contractNodes takes a list of NodeContractions, each of which specifies a\n   * replacement node, and a list of old node addresses to map onto the new\n   * node. A new graph will be returned where the new node is added, none of\n   * the old nodes are present, and every edge incident to one of the old nodes\n   * has been re-written so that it is incident to the new node instead.\n   *\n   * If the same node addresses is \"old\" for several contractions, all incident\n   * edges will be re-written to connect to whichever contraction came last.\n   *\n   * If the replacement node is present in the graph, no error will be thrown,\n   * provided that the replacement node is consistent with the one in the graph.\n   *\n   * If there is a \"chain\" of remaps (i.e. a->b and b->c), then an error will\n   * be thrown, as support for chaining has not yet been implemented.\n   *\n   * The original Graph is not mutated.\n   *\n   * contractNodes runs in O(n+e+k), where `n` is the number of nodes, `e` is the\n   * number of edges, and `k` is the number of contractions. If needed, we can\n   * improve the peformance by mutating the original graph instead of creating\n   * a new one.\n   */contractNodes(contractions){const remap=new Map();const replacements=new Set();const contracted=new Graph();for(const{old,replacement}of contractions){for(const addr of old){if(replacements.has(addr)){throw new Error(\"Chained contractions are not supported: \".concat(NodeAddress.toString(addr)));}remap.set(addr,replacement.address);}replacements.add(replacement.address);contracted.addNode(replacement);}for(const node of this.nodes()){if(!remap.has(node.address)){contracted.addNode(node);}}for(const edge of this.edges({showDangling:true})){const src=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"orElse\"](remap.get(edge.src),edge.src);const dst=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"orElse\"](remap.get(edge.dst),edge.dst);const newEdge=_objectSpread(_objectSpread({},edge),{},{src,dst});contracted.addEdge(newEdge);}return contracted;}checkInvariants(){if(this._invariantsLastChecked.when!==this._modificationCount){let failure=null;try{this._checkInvariants();}catch(e){failure=e.message;}finally{this._invariantsLastChecked={when:this._modificationCount,failure};}}if(this._invariantsLastChecked.failure!=null){throw new Error(this._invariantsLastChecked.failure);}}_checkInvariants(){// Definition. A node `n` is in the graph if `n` is deep-equal to\n// `_nodes.get(n.address)`.\n//\n// Definition. An edge `e` is in the graph if `e` is deep-equal to\n// `_edges.get(e.address)`.\n//\n// Definition. A *logical value* is an equivalence class of ECMAScript\n// values modulo deep equality (or, from context, an element of such a\n// class).\n// Invariant 1. A node address `na` is 'referenced' if `_incidentEdges.has(na)`.\n// 1.1 If a node is in the graph, then it is referenced by its address.\n// 1.2 If a node has any incident edge, then it is referenced.\n// 1.3 If a node is not in the graph and does not have incident edges, then\n// it is not referenced.\nconst referencedNodesEncountered=new Set();// 1.1\nfor(const[address,node]of this._nodes){if(node.address!==address){throw new Error(\"bad node address for \".concat(NodeAddress.toString(address)));}if(!this._incidentEdges.has(address)){throw new Error(\"missing incident-edges for \".concat(NodeAddress.toString(address)));}referencedNodesEncountered.add(address);}// 1.2\nfor(const edge of this._edges.values()){if(!this._incidentEdges.has(edge.src)){throw new Error(\"missing incident-edges for src of: \".concat(edgeToString(edge)));}referencedNodesEncountered.add(edge.src);if(!this._incidentEdges.has(edge.dst)){throw new Error(\"missing incident-edges for dst of: \".concat(edgeToString(edge)));}referencedNodesEncountered.add(edge.dst);}// Check 1.3 by implication: for every address in\n// referencedNodesEncountered, we've explicitly checked that it is present\n// in _incidentEdges.\n//\n// Therefore, if the number of keys in _incidentEdges differs from the\n// number of elements in referencedNodesEncountered, it must be because\n// some elements in _incidentEdges were not present in\n// referencedNodesEncountered, which means that they did not correspond to\n// a node in the graph and did not have incident edges.\nconst numIncidentEntries=Array.from(this._incidentEdges.keys()).length;if(numIncidentEntries!==referencedNodesEncountered.size){throw new Error(\"extra addresses in incident-edges\");}// Invariant 2. For an edge address `a`, if `_edges.has(a)` and\n// `_edges.get(a) === e`, then:\n//  1. `e.address` equals `a`;\n//  2. `e.src` is referenced;\n//  3. `e.dst` is referenced;\n//  4. `_incidentEdges.get(e.dst).inEdges` contains `e`; and\n//  5. `_incidentEdges.get(e.src).outEdges` contains `e`.\n//\n// 2.2 and 2.3 are implied by 2.4 and 2.5 respectively (as a node's address\n// being available in _incidentEdges means that it is referenced). So we may\n// ignore them.\n//\n// We check 2.1 here, and check 2.4 and 2.5 later for improved performance.\nfor(const[address,edge]of this._edges.entries()){if(edge.address!==address){throw new Error(\"bad edge address: \".concat(edgeToString(edge),\" does not match \").concat(address));}}// Invariant 3. Suppose that `_incidentEdges.has(n)` and, let `es` be\n// `_incidentEdges.get(n).inEdges`. Then\n//  1. `es` contains any logical value at most once;\n//  2. if `es` contains `e`, then `e` is in the graph; and\n//  3. if `es` contains `e`, then `e.dst === n`.\n//\n// Invariant 4. Suppose that `_incidentEdges.has(n)` and, let `es` be\n// `_incidentEdges.get(n).outEdges`. Then\n//  1. `es` contains any logical value at most once;\n//  2. if `es` contains `e`, then `e` is in the graph; and\n//  3. if `es` contains `e`, then `e.src === n`.\n//\n// Note that Invariant 3.1 is equivalent to the following:\n//\n//     Invariant 3.1*. If `a` is an address, then there is at most\n//     one index `i` such that `es[i].address` is `a`.\n//\n// It is immediate that 3.1* implies 3.1. To see that 3.1 implies\n// 3.1*, suppose that `i` and `j` are such that `es[i].address` and\n// `es[j].address` are both `a`. Then, by Invariant 3.2, each of\n// `es[i]` and `es[j]` is in the graph, so each is deep-equal to\n// `_edges.get(a)`. Therefore, `es[i]` and `es[j]` are deep-equal to\n// each other. By 3.1, `es` contains a logical value at most once,\n// so `i` must be equal to `j`.\n//\n// Therefore, it is valid to verify that 3.1*, which we will do. The\n// same logic of course applies to Invariant 4.1.\nconst inEdgesSeen=new Set();const outEdgesSeen=new Set();const incidentEntries=Array.from(this._incidentEdges.entries());for(const{seen,entries,baseNodeAccessor,kind}of[{seen:inEdgesSeen,entries:incidentEntries.map(_ref4=>{let[a,{inEdges}]=_ref4;return[a,inEdges];}),baseNodeAccessor:e=>e.dst,kind:\"in-edge\"},{seen:outEdgesSeen,entries:incidentEntries.map(_ref5=>{let[a,{outEdges}]=_ref5;return[a,outEdges];}),baseNodeAccessor:e=>e.src,kind:\"out-edge\"}]){for(const[base,edges]of entries){for(const edge of edges){// 3.1/4.1\nif(seen.has(edge.address)){throw new Error(\"duplicate \".concat(kind,\": \").concat(edgeToString(edge)));}seen.add(edge.address);const expected=this._edges.get(edge.address);// 3.2/4.2\nif(!lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(edge,expected)){if(expected==null){throw new Error(\"spurious \".concat(kind,\": \").concat(edgeToString(edge)));}else{const vs=\"\".concat(edgeToString(edge),\" vs. \").concat(edgeToString(expected));throw new Error(\"bad \".concat(kind,\": \").concat(vs));}}// 3.3/4.3\nconst expectedBase=baseNodeAccessor(edge);if(base!==baseNodeAccessor(edge)){throw new Error(\"bad \".concat(kind,\": \").concat(edgeToString(edge),\" should be \")+\"should be anchored at \".concat(NodeAddress.toString(expectedBase)));}}}}// We now return to check 2.4 and 2.5, with the help of the\n// structures that we have built up in checking Invariants 3 and 4.\nfor(const edge of this._edges.values()){// That `_incidentEdges.get(n).inEdges` contains `e` for some `n` is\n// sufficient to show that `_incidentEdges.get(e.dst).inEdges` contains\n// `e`: if `n` were something other than `e.dst`, then we would have a\n// failure of invariant 3.3, which would have been caught earlier.\n// Likewise for outEdges.\nif(!inEdgesSeen.has(edge.address)){throw new Error(\"missing in-edge: \".concat(edgeToString(edge)));}if(!outEdgesSeen.has(edge.address)){throw new Error(\"missing out-edge: \".concat(edgeToString(edge)));}}}_maybeCheckInvariants(){if(false){}}}/**\n * Convert a node into a human readable string.\n *\n * The precise behavior is an implementation detail and subject to change.\n */function nodeToString(node){const address=NodeAddress.toString(node.address);const timestamp=node.timestampMs==null?\"null\":String(node.timestampMs);return\"{address: \".concat(address,\", description: \").concat(node.description,\", timestampMs: \").concat(timestamp,\"}\");}/**\n * Convert an edge into a human readable string.\n *\n * The precise behavior is an implementation detail and subject to change.\n */function edgeToString(edge){const address=EdgeAddress.toString(edge.address);const src=NodeAddress.toString(edge.src);const dst=NodeAddress.toString(edge.dst);return\"{address: \".concat(address,\", src: \").concat(src,\", dst: \").concat(dst,\", timestampMs: \").concat(edge.timestampMs,\"}\");}/**\n * Convert an edge to an object whose fields are human-readable.\n * This is useful for storing edges in human-readable formats that\n * should not include NUL characters, such as Jest snapshots.\n */function edgeToStrings(edge){return{address:EdgeAddress.toString(edge.address),src:NodeAddress.toString(edge.src),dst:NodeAddress.toString(edge.dst),timestampMs:edge.timestampMs};}function edgeToParts(edge){const addressParts=EdgeAddress.toParts(edge.address);const srcParts=NodeAddress.toParts(edge.src);const dstParts=NodeAddress.toParts(edge.dst);const timestampMs=edge.timestampMs;return{addressParts,srcParts,dstParts,timestampMs};}function compareGraphs(firstGraph,secondGraph){const nodeDiffs=[];const edgeDiffs=[];const graphsAreEqual=firstGraph.equals(secondGraph);if(!graphsAreEqual){for(const firstNode of firstGraph.nodes()){const secondNode=secondGraph.node(firstNode.address);if(!lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(firstNode,secondNode))nodeDiffs.push({first:firstNode,second:secondNode});}for(const secondNode of secondGraph.nodes()){const firstNode=firstGraph.node(secondNode.address);if(!firstNode){nodeDiffs.push({first:firstNode,second:secondNode});}}for(const firstEdge of firstGraph.edges({showDangling:true})){const secondEdge=secondGraph.edge(firstEdge.address);if(!lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(firstEdge,secondEdge))edgeDiffs.push({first:firstEdge,second:secondEdge});}for(const secondEdge of secondGraph.edges({showDangling:true})){const firstEdge=firstGraph.edge(secondEdge.address);if(!firstEdge){edgeDiffs.push({first:firstEdge,second:secondEdge});}}}return{graphsAreEqual,nodeDiffs,edgeDiffs};}\n\n//# sourceURL=webpack:///./src/core/graph.js?");

/***/ }),

/***/ "./src/core/identity/alias.js":
/*!************************************!*\
  !*** ./src/core/identity/alias.js ***!
  \************************************/
/*! exports provided: parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/**\n * An Alias is basically another graph Node which resolves to this identity. We\n * ignore the timestamp because it's generally not significant for users; we\n * keep the address out of obvious necessity, and we keep the description so we\n * can describe this alias in UIs (e.g. the ledger admin panel).\n */const parser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({address:_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].parser,description:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"]});\n\n//# sourceURL=webpack:///./src/core/identity/alias.js?");

/***/ }),

/***/ "./src/core/identity/id.js":
/*!*********************************!*\
  !*** ./src/core/identity/id.js ***!
  \*********************************/
/*! exports provided: identityIdParser, delimitedIdentityIdParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identityIdParser\", function() { return identityIdParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"delimitedIdentityIdParser\", function() { return delimitedIdentityIdParser; });\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/uuid */ \"./src/util/uuid.js\");\nconst identityIdParser=_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"parser\"];const delimitedIdentityIdParser=_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"delimitedUuidParser\"];\n\n//# sourceURL=webpack:///./src/core/identity/id.js?");

/***/ }),

/***/ "./src/core/identity/identity.js":
/*!***************************************!*\
  !*** ./src/core/identity/identity.js ***!
  \***************************************/
/*! exports provided: IDENTITY_PREFIX, newIdentity, graphNode, contractions, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IDENTITY_PREFIX\", function() { return IDENTITY_PREFIX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"newIdentity\", function() { return newIdentity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"graphNode\", function() { return graphNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contractions\", function() { return contractions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/uuid */ \"./src/util/uuid.js\");\n/* harmony import */ var _name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./name */ \"./src/core/identity/name.js\");\n/* harmony import */ var _alias__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./alias */ \"./src/core/identity/alias.js\");\n/* harmony import */ var _identityType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./identityType */ \"./src/core/identity/identityType.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n// It's not in the typical [owner, name] format because it isn't provided by a plugin.\n// Instead, it's a raw type owned by SourceCred project.\nconst IDENTITY_PREFIX=_core_graph__WEBPACK_IMPORTED_MODULE_5__[\"NodeAddress\"].fromParts([\"sourcecred\",\"core\",\"IDENTITY\"]);function newIdentity(subtype,name){const id=Object(_util_uuid__WEBPACK_IMPORTED_MODULE_1__[\"random\"])();try{_identityType__WEBPACK_IMPORTED_MODULE_4__[\"parser\"].parseOrThrow(subtype);}catch(e){throw new Error(\"invalid identity subtype: \".concat(subtype));}return{id,subtype,address:_core_graph__WEBPACK_IMPORTED_MODULE_5__[\"NodeAddress\"].append(IDENTITY_PREFIX,id),name:Object(_name__WEBPACK_IMPORTED_MODULE_2__[\"nameFromString\"])(name),aliases:[]};}function graphNode(_ref){let{name,address}=_ref;return{address,description:name,timestampMs:null};}function contractions(identities){return identities.map(i=>({replacement:graphNode(i),old:i.aliases.map(a=>a.address)}));}const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({id:_util_uuid__WEBPACK_IMPORTED_MODULE_1__[\"parser\"],subtype:_identityType__WEBPACK_IMPORTED_MODULE_4__[\"parser\"],name:_name__WEBPACK_IMPORTED_MODULE_2__[\"parser\"],address:_core_graph__WEBPACK_IMPORTED_MODULE_5__[\"NodeAddress\"].parser,aliases:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](_alias__WEBPACK_IMPORTED_MODULE_3__[\"parser\"])});\n\n//# sourceURL=webpack:///./src/core/identity/identity.js?");

/***/ }),

/***/ "./src/core/identity/identityType.js":
/*!*******************************************!*\
  !*** ./src/core/identity/identityType.js ***!
  \*******************************************/
/*! exports provided: IdentityTypes, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IdentityTypes\", function() { return IdentityTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_1__);\nconst ValidIdentityTypes={USER:\"USER\",PROJECT:\"PROJECT\",ORGANIZATION:\"ORGANIZATION\",BOT:\"BOT\"};// export a read-only version of the ValidIdentityTypes object for programmatic reference\nconst IdentityTypes=deep_freeze__WEBPACK_IMPORTED_MODULE_1___default()(ValidIdentityTypes);const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"exactly\"](Object.keys(IdentityTypes));\n\n//# sourceURL=webpack:///./src/core/identity/identityType.js?");

/***/ }),

/***/ "./src/core/identity/index.js":
/*!************************************!*\
  !*** ./src/core/identity/index.js ***!
  \************************************/
/*! exports provided: identityIdParser, delimitedIdentityIdParser, newIdentity, contractions, graphNode, identityParser, IDENTITY_PREFIX, identityTypeParser, nameFromString, nameParser, aliasParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id */ \"./src/core/identity/id.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"identityIdParser\", function() { return _id__WEBPACK_IMPORTED_MODULE_0__[\"identityIdParser\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"delimitedIdentityIdParser\", function() { return _id__WEBPACK_IMPORTED_MODULE_0__[\"delimitedIdentityIdParser\"]; });\n\n/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity */ \"./src/core/identity/identity.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"newIdentity\", function() { return _identity__WEBPACK_IMPORTED_MODULE_1__[\"newIdentity\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"contractions\", function() { return _identity__WEBPACK_IMPORTED_MODULE_1__[\"contractions\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"graphNode\", function() { return _identity__WEBPACK_IMPORTED_MODULE_1__[\"graphNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"identityParser\", function() { return _identity__WEBPACK_IMPORTED_MODULE_1__[\"parser\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"IDENTITY_PREFIX\", function() { return _identity__WEBPACK_IMPORTED_MODULE_1__[\"IDENTITY_PREFIX\"]; });\n\n/* harmony import */ var _identityType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identityType */ \"./src/core/identity/identityType.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"identityTypeParser\", function() { return _identityType__WEBPACK_IMPORTED_MODULE_2__[\"parser\"]; });\n\n/* harmony import */ var _name__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./name */ \"./src/core/identity/name.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"nameFromString\", function() { return _name__WEBPACK_IMPORTED_MODULE_3__[\"nameFromString\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"nameParser\", function() { return _name__WEBPACK_IMPORTED_MODULE_3__[\"parser\"]; });\n\n/* harmony import */ var _alias__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./alias */ \"./src/core/identity/alias.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"aliasParser\", function() { return _alias__WEBPACK_IMPORTED_MODULE_4__[\"parser\"]; });\n\n\n\n//# sourceURL=webpack:///./src/core/identity/index.js?");

/***/ }),

/***/ "./src/core/identity/name.js":
/*!***********************************!*\
  !*** ./src/core/identity/name.js ***!
  \***********************************/
/*! exports provided: nameFromString, coerce, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nameFromString\", function() { return nameFromString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"coerce\", function() { return coerce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/**\n * A Name is an identity name which has the following properties:\n * - It consists of alphanumeric ASCII and of dashes, which makes it suitable\n *   for including in urls (so we can give each contributor a hardcoded URL\n *   showing their contributions, Cred, and Grain).\n * - It is unique within an instance. Also, no two identities may have names that both\n *   have the same lowercase representation.\n * - It's chosen by (and changeable by) the owner of the identity.\n */const NAME_PATTERN=/^[A-Za-z0-9-]+$/;// Based on the length of an Ethereum address (with '0x' prefix)\nconst MAXIMUM_NAME_LENGTH=42;/**\n * Parse a Name from a string.\n *\n * Throws an error if the Name is invalid.\n */function nameFromString(name){if(!name.match(NAME_PATTERN)){throw new Error(\"invalid name: \".concat(name));}if(name.length>MAXIMUM_NAME_LENGTH){throw new Error(\"name too long: \".concat(name));}return name;}const COERCE_PATTERN=/[^A-Za-z0-9-]/g;/**\n * Attempt to coerce a string into a valid name, by replacing invalid\n * characters like `_` or `#` with hyphens.\n *\n * This can still error, if given a very long string or the empty string, it\n * will fail rather than try to change the name length.\n */function coerce(name){const coerced=name.replace(COERCE_PATTERN,\"-\");return nameFromString(coerced);}const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],nameFromString);\n\n//# sourceURL=webpack:///./src/core/identity/name.js?");

/***/ }),

/***/ "./src/core/interval.js":
/*!******************************!*\
  !*** ./src/core/interval.js ***!
  \******************************/
/*! exports provided: intervalSequence, intervalSequenceParser, partitionGraph, graphIntervals, weekIntervals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intervalSequence\", function() { return intervalSequence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intervalSequenceParser\", function() { return intervalSequenceParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partitionGraph\", function() { return partitionGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"graphIntervals\", function() { return graphIntervals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"weekIntervals\", function() { return weekIntervals; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_sortBy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/sortBy */ \"./src/util/sortBy.js\");\n/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ \"d3-time\");\n/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(d3_time__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/**\n * Represents a time interval\n * The interval is half open [startTimeMs, endTimeMs),\n * i.e. if a timestamp is exactly on the interval boundary, it will fall at the\n * start of the older interval.\n */function intervalSequence(intervals){let lastEndTime=null;for(const{startTimeMs,endTimeMs}of intervals){if(isNaN(startTimeMs)||isNaN(endTimeMs)){throw new Error(\"NaN in interval [\".concat(startTimeMs,\", \").concat(endTimeMs,\"]\"));}if(lastEndTime!=null&&startTimeMs!==lastEndTime){throw new Error(\"last interval ended at \".concat(lastEndTime,\" but this interval starts at \").concat(startTimeMs));}if(endTimeMs<=startTimeMs){throw new Error(\"interval must have positive length, but got [\".concat(startTimeMs,\", \").concat(endTimeMs,\"]\"));}lastEndTime=endTimeMs;}// Reconstruct the objects so mutating the input won't break the IntervalSequence\nreturn intervals.map(_ref=>{let{startTimeMs,endTimeMs}=_ref;return{startTimeMs,endTimeMs};});}const intervalSequenceParser=_util_combo__WEBPACK_IMPORTED_MODULE_4__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_4__[\"object\"]({startTimeMs:_util_combo__WEBPACK_IMPORTED_MODULE_4__[\"number\"],endTimeMs:_util_combo__WEBPACK_IMPORTED_MODULE_4__[\"number\"]})).fmap(arr=>intervalSequence(arr));/**\n * Represents a slice of a time-partitioned graph\n * Includes the interval, as well as all of the nodes and edges whose timestamps\n * are within the interval.\n */ /**\n * Partition a graph based on time intervals.\n *\n * The intervals are always one week long, as calculated using d3.utcWeek.\n * The result may contain empty intervals.\n * If the graph is empty, no intervals are returned.\n * Timeless nodes are not included in the partition, nor are dangling edges.\n */function partitionGraph(graph){const nodes=Array.from(graph.nodes());const timefulNodes=nodes.filter(x=>x.timestampMs!=null);const sortedNodes=Object(_util_sortBy__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(timefulNodes,x=>x.timestampMs);const edges=Array.from(graph.edges({showDangling:false}));const sortedEdges=Object(_util_sortBy__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(edges,x=>x.timestampMs);const intervals=graphIntervals(graph);let nodeIndex=0;let edgeIndex=0;return intervals.map(interval=>{const nodes=[];const edges=[];while(nodeIndex<sortedNodes.length&&sortedNodes[nodeIndex].timestampMs<interval.endTimeMs){nodes.push(sortedNodes[nodeIndex++]);}while(edgeIndex<sortedEdges.length&&sortedEdges[edgeIndex].timestampMs<interval.endTimeMs){edges.push(sortedEdges[edgeIndex++]);}return{interval,nodes,edges};});}/**\n * Produce an array of Intervals which cover all the node and edge timestamps\n * for a graph.\n *\n * The intervals are one week long, and are aligned on clean week boundaries.\n *\n * This function is basically a wrapper around weekIntervals that makes sure\n * the graph's nodes and edges are all accounted for properly.\n */function graphIntervals(graph){const nodeTimestamps=Array.from(graph.nodes()).map(x=>x.timestampMs).filter(x=>x!=null)// Unnecessary map is to satisfy flow that the array doesn't contain null.\n.map(x=>_util_null__WEBPACK_IMPORTED_MODULE_3__[\"get\"](x));const edgeTimestamps=Array.from(graph.edges({showDangling:false})).map(x=>x.timestampMs);if(nodeTimestamps.length===0&&edgeTimestamps.length===0){return[];}const allTimestamps=nodeTimestamps.concat(edgeTimestamps);const start=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"min\"])(allTimestamps);const end=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"max\"])(allTimestamps);return weekIntervals(start,end);}/**\n * Produce an array of week-long intervals to cover the startTime and endTime.\n *\n * Each interval is one week long and aligned on week boundaries, as produced\n * by d3.utcWeek. The weeks always use UTC boundaries to ensure consistent\n * output regardless of which timezone the user is in.\n *\n * Assuming that the inputs are valid, there will always be at least one\n * interval, so that that interval can cover the input timestamps. (E.g. if\n * startMs and endMs are the same value, then the produced interval will be the\n * start and end of the last week that starts on or before startMs.)\n */function weekIntervals(startMs,endMs){if(!isFinite(startMs)||!isFinite(endMs)){throw new Error(\"invalid non-finite input\");}if(typeof startMs!==\"number\"||typeof endMs!==\"number\"){throw new Error(\"start or end are not numbers\");}if(startMs>endMs){throw new Error(\"start time after end time\");}// Promote the window to the nearest week boundaries, to ensure that\n// utcWeek.range will not return an empty array.\n// We add one to the endTime so that just in case we're exactly on a week\n// boundary, we still get at least one interval.\nstartMs=d3_time__WEBPACK_IMPORTED_MODULE_2__[\"utcWeek\"].floor(startMs);endMs=d3_time__WEBPACK_IMPORTED_MODULE_2__[\"utcWeek\"].ceil(endMs+1);const boundaries=d3_time__WEBPACK_IMPORTED_MODULE_2__[\"utcWeek\"].range(startMs,endMs);boundaries.push(endMs);const intervals=[];for(let i=0;i<boundaries.length-1;i++){intervals.push({startTimeMs:+boundaries[i],endTimeMs:+boundaries[i+1]});}return intervalSequence(intervals);}\n\n//# sourceURL=webpack:///./src/core/interval.js?");

/***/ }),

/***/ "./src/core/ledger/applyDistributions.js":
/*!***********************************************!*\
  !*** ./src/core/ledger/applyDistributions.js ***!
  \***********************************************/
/*! exports provided: applyDistributions, _chooseDistributionIntervals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyDistributions\", function() { return applyDistributions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_chooseDistributionIntervals\", function() { return _chooseDistributionIntervals; });\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../interval */ \"./src/core/interval.js\");\n/* harmony import */ var _ledger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _credrank_credGraph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../credrank/credGraph */ \"./src/core/credrank/credGraph.js\");\n/* harmony import */ var _computeDistribution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./computeDistribution */ \"./src/core/ledger/computeDistribution.js\");\n/* harmony import */ var _credGrainView__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../credGrainView */ \"./src/core/credGrainView.js\");\n/**\n * Iteratively compute and distribute Grain, based on the provided CredGraph,\n * into the provided Ledger, according to the specified DistributionPolicy.\n *\n * Here are some examples of how it works:\n *\n * - The last time there was a distribution was two days ago. Since then,\n *   no new Cred Intervals have been completed. This method will no-op.\n *\n * - The last time there was a distribution was last week. Since then, one new\n *   Cred Interval has been completed. The method will apply one Distribution.\n *\n * - The last time there was a distribution was a month ago. Since then, four\n *   Cred Intervals have been completed. The method will apply four Distributions,\n *   unless maxOldDistributions is set to a lower number (e.g. 2), in which case\n *   that maximum number of distributions will be applied.\n *\n * It returns the list of applied distributions, which may be helpful for\n * diagnostics, printing a summary, etc.\n */function applyDistributions(config,credGraph,ledger,currentTimestamp,allowMultipleDistributionsPerInterval){const credIntervals=credGraph.intervals();const distributionIntervals=_chooseDistributionIntervals(credIntervals,_util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](ledger.lastDistributionTimestamp(),-Infinity),currentTimestamp,config.maxSimultaneousDistributions,allowMultipleDistributionsPerInterval);return distributionIntervals.map(interval=>{// Recompute for every endpoint because the Ledger will be in a different state\n// (wrt paid balances)\nconst credGrainView=_credGrainView__WEBPACK_IMPORTED_MODULE_5__[\"CredGrainView\"].fromCredGraphAndLedger(credGraph,ledger);const distribution=Object(_computeDistribution__WEBPACK_IMPORTED_MODULE_4__[\"computeDistribution\"])(config.allocationPolicies,credGrainView,interval.endTimeMs);ledger.distributeGrain(distribution);return distribution;});}function _chooseDistributionIntervals(credIntervals,lastDistributionTimestamp,currentTimestamp,maxSimultaneousDistributions,allowMultipleDistributionsPerInterval){// Slice off the final interval--we may assume that it is not yet finished.\nconst completeIntervals=credIntervals.filter(x=>x.endTimeMs<=currentTimestamp);const undistributedIntervals=completeIntervals.filter(i=>i.endTimeMs>lastDistributionTimestamp);const sequence=undistributedIntervals.slice(undistributedIntervals.length-maxSimultaneousDistributions,undistributedIntervals.length);if(allowMultipleDistributionsPerInterval&&!sequence.length)return Object(_interval__WEBPACK_IMPORTED_MODULE_1__[\"intervalSequence\"])(completeIntervals.slice(completeIntervals.length-1));return Object(_interval__WEBPACK_IMPORTED_MODULE_1__[\"intervalSequence\"])(sequence);}\n\n//# sourceURL=webpack:///./src/core/ledger/applyDistributions.js?");

/***/ }),

/***/ "./src/core/ledger/computeDistribution.js":
/*!************************************************!*\
  !*** ./src/core/ledger/computeDistribution.js ***!
  \************************************************/
/*! exports provided: computeDistribution */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeDistribution\", function() { return computeDistribution; });\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/uuid */ \"./src/util/uuid.js\");\n/* harmony import */ var _grainAllocation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grainAllocation */ \"./src/core/ledger/grainAllocation.js\");\n/**\n * Compute a single Distribution using CredAccountData.\n *\n * The distribution will include the provided policies.\n * It will be computed using only Cred intervals that are finished as of the\n * effectiveTimestamp.\n *\n * Note: This method is untested as it is just a bit of plubming; flow gives me\n * confidence that the semantics are correct.\n **/function computeDistribution(policies,credGrainView,effectiveTimestamp){const allocations=policies.map(p=>Object(_grainAllocation__WEBPACK_IMPORTED_MODULE_1__[\"computeAllocation\"])(p,credGrainView,effectiveTimestamp));const distribution={id:_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"random\"](),allocations,credTimestamp:effectiveTimestamp};return distribution;}\n\n//# sourceURL=webpack:///./src/core/ledger/computeDistribution.js?");

/***/ }),

/***/ "./src/core/ledger/credAccounts.js":
/*!*****************************************!*\
  !*** ./src/core/ledger/credAccounts.js ***!
  \*****************************************/
/*! exports provided: computeCredAccounts, _computeCredAccounts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeCredAccounts\", function() { return computeCredAccounts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_computeCredAccounts\", function() { return _computeCredAccounts; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ledger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graph */ \"./src/core/graph.js\");\n/* harmony import */ var _credrank_credGraph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../credrank/credGraph */ \"./src/core/credrank/credGraph.js\");\n/**\n * This module outputs aggregated data that combines Cred Scores with Ledger\n * Account data.\n *\n * We use this internally when creating Grain distributions using a Ledger and\n * a Cred View. It's also an experimental output format which gives overall\n * information on the cred in an instance. We may remove it or make breaking\n * changes to it in the future.\n */function computeCredAccounts(ledger,credGraph){const grainAccounts=ledger.accounts();const userlikeInfo=new Map();const intervals=credGraph.intervals();const noIntervals=intervals.length===0;for(const{address,description,credPerInterval}of credGraph.participants()){if(noIntervals){userlikeInfo.set(address,{cred:[],description});}else if(credPerInterval===null){throw new Error(\"userlike \".concat(_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].toString(address),\" does not have detailed cred\"));}else{userlikeInfo.set(address,{cred:credPerInterval,description});}}return _computeCredAccounts(grainAccounts,userlikeInfo,intervals);}function _computeCredAccounts(grainAccounts,userlikeInfo,intervals){const aliasAddresses=new Set();const accountAddresses=new Set();const accounts=[];const unclaimedAliases=[];for(const account of grainAccounts){accountAddresses.add(account.identity.address);for(const alias of account.identity.aliases){aliasAddresses.add(alias.address);}const info=userlikeInfo.get(account.identity.address);if(info==null){throw new Error(\"cred sync error: no info for account \".concat(account.identity.name));}const{cred}=info;const credAccount={account,cred,totalCred:Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(cred)};accounts.push(credAccount);}for(const[address,info]of userlikeInfo.entries()){if(accountAddresses.has(address)){// This userlike actually has an explicit account\ncontinue;}const{cred,description}=info;if(aliasAddresses.has(address)){throw new Error(\"cred sync error: alias \".concat(_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].toString(address),\" (aka \").concat(description,\") included in Cred scores\"));}unclaimedAliases.push({alias:{address,description},cred,totalCred:Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(cred)});}return{accounts,unclaimedAliases,intervals};}\n\n//# sourceURL=webpack:///./src/core/ledger/credAccounts.js?");

/***/ }),

/***/ "./src/core/ledger/currency.js":
/*!*************************************!*\
  !*** ./src/core/ledger/currency.js ***!
  \*************************************/
/*! exports provided: parseEvmChainId, protocolSymbolParser, evmChainParser, evmParser, protocolParser, currencyParser, getCurrencyKey, buildCurrency */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseEvmChainId\", function() { return parseEvmChainId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protocolSymbolParser\", function() { return protocolSymbolParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"evmChainParser\", function() { return evmChainParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"evmParser\", function() { return evmParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protocolParser\", function() { return protocolParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currencyParser\", function() { return currencyParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCurrencyKey\", function() { return getCurrencyKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildCurrency\", function() { return buildCurrency; });\n/* harmony import */ var _plugins_ethereum_ethAddress__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../plugins/ethereum/ethAddress */ \"./src/plugins/ethereum/ethAddress.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/**\n * EvmChainId is represented in the form of a stringified integer for all\n * EVM-based chains, including mainnet (1), and xDai (100).\n * The reason for this is that ethereum's client configuration utilizes\n * a number to represent chainId, and this way we can just transpose that\n * chainId here as a component of the currency Id, since the web3 client will\n * return a stringified integer when the chainId is requested.\n */function parseEvmChainId(id){const result=parseInt(id,10).toString();if(Number.isNaN(result)||result!==id){throw new Error(\"Invalid EVM chainId value: \".concat(id));}return id;}const protocolSymbolParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"exactly\"]([\"BTC\",\"FIL\"]);/**\n * Chains like Bitcoin and Filecoin do not have \"production\" sidechains so\n * we represent them as a string, as specified in the ProtocolSymbol type\n */const evmChainParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"string\"],parseEvmChainId);const evmParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"exactly\"]([\"EVM\"]),chainId:evmChainParser,tokenAddress:_plugins_ethereum_ethAddress__WEBPACK_IMPORTED_MODULE_0__[\"ethAddressParser\"]});const protocolParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"exactly\"]([\"PROTOCOL\"]),chainId:protocolSymbolParser});// @topocount TODO: enable protocolIdParser once we support its address types\nconst currencyParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"orElse\"]([evmParser,protocolParser]);/**\n * The Currency key must be stringified to ensure the data is retrievable.\n * Keying on the raw Currency object means keying on the object reference,\n * rather than the contents of the object.\n */function getCurrencyKey(currency){return json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default()(currency);}function buildCurrency(chainId,tokenAddress){return tokenAddress?evmParser.parseOrThrow({type:\"EVM\",chainId,tokenAddress}):protocolParser.parseOrThrow({type:\"PROTOCOL\",chainId});}\n\n//# sourceURL=webpack:///./src/core/ledger/currency.js?");

/***/ }),

/***/ "./src/core/ledger/distribution.js":
/*!*****************************************!*\
  !*** ./src/core/ledger/distribution.js ***!
  \*****************************************/
/*! exports provided: parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/uuid */ \"./src/util/uuid.js\");\n/* harmony import */ var _grainAllocation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./grainAllocation */ \"./src/core/ledger/grainAllocation.js\");\nconst parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({id:_util_uuid__WEBPACK_IMPORTED_MODULE_1__[\"parser\"],allocations:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](_grainAllocation__WEBPACK_IMPORTED_MODULE_2__[\"allocationParser\"]),credTimestamp:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"]});\n\n//# sourceURL=webpack:///./src/core/ledger/distribution.js?");

/***/ }),

/***/ "./src/core/ledger/distributionSummary/allocationSummary.js":
/*!******************************************************************!*\
  !*** ./src/core/ledger/distributionSummary/allocationSummary.js ***!
  \******************************************************************/
/*! exports provided: allocationMarkdownSummary, getTotalDistributed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"allocationMarkdownSummary\", function() { return allocationMarkdownSummary; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTotalDistributed\", function() { return getTotalDistributed; });\n/* harmony import */ var _util_sortBy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/sortBy */ \"./src/util/sortBy.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _ledger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _policies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../policies */ \"./src/core/ledger/policies/index.js\");\n/* harmony import */ var _distributionSummary__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./distributionSummary */ \"./src/core/ledger/distributionSummary/distributionSummary.js\");\nfunction allocationMarkdownSummary(distribution,allocation,ledger){const{receipts}=allocation;const totalDistributed=getTotalDistributed(receipts);const columnHeaders=\"|          name          |    total    |     %     |\";const divider=\"| ---------------------- | ----------- | --------- |\";return[Object(_policies__WEBPACK_IMPORTED_MODULE_4__[\"toString\"])(allocation.policy),columnHeaders,divider,sortedReceipts(receipts).map(_ref=>{let{amount,id}=_ref;return row(amount,id);}).join(\"\\n\")].join(\"\\n\");function row(amount,id){const{name}=ledger.account(id).identity;const nameFormatted=Object(_distributionSummary__WEBPACK_IMPORTED_MODULE_5__[\"formatCenter\"])(name,22);const total=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"](amount,_grain__WEBPACK_IMPORTED_MODULE_2__[\"ZERO\"]);const totalFormatted=Object(_distributionSummary__WEBPACK_IMPORTED_MODULE_5__[\"formatCenter\"])(_grain__WEBPACK_IMPORTED_MODULE_2__[\"format\"](total,3,\"\"),11);const percentage=100*_grain__WEBPACK_IMPORTED_MODULE_2__[\"toFloatRatio\"](total,totalDistributed);const percentageFormatted=Object(_distributionSummary__WEBPACK_IMPORTED_MODULE_5__[\"formatCenter\"])(percentage.toFixed(2)+\"%\",9);return\"| \".concat(nameFormatted,\" | \").concat(totalFormatted,\" | \").concat(percentageFormatted,\" |\");}}/**\n * Given {allocationBalances}, return the total Grain distributed across ids.\n */function getTotalDistributed(receipts){return receipts.reduce((sum,_ref2)=>{let{amount}=_ref2;return _grain__WEBPACK_IMPORTED_MODULE_2__[\"add\"](sum,amount);},_grain__WEBPACK_IMPORTED_MODULE_2__[\"ZERO\"]);}function sortedReceipts(receipts){return Object(_util_sortBy__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(receipts,receipt=>-Number(receipt.amount));}\n\n//# sourceURL=webpack:///./src/core/ledger/distributionSummary/allocationSummary.js?");

/***/ }),

/***/ "./src/core/ledger/distributionSummary/distributionSummary.js":
/*!********************************************************************!*\
  !*** ./src/core/ledger/distributionSummary/distributionSummary.js ***!
  \********************************************************************/
/*! exports provided: distributionMarkdownSummary, formatCenter, getDistributionBalances, getTotalDistributed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distributionMarkdownSummary\", function() { return distributionMarkdownSummary; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatCenter\", function() { return formatCenter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDistributionBalances\", function() { return getDistributionBalances; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTotalDistributed\", function() { return getTotalDistributed; });\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _util_sortBy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/sortBy */ \"./src/util/sortBy.js\");\n/* harmony import */ var _util_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/timestamp */ \"./src/util/timestamp.js\");\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _ledger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ledger */ \"./src/core/ledger/ledger.js\");\nfunction distributionMarkdownSummary(distribution,ledger,currencyDetails){const{name:currencyName,suffix:currencySuffix}=currencyDetails;const distributionBalances=getDistributionBalances(distribution);const totalDistributed=getTotalDistributed(distributionBalances);const columnHeaders=\"|          name          |    total    |     %     |\";const divider=\"| ---------------------- | ----------- | --------- |\";return[title(currencyName),timeStamp(distribution.credTimestamp),total(totalDistributed,currencySuffix),policyAmounts(distribution,currencySuffix),columnHeaders,divider,sortedIds(distributionBalances).map(row).join(\"\\n\")].join(\"\\n\");function row(id){const{name}=ledger.account(id).identity;const nameFormatted=formatCenter(name,22);const total=_util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](distributionBalances.get(id),_grain__WEBPACK_IMPORTED_MODULE_3__[\"ZERO\"]);const totalFormatted=formatCenter(_grain__WEBPACK_IMPORTED_MODULE_3__[\"format\"](total,3,\"\"),11);const percentage=100*_grain__WEBPACK_IMPORTED_MODULE_3__[\"toFloatRatio\"](total,totalDistributed);const percentageFormatted=formatCenter(percentage.toFixed(2)+\"%\",9);return\"| \".concat(nameFormatted,\" | \").concat(totalFormatted,\" | \").concat(percentageFormatted,\" |\");}}function title(currencyName){return\"## \".concat(currencyName.toUpperCase(),\" Distribution\");}function timeStamp(credTimeStamp){return\"### \".concat(Object(_util_timestamp__WEBPACK_IMPORTED_MODULE_2__[\"toISO\"])(credTimeStamp));}function total(total,currencySuffix){return\"#### Total Distributed: \".concat(_grain__WEBPACK_IMPORTED_MODULE_3__[\"formatAndTrim\"](total,currencySuffix));}function policyAmounts(distribution,currencySuffix){return distribution.allocations.map(_ref=>{let{policy}=_ref;const{policyType,budget}=policy;return\"#### \".concat(policyType,\": \").concat(_grain__WEBPACK_IMPORTED_MODULE_3__[\"formatAndTrim\"](budget,currencySuffix));}).join(\"\\n\");}/**\n * Return ids sorted by balance.\n */function sortedIds(distributionBalances){return Object(_util_sortBy__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Array.from(distributionBalances.keys()),id=>-Number(distributionBalances.get(id)));}/**\n * Center string in some whitespace for total length {len}.\n */function formatCenter(str,len){return str.length>=len?str:str.length<len-1?formatCenter(\" \".concat(str,\" \"),len):formatCenter(\"\".concat(str,\" \"),len);}/**\n * Given some distribution, return the total allocated to id across\n * all allocation policies.\n */function getDistributionBalances(distribution){const distributionBalances=new Map();distribution.allocations.map(_ref2=>{let{receipts}=_ref2;receipts.map(_ref3=>{let{amount,id}=_ref3;const existing=_util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](distributionBalances.get(id),_grain__WEBPACK_IMPORTED_MODULE_3__[\"ZERO\"]);distributionBalances.set(id,_grain__WEBPACK_IMPORTED_MODULE_3__[\"add\"](amount,existing));});});return distributionBalances;}/**\n * Given DistributionBalances, return total grain distributed\n * across participants.\n */function getTotalDistributed(distributionBalances){let total=_grain__WEBPACK_IMPORTED_MODULE_3__[\"ZERO\"];distributionBalances.forEach(amount=>{total=_grain__WEBPACK_IMPORTED_MODULE_3__[\"add\"](total,amount);});return total;}\n\n//# sourceURL=webpack:///./src/core/ledger/distributionSummary/distributionSummary.js?");

/***/ }),

/***/ "./src/core/ledger/grain.js":
/*!**********************************!*\
  !*** ./src/core/ledger/grain.js ***!
  \**********************************/
/*! exports provided: ZERO, DECIMAL_PRECISION, ONE, add, sub, mul, div, lt, gt, lte, gte, eq, fromString, format, formatAndTrim, multiplyFloat, divideFloat, fromInteger, fromFloatString, toFloatString, fromApproximateFloat, toFloatRatio, splitBudget, sum, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZERO\", function() { return ZERO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DECIMAL_PRECISION\", function() { return DECIMAL_PRECISION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ONE\", function() { return ONE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lt\", function() { return lt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gt\", function() { return gt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lte\", function() { return lte; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gte\", function() { return gte; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eq\", function() { return eq; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromString\", function() { return fromString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"format\", function() { return format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatAndTrim\", function() { return formatAndTrim; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyFloat\", function() { return multiplyFloat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divideFloat\", function() { return divideFloat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromInteger\", function() { return fromInteger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromFloatString\", function() { return fromFloatString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toFloatString\", function() { return toFloatString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromApproximateFloat\", function() { return fromApproximateFloat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toFloatRatio\", function() { return toFloatRatio; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitBudget\", function() { return splitBudget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sum\", function() { return sum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var big_integer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-integer */ \"big-integer\");\n/* harmony import */ var big_integer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(big_integer__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _api_currencyConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../api/currencyConfig */ \"./src/api/currencyConfig.js\");\n/**\n * This module contains the types for tracking Grain, which is the native\n * project-specific, cred-linked token created in SourceCred instances. In\n * practice, projects can call these tokens anything they want, but we will\n * refer to the tokens as \"Grain\" throughout the codebase. The conserved\n * properties of all Grains are that they are minted/distributed based on cred\n * scores, and that they can be used to Boost contributions in a cred graph.\n *\n * We track Grain using big integer arithmetic, so that we can be precise with\n * Grain values and avoid float imprecision issues. Following the convention of\n * ERC20 tokens, we track Grain at 18 decimals of precision, although we can\n * make this project-specific if there's a future need.\n *\n * At rest, we represent Grain as strings. This is a convenient decision around\n * serialization boundaries, so that we can just directly stringify objects containing\n * Grain values and it will Just Work. The downside is that we need to convert them to/fro\n * string representations any time we need to do Grain arithmetic, which could create\n * perf hot spots. If so, we can factor out the hot loop and do them in a way\n * that has less overhead. You can see context for this decision in [#1936] and [#1938].\n *\n * Ideally, we would just use the native [BigInt] type. However, at time of\n * writing it's not well supported by [flow] or Safari, so we use the\n * big-integer library. That library delegates out to native BigInt when\n * available, so this should be fine.\n *\n * Since the big-integer library does have a sensible `toString` method defined\n * on the integers, we could switch to representing Grain at rest via\n * big-integers rather than as strings. However, this would require re-writing\n * a lot of test code. If perf becomes an issue that would be a principled fix.\n *\n * [BigInt]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt\n * [flow]: https://github.com/facebook/flow/issues/6639\n * [#1936]: https://github.com/sourcecred/sourcecred/pull/1936\n * [#1938]: https://github.com/sourcecred/sourcecred/pull/1938\n */const ZERO=\"0\";// How many digits of precision there are in \"one\" grain\nconst DECIMAL_PRECISION=18;// One \"full\" grain\nconst ONE=big_integer__WEBPACK_IMPORTED_MODULE_1___default()(10).pow(DECIMAL_PRECISION).toString();function add(a,b){return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(a).plus(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(b)).toString();}function sub(a,b){return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(a).subtract(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(b)).toString();}function mul(a,b){return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(a).times(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(b)).toString();}function div(a,b){return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(a).divide(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(b)).toString();}function lt(a,b){return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(a).lt(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(b));}function gt(a,b){return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(a).gt(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(b));}function lte(a,b){return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(a).leq(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(b));}function gte(a,b){return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(a).geq(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(b));}function eq(a,b){return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(a).eq(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(b));}function fromString(s){return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(s).toString();}/**\n * Formats a grain balance as a human-readable number, dividing the\n * raw grain balance by `one`.\n *\n * The client controls how many digits of precision are shown; by default, we\n * display zero digits. Grain balances will have commas added as\n * thousands-separators if the balance is greater than 1000g.\n *\n * The client also specifies a suffix; by default, we use 'g' for grain.\n *\n * Here are some examples of its behavior, pretending that we use 2 decimals\n * of precision for readability:\n *\n * format(133700042n) === \"1,337,000g\"\n * format(133700042n, 2) === \"1,337,000.42g\"\n * format(133700042n, 2, \"seeds\") === \"1,337,000.42seeds\"\n * format(133700042n, 2, \"\") === \"1,337,000.42\"\n *\n */function format(grain){let decimals=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;let suffix=arguments.length>2&&arguments[2]!==undefined?arguments[2]:_api_currencyConfig__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_SUFFIX\"];if(!Number.isInteger(decimals)||decimals<0||decimals>DECIMAL_PRECISION){throw new Error(\"decimals must be integer in range [0..\".concat(DECIMAL_PRECISION,\"]\"));}const isNegative=grain[0]===\"-\";let digits=[...grain];if(isNegative){// Remove the negative sign for consistency, we'll prepend it back at the end\ndigits=digits.slice(1,digits.length);}// If the number is less than one, we need to pad it with zeros at the front\nif(digits.length<DECIMAL_PRECISION+1){digits=[...new Array(DECIMAL_PRECISION+1-digits.length).fill(\"0\"),...digits];}// If we have more than 1000 grain, then we will insert commas for\n// readability\nconst integerDigits=digits.length-DECIMAL_PRECISION;const numCommasToInsert=Math.floor((integerDigits-1)/3);for(let i=0;i<numCommasToInsert;i++){// Count digits backwards from the last integer.\n// Since we are moving from high index to low, we don't need to adjust for\n// the fact that we're mutating the length of the array as we go... if you\n// are concerned, rest assured that this logic is tested :)\ndigits.splice(integerDigits-i*3-3,0,\",\");}if(decimals>0){// Insert a decimal point at the right spot\ndigits.splice(digits.length-DECIMAL_PRECISION,0,\".\");}// Slice away all the unwanted precision\ndigits=digits.slice(0,digits.length-DECIMAL_PRECISION+decimals);if(isNegative){// re-insert the negative sign, if appropriate\ndigits.splice(0,0,\"-\");}return digits.join(\"\")+suffix;}/**\n * Formats a grain balance as a human-readable number using the format()\n * method, but trims any unnecessary decimal information.\n *\n * The intended use is for UI presentation where less visual clutter is\n * desired.\n *\n * Here are some examples of its behavior\n *\n * formatAndTrim(100000000000000) === \"0.0001g\"\n * formatAndTrim(150000000000000000000) === \"150g\"\n * formatAndTrim(15000000000000000000000) === \"15,000g\"\n * formatAndTrim(15000000000000000000000, \"seeds\") === \"15,000seeds\"\n * formatAndTrim(15000000000000000000000, \"\") === \"15,000\"\n *\n */function formatAndTrim(grain){let suffix=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_api_currencyConfig__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_SUFFIX\"];return format(grain,DECIMAL_PRECISION,\"\").replace(/\\.?0+$/,\"\")+suffix;}/**\n * Multiply a grain amount by a floating point number.\n *\n * Use this method when you need to multiply a grain balance by a floating\n * point number, e.g. a ratio.\n *\n * Note that this method is imprecise. It is not safe to assume, for example,\n * that `multiply(g, 1/3) + multiply(g, 2/3) === g` due to loss of precision.\n * However, the errors will be small in absolute terms (i.e. tiny compared to\n * one full grain).\n *\n * See some messy analysis of the numerical errors here:\n * https://observablehq.com/@decentralion/grain-arithmetic\n */function multiplyFloat(grain,num){if(!isFinite(num)){throw new Error(\"invalid input: num is \".concat(num));}if(num===1){// The one case where we can be sure to return a correct answer :)\nreturn grain;}const floatProduct=Number(grain)*num;return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(Math.floor(floatProduct)).toString();}function divideFloat(dividend,divisor){return multiplyFloat(dividend,1/divisor);}/**\n * Convert an integer number (in floating-point representation) into a precise\n * Grain value.\n */function fromInteger(x){if(!isFinite(x)||Math.floor(x)!==x){throw new Error(\"not an integer: \".concat(x));}return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(ONE).times(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(x)).toString();}/**\n * Accept human-readable numbers strings and convert them to precise grain amounts\n *\n * This is most useful for processing form input values before passing them\n * into the ledger, since all form fields return strings\n *\n * In this case, a \"float string\" is a string that returns a number value\n * when passed into `parseFloat`\n *\n * The reason to circumvent any floating point values is to avoid losses in\n * precision. By modifying the string directly in a predictable pattern, we can\n * convert uer-generated floating point values to grain at full fidelity, and avoid\n * any fuzzy floating point arithmetic\n *\n * The tradeoff here is around versatility. Values with more decimals than the\n * allowable precision will yield an error when passed in.\n */function fromFloatString(x){let precision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:DECIMAL_PRECISION;if(typeof x!==\"string\"){throw new Error(\"not a string: \".concat(x));}if(!(isFinite(x)&&x.trim())){throw new Error(\"input not a valid number: \".concat(x));}const[whole=\"\",dec=\"\"]=x.split(\".\");if(dec.length>precision){throw new Error(\"Provided decimals \".concat(dec.length,\" exceed allowable precision \").concat(precision));}const paddedDecimal=dec.padEnd(precision,\"0\");return big_integer__WEBPACK_IMPORTED_MODULE_1___default()(\"\".concat(whole).concat(paddedDecimal)).toString();}// Returns a string containing a float representation of the grain,\n// which can be rehydrated into grain losslessly using fromFloatString\n// Example: toFloatString(15000111000000000000000) === \"15000.111\"\nconst toFloatString=g=>{return formatAndTrim(g,\"\").replace(/,/g,\"\");};/**\n * Approximately create a grain balance from a float.\n *\n * This method tries to convert the floating point `amt` into a grain\n * balance. For example, `grain(1)` approximately equals `ONE`.\n *\n * Do not assume this will be precise! For example, `grain(0.1337)` results in\n * `133700000000000016n`. This method is intended for test code.\n *\n * This is a shorthand for `multiplyFloat(ONE, amt)`.\n */function fromApproximateFloat(f){return multiplyFloat(ONE,f);}/**\n * Approximates the division of two grain values\n *\n * This naive implementation of grain division converts the given values\n * to floats and performs simple floating point division.\n *\n * Do not assume this will be precise!\n */function toFloatRatio(numerator,denominator){return Number(numerator)/Number(denominator);}/**\n * Splits a budget of Grain proportional to floating-point scores.\n *\n * splitBudget guarantees that the total amount distributed will precisely\n * equal the budget. This is a surprisingly challenging property to ensure, and\n * it explains the complexity of this algorithm. We stress-test the method with\n * extremely uneven share distribution (e.g. a split where some users' scores\n * are 10**100 larger than others).\n *\n * The algorithm can be arbitrarily unfair at the atto-Grain level; for\n * example, in the case `splitBudget(fromString(\"1\"), [1, 100])` it will give\n * all the Grain to the first account, even though it only has 1/100th the score\n * of the second account. However, since Grain is tracked with 18 decimal point\n * precision, these tiny biases mean very little in practice. In testing, when\n * splitting one full Grain (i.e. 10**18 attoGrain), we haven't seen discrepancies\n * over ~100 attoGrain, or one billion-million-th of a full Grain.\n */function splitBudget(budget,scores){if(lt(budget,ZERO)){throw new Error(\"negative budget\");}const totalScore=scores.reduce((a,b)=>a+b,0);if(!isFinite(totalScore)){throw new Error(\"scores must all be finite, got: \".concat(totalScore));}if(totalScore<=0){throw new Error(\"total score must be positive, got: \".concat(totalScore));}let scoreRemaining=totalScore;let budgetRemaining=budget;const pieces=scores.map(s=>{if(s<0){throw new Error(\"negative score: \"+s);}if(s===0||scoreRemaining===0){// You would think that s === 0 implies scoreRemaining === 0, but\n// testing in extreme circumstances reveals that both checks are needed.\nreturn\"0\";}let fraction=s/scoreRemaining;if(fraction>1){fraction=1;}const piece=multiplyFloat(budgetRemaining,fraction);/**\n     * Uncomment below if you want to measure the discrepancy caused by\n     * forcing fracion=1 whenever fraction > 1.\n     *\n     * In testing, when distributing one full Grain across wildly unequal\n     * scores, it never produced more than ~hundreds of attoGrain discrepancy.\n     */ /*\n    const altPiece = multiplyFloat(budgetRemaining, s / scoreRemaining);\n    if (altPiece !== piece) {\n      const delta = sub(altPiece, piece);\n      console.error(\n        `${delta} discrepancy due to capping ${s} / ${scoreRemaining} from ${\n          s / scoreRemaining\n        } to 1`\n      );\n    }\n    */budgetRemaining=sub(budgetRemaining,piece);scoreRemaining-=s;return piece;});// istanbul ignore if\nif(lt(budgetRemaining,\"0\")){// Per the contract of the function, this should never happen.\nthrow new Error(\"invariant error: budget overspent: \"+budgetRemaining);}if(gt(budgetRemaining,\"0\")){/**\n     * Uncomment below if you want to measure the discrepancy caused by this\n     * \"giveaway-leftovers\" approach. In testing, when run with wildly varying\n     * shares, it never produced more than ~hundreds of attoGrain discrepancy.\n     */ /*\n    console.error(\n      `${budgetRemaining} discrepancy being resolved via giveaway to last share`\n    );\n    */pieces[pieces.length-1]=add(pieces[pieces.length-1],budgetRemaining);}return pieces;}/**\n * Sum a sequence of Grain values.\n */function sum(xs){let total=big_integer__WEBPACK_IMPORTED_MODULE_1___default()(0);for(const x of xs){total=total.add(big_integer__WEBPACK_IMPORTED_MODULE_1___default()(x));}return total.toString();}const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],fromString);\n\n//# sourceURL=webpack:///./src/core/ledger/grain.js?");

/***/ }),

/***/ "./src/core/ledger/grainAllocation.js":
/*!********************************************!*\
  !*** ./src/core/ledger/grainAllocation.js ***!
  \********************************************/
/*! exports provided: computeAllocation, computeAllocationSpecial, _validateAllocationBudget, allocationParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeAllocation\", function() { return computeAllocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeAllocationSpecial\", function() { return computeAllocationSpecial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_validateAllocationBudget\", function() { return _validateAllocationBudget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"allocationParser\", function() { return allocationParser; });\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/uuid */ \"./src/util/uuid.js\");\n/* harmony import */ var _policies__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./policies */ \"./src/core/ledger/policies/index.js\");\n/**\n * In SourceCred, projects regularly distribute Grain to contributors based on\n * their Cred scores. This is called a \"Distribution\". This module contains the\n * logic for computing distributions.\n */function computeAllocation(policy,credGrainView,effectiveTimestamp){const validatedPolicy=_validatePolicy(policy);credGrainView.validateForGrainAllocation();return _validateAllocationBudget({policy,receipts:receipts(validatedPolicy,credGrainView,effectiveTimestamp),id:Object(_util_uuid__WEBPACK_IMPORTED_MODULE_2__[\"random\"])()});}/* This is a simplified case that should not require a credGrainView */function computeAllocationSpecial(policy,identities){const validatedPolicy=_validatePolicy(policy);if(validatedPolicy.policyType===\"SPECIAL\"){return _validateAllocationBudget({policy,receipts:Object(_policies__WEBPACK_IMPORTED_MODULE_3__[\"specialReceipts\"])(validatedPolicy,identities),id:Object(_util_uuid__WEBPACK_IMPORTED_MODULE_2__[\"random\"])()});}else{throw new Error(\"SpecialPolicyRequired. Got: \".concat(validatedPolicy.policyType));}}function _validatePolicy(p){_policies__WEBPACK_IMPORTED_MODULE_3__[\"allocationPolicyParser\"].parseOrThrow(p);if(_grain__WEBPACK_IMPORTED_MODULE_0__[\"lt\"](p.budget,_grain__WEBPACK_IMPORTED_MODULE_0__[\"ZERO\"])){throw new Error(\"invalid budget: \".concat(p.budget));}return p;}// Exported for test purposes.\nfunction _validateAllocationBudget(a){const amt=_grain__WEBPACK_IMPORTED_MODULE_0__[\"sum\"](a.receipts.map(a=>a.amount));if(amt!==a.policy.budget){throw new Error(\"allocation has budget of \".concat(a.policy.budget,\" but distributed \").concat(amt));}return a;}function receipts(policy,credGrainView,effectiveTimestamp){switch(policy.policyType){case\"IMMEDIATE\":return Object(_policies__WEBPACK_IMPORTED_MODULE_3__[\"immediateReceipts\"])(policy,credGrainView,effectiveTimestamp);case\"RECENT\":return Object(_policies__WEBPACK_IMPORTED_MODULE_3__[\"recentReceipts\"])(policy,credGrainView,effectiveTimestamp);case\"BALANCED\":return Object(_policies__WEBPACK_IMPORTED_MODULE_3__[\"balancedReceipts\"])(policy,credGrainView,effectiveTimestamp);case\"SPECIAL\":const identities=credGrainView.activeParticipants().map(participant=>participant.identity);return Object(_policies__WEBPACK_IMPORTED_MODULE_3__[\"specialReceipts\"])(policy,identities);// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(\"Unknown policyType: \".concat(policy.policyType));}}const grainReceiptParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({id:_util_uuid__WEBPACK_IMPORTED_MODULE_2__[\"parser\"],amount:_grain__WEBPACK_IMPORTED_MODULE_0__[\"parser\"]});const allocationParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({policy:_policies__WEBPACK_IMPORTED_MODULE_3__[\"allocationPolicyParser\"],id:_util_uuid__WEBPACK_IMPORTED_MODULE_2__[\"parser\"],receipts:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"array\"](grainReceiptParser)});\n\n//# sourceURL=webpack:///./src/core/ledger/grainAllocation.js?");

/***/ }),

/***/ "./src/core/ledger/grainIntegration.js":
/*!*********************************************!*\
  !*** ./src/core/ledger/grainIntegration.js ***!
  \*********************************************/
/*! exports provided: executeGrainIntegration, buildDistributionIndexes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"executeGrainIntegration\", function() { return executeGrainIntegration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildDistributionIndexes\", function() { return buildDistributionIndexes; });\n/* harmony import */ var _ledger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _distributionSummary_distributionSummary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distributionSummary/distributionSummary.js */ \"./src/core/ledger/distributionSummary/distributionSummary.js\");\n/* harmony import */ var _currency_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./currency.js */ \"./src/core/ledger/currency.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./grain */ \"./src/core/ledger/grain.js\");\n///////////////////\n// Helper functions\n///////////////////\n// TODO @topocount: Refactor interface using instance/config properties\n// after grainConfig is updated to include The payout currency details and\n// sink identity\nfunction executeGrainIntegration(ledger,integration,distribution,currency,processDistributions,sink){let accountingEnabled=arguments.length>6&&arguments[6]!==undefined?arguments[6]:false;const{payoutDistributions,payoutAddressToId}=buildDistributionIndexes(ledger,distribution,Object(_currency_js__WEBPACK_IMPORTED_MODULE_2__[\"getCurrencyKey\"])(currency));// Need to receive actual allocations so users don't lose funds if\n// decimals are truncated in L2 or in some other environment that must modify\n// the fixed-point amount for some reason.\nlet result;try{result=integration(payoutDistributions,{currency,accountingEnabled,processDistributions});if(processDistributions)ledger.markDistributionExecuted(distribution.id);}catch(e){throw new Error(\"Grain Integration failed: \".concat(e));}if(result&&sink&&accountingEnabled&&processDistributions){const{transferredGrain}=result;for(const{payoutAddress,amount,memo}of transferredGrain){const recipientId=payoutAddressToId.get(payoutAddress);if(!recipientId)throw new Error(\"Invalid recipient address: \".concat(payoutAddress));ledger.transferGrain({from:recipientId,to:sink,amount,memo:\"Integrated Distribution: \".concat(memo)});}}return{ledger,output:result.outputFile,distributionCredTimestamp:distribution.credTimestamp};}function buildDistributionIndexes(ledger,distribution,currencyId){const payoutDistributionMap=new Map();const payoutAddressToId=new Map();const balances=Object(_distributionSummary_distributionSummary_js__WEBPACK_IMPORTED_MODULE_1__[\"getDistributionBalances\"])(distribution);for(const[id,amount]of balances.entries()){const{payoutAddresses,identity}=ledger.account(id);const address=payoutAddresses.get(currencyId);if(!address)continue;// need to allow for identities that have since been merged to still claim\n// funds if accounts are merged between a grain distribution and a\n// grainIntegration call.\nconst total=_util_null__WEBPACK_IMPORTED_MODULE_3__[\"orElse\"](payoutDistributionMap.get(address),_grain__WEBPACK_IMPORTED_MODULE_4__[\"ZERO\"]);payoutDistributionMap.set(address,_grain__WEBPACK_IMPORTED_MODULE_4__[\"add\"](amount,total));payoutAddressToId.set(address,identity.id);}const payoutDistributions=Array.from(payoutDistributionMap.entries());return{payoutDistributions,payoutAddressToId};}\n\n//# sourceURL=webpack:///./src/core/ledger/grainIntegration.js?");

/***/ }),

/***/ "./src/core/ledger/identityProposal.js":
/*!*********************************************!*\
  !*** ./src/core/ledger/identityProposal.js ***!
  \*********************************************/
/*! exports provided: parser, identityProposalsParser, ensureIdentityExists, _chooseIdentityName */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identityProposalsParser\", function() { return identityProposalsParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ensureIdentityExists\", function() { return ensureIdentityExists; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_chooseIdentityName\", function() { return _chooseIdentityName; });\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _ledger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ledger */ \"./src/core/ledger/ledger.js\");\n/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../identity */ \"./src/core/identity/index.js\");\nconst parser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({name:_identity__WEBPACK_IMPORTED_MODULE_3__[\"nameParser\"],pluginName:_identity__WEBPACK_IMPORTED_MODULE_3__[\"nameParser\"],alias:_identity__WEBPACK_IMPORTED_MODULE_3__[\"aliasParser\"],type:_identity__WEBPACK_IMPORTED_MODULE_3__[\"identityTypeParser\"]});const identityProposalsParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"array\"](parser);/**\n * Given a Ledger and an IdentityProposal, ensure that some Ledger account\n * exists for the proposed identity and return the identity ID.\n *\n * If there is already an account matching the node address of the proposal's\n * alias, then the ledger is unchanged.\n *\n * Otherwise, a new account will be created per the semantics of the\n * IdentityProposal type.\n */function ensureIdentityExists(ledger,proposal){const existingAccount=ledger.accountByAddress(proposal.alias.address);if(existingAccount!=null){// there is already some account that includes this address; do nothing\nreturn existingAccount.identity.id;}const name=_chooseIdentityName(proposal,n=>ledger.nameAvailable(n));const id=ledger.createIdentity(proposal.type,name);ledger.addAlias(id,proposal.alias);return id;}const MAX_NUMERIC_DISCRIMINATOR=100;function _chooseIdentityName(proposal,checkAvailability){if(checkAvailability(proposal.name)){return proposal.name;}const withPluginDiscriminator=Object(_identity__WEBPACK_IMPORTED_MODULE_3__[\"nameFromString\"])(proposal.name+\"-\"+proposal.pluginName);if(checkAvailability(withPluginDiscriminator)){return withPluginDiscriminator;}for(let i=1;i<MAX_NUMERIC_DISCRIMINATOR;i++){const withNumericDiscriminator=Object(_identity__WEBPACK_IMPORTED_MODULE_3__[\"nameFromString\"])(withPluginDiscriminator+\"-\"+i);if(checkAvailability(withNumericDiscriminator)){return withNumericDiscriminator;}}throw new Error(\"unable to find an identity name for \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(proposal)));}\n\n//# sourceURL=webpack:///./src/core/ledger/identityProposal.js?");

/***/ }),

/***/ "./src/core/ledger/ledger.js":
/*!***********************************!*\
  !*** ./src/core/ledger/ledger.js ***!
  \***********************************/
/*! exports provided: Ledger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ledger\", function() { return Ledger; });\n/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../identity */ \"./src/core/identity/index.js\");\n/* harmony import */ var _currency__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./currency */ \"./src/core/ledger/currency.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graph */ \"./src/core/graph.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/uuid */ \"./src/util/uuid.js\");\n/* harmony import */ var _distribution__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./distribution */ \"./src/core/ledger/distribution.js\");\n/* harmony import */ var _plugins_ethereum_ethAddress__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../plugins/ethereum/ethAddress */ \"./src/plugins/ethereum/ethAddress.js\");\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _util_jsonLog__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/jsonLog */ \"./src/util/jsonLog.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * This module contains the ledger, for accumulating state updates related to\n * identity identities and Grain distribution.\n *\n * A key requirement for the ledger is that we need to store an ordered log of\n * every action that's happened in the ledger, so that we can audit the ledger\n * state to ensure its integrity.\n *//**\n * The Ledger is an append-only auditable data store which tracks\n * - Identities and what aliases they possess\n * - Identities' grain balances\n *\n * Every time the ledger state is changed, a corresponding Action is added to\n * the ledger's action log. The ledger state may be serialized by saving the\n * action log, and then reconstructed by replaying the action log. The\n * corresponding methods are `actionLog` and `Ledger.fromActionLog`.\n *\n * None of these methods are idempotent, since they all modify the Ledger state\n * on success by adding a new action to the log. Therefore, they will all fail\n * if they would not cause any change to the ledger's logical state, so as to\n * prevent the ledger from permanently accumulating no-op clutter in the log.\n *\n * It's important that any API method that fails (e.g. trying to add a\n * conflicting identity) fails without mutating the ledger state; this way we avoid\n * ever getting the ledger in a corrupted state. To make this easier to test,\n * the test code uses deep equality testing on the ledger before/after\n * attempting illegal actions. To ensure that this testing works, we should\n * avoid adding any ledger state that can't be verified by deep equality\n * checking (e.g. don't store state in functions or closures that aren't\n * attached to the Ledger object).\n *\n * Every Ledger action has a timestamp, and the Ledger's actions must always be\n * in timestamp-sorted order. Adding a new Action with a timestamp older than a\n * previous action is illegal.\n */class Ledger{constructor(){_defineProperty(this,\"_ledgerEventLog\",void 0);_defineProperty(this,\"_nameToId\",void 0);_defineProperty(this,\"_lowercaseNames\",void 0);_defineProperty(this,\"_aliasAddressToIdentity\",void 0);_defineProperty(this,\"_accounts\",void 0);_defineProperty(this,\"_allocations\",void 0);_defineProperty(this,\"_distributions\",void 0);_defineProperty(this,\"_allocationsToDistributions\",void 0);_defineProperty(this,\"_latestTimestamp\",-Infinity);_defineProperty(this,\"_lastDistributionTimestamp\",null);_defineProperty(this,\"_shouldTrackGrainIntegration\",false);_defineProperty(this,\"_grainIntegrationStatuses\",void 0);this._ledgerEventLog=new _util_jsonLog__WEBPACK_IMPORTED_MODULE_8__[\"JsonLog\"]();this._nameToId=new Map();this._lowercaseNames=new Set();this._aliasAddressToIdentity=new Map();this._accounts=new Map();this._allocations=new Map();this._distributions=new Map();this._allocationsToDistributions=new Map();this._grainIntegrationStatuses=new Map();}/**\n   * Return all the Accounts in the ledger.\n   */accounts(){return Array.from(new Set(this._accounts.values()));}/**\n   * Get the Account associated with a particular identity.\n   *\n   * If the identity is not in the ledger, an error is thrown.\n   */account(id){// This wrapper ensures it's a read-only type\nreturn this._mutableAccount(id);}_mutableAccount(id){const result=this._accounts.get(id);if(result==null){throw new Error(\"no Account for identity: \".concat(id));}return result;}/**\n   * Return whether the IdentityName in question is available.\n   *\n   * For convenience in test code (and consistency with createIdentity and renameIdentity),\n   * the name is provided as a string. If the string is not a valid name, an error will be\n   * thrown.\n   */nameAvailable(name){// Error if the name is not valid.\nObject(_identity__WEBPACK_IMPORTED_MODULE_0__[\"nameFromString\"])(name);// We don't need to explicitly test the name itself, since if a name\n// is reserved, its lowercased version is also reserved.\nreturn!this._lowercaseNames.has(name.toLowerCase());}/**\n   * Return the account matching a given NodeAddress, if one exists.\n   *\n   * Returns null if there is no account matching that address.\n   */accountByAddress(address){const identityId=this._aliasAddressToIdentity.get(address);if(identityId==null){return null;}return this.account(identityId);}/**\n   * Return the account with the given name, if one exists.\n   *\n   * Returns null if there is no account matching that address.\n   *\n   * Note: This is case sensitive.\n   */accountByName(name){const identityId=this._nameToId.get(Object(_identity__WEBPACK_IMPORTED_MODULE_0__[\"nameFromString\"])(name));if(identityId==null){return null;}return this.account(identityId);}/**\n   * Get the Allocation associated with a particular Allocation ID.\n   *\n   * If the ID is not in the ledger, an error is thrown.\n   */allocation(id){const allocation=this._allocations.get(id);if(allocation==null)throw new Error(\"no Allocation for id: \".concat(id));return allocation;}/**\n   * Get an Iterator over all Allocations in the order they occur in the Ledger.\n   */allocations(){return this._allocations.values();}/**\n   * Get the Distribution associated with a particular Distribution ID.\n   *\n   * If the ID is not in the ledger, an error is thrown.\n   */distribution(id){const distribution=this._distributions.get(id);if(distribution==null)throw new Error(\"no Distribution for id: \".concat(id));return distribution;}/**\n   * Get an Iterator over all Distributions in the order they occur in the Ledger.\n   */distributions(){return this._distributions.values();}/**\n   * Get the Distribution associated with a particular Allocation ID.\n   *\n   * If the Allocation ID is not associated with a distribution, an error is thrown.\n   */distributionByAllocationId(allocationId){const distributionId=this._allocationsToDistributions.get(allocationId);if(distributionId==null)throw new Error(\"no Distribution for allocation id: \".concat(allocationId));return this.distribution(distributionId);}/**\n   * Create an account in the ledger.\n   *\n   * This will reserve the identity's name, and its innate address.\n   *\n   * This returns the newly created Identity's ID, so that the caller\n   * store it for future reference.\n   *\n   * Will fail if the name is not valid, or already taken.\n   */createIdentity(type,name){const identity=Object(_identity__WEBPACK_IMPORTED_MODULE_0__[\"newIdentity\"])(type,name);const action={type:\"CREATE_IDENTITY\",identity};this._createAndProcessEvent(action);return _util_null__WEBPACK_IMPORTED_MODULE_3__[\"get\"](this._nameToId.get(identity.name));}_createIdentity(_ref){let{identity}=_ref;if(this._nameToId.has(identity.name)){// This identity already exists; return.\nthrow new Error(\"createIdentity: name already taken: \".concat(identity.name));}if(this._lowercaseNames.has(identity.name.toLowerCase())){throw new Error(\"createIdentity: already have same name with different capitalization: \".concat(identity.name));}if(identity.aliases.length!==0){throw new Error(\"createIdentity: new identities may not have aliases\");}// istanbul ignore if\nif(this._aliasAddressToIdentity.has(identity.address)){// This should never happen, as it implies a UUID conflict.\nthrow new Error(\"createIdentity: innate address already claimed \".concat(identity.id));}// Mutations! Method must not fail after this comment.\nthis._nameToId.set(identity.name,identity.id);this._lowercaseNames.add(identity.name.toLowerCase());// Reserve this identity's own address\nthis._aliasAddressToIdentity.set(identity.address,identity.id);// Every identity has a corresponding Account.\nthis._accounts.set(identity.id,{balance:_grain__WEBPACK_IMPORTED_MODULE_7__[\"ZERO\"],paid:_grain__WEBPACK_IMPORTED_MODULE_7__[\"ZERO\"],identity,active:false,allocationHistory:[],payoutAddresses:new Map(),// seed this array with the account's own identityId\nmergedIdentityIds:[identity.id]});}/**\n   * Merge two identities together.\n   *\n   * One identity is considered the \"base\" and the other is the \"target\".\n   * The target is absorbed into the base, meaning:\n   * - Base gets the Grain balance, and lifetime paid amount added to its account.\n   * - Base gets every alias that the target had.\n   * - Base gets the target's own address as an alias.\n   * - The target account is removed from the ledger.\n   * - The target's login name is freed.\n   *\n   * Attempting to merge an identity that doesn't exist, or to merge an identity into\n   * itself, will error.\n   */mergeIdentities(opts){const{base,target}=opts;const action={type:\"MERGE_IDENTITIES\",base,target};this._createAndProcessEvent(action);return this;}_mergeIdentities(_ref2){let{base,target}=_ref2;const baseAccount=this._mutableAccount(base);const targetAccount=this.account(target);const baseIdentity=baseAccount.identity;const targetIdentity=targetAccount.identity;if(base===target){throw new Error(\"tried to merge identity @\".concat(baseIdentity.name,\" with itself\"));}const updatedAliases=baseIdentity.aliases.slice();const transferAlias=alias=>{updatedAliases.push(alias);this._aliasAddressToIdentity.set(alias.address,baseIdentity.id);};// Mutation follows. Nothing after this line may throw.\ntargetIdentity.aliases.forEach(a=>transferAlias(a));const innateAlias={address:targetIdentity.address,description:\"identity @\".concat(targetIdentity.name,\" (id: \").concat(targetIdentity.id,\")\")};transferAlias(innateAlias);const updatedIdentity=_objectSpread(_objectSpread({},baseIdentity),{},{aliases:updatedAliases});baseAccount.identity=updatedIdentity;baseAccount.paid=_grain__WEBPACK_IMPORTED_MODULE_7__[\"add\"](baseAccount.paid,targetAccount.paid);baseAccount.allocationHistory=baseAccount.allocationHistory.concat(targetAccount.allocationHistory).sort((a,b)=>a.credTimestampMs-b.credTimestampMs);// merge payout payoutAddresses under one account, but don't overwrite base\n// account entries\nbaseAccount.payoutAddresses=new Map([...targetAccount.payoutAddresses.entries(),...baseAccount.payoutAddresses.entries()]);baseAccount.balance=_grain__WEBPACK_IMPORTED_MODULE_7__[\"add\"](baseAccount.balance,targetAccount.balance);targetAccount.mergedIdentityIds.forEach(id=>{this._accounts.set(id,baseAccount);baseAccount.mergedIdentityIds.push(id);});this._nameToId.delete(targetIdentity.name);this._lowercaseNames.delete(targetIdentity.name.toLowerCase());}/**\n   * Change a identity's name.\n   *\n   * Will fail if no identity matches the identityId, or if the identity already has that\n   * name, or if the identity's new name is claimed by another identity.\n   */renameIdentity(identityId,newName){this._createAndProcessEvent({type:\"RENAME_IDENTITY\",identityId,newName:Object(_identity__WEBPACK_IMPORTED_MODULE_0__[\"nameFromString\"])(newName)});return this;}_renameIdentity(_ref3){let{identityId,newName}=_ref3;if(!this._accounts.has(identityId)){throw new Error(\"renameIdentity: no identity matches id \".concat(identityId));}const account=this._mutableAccount(identityId);const existingIdentity=account.identity;const existingName=existingIdentity.name;if(existingName===newName){// We error rather than silently succeed because we don't want the ledger\n// to get polluted with no-op records (no successful operations are\n// idempotent, since they do add to the ledger logs)\nthrow new Error(\"renameIdentity: identity already has name \".concat(newName));}if(this._nameToId.has(newName)){// We already checked that the name is not owned by this identity,\n// so it is a conflict. Fail.\nthrow new Error(\"renameIdentity: conflict on name \".concat(newName));}const lowerCased=newName.toLowerCase();if(this._lowercaseNames.has(lowerCased)&&lowerCased!==existingName.toLowerCase()){throw new Error(\"renameIdentity: already have same name with different capitalization: \".concat(newName));}const updatedIdentity={id:identityId,name:newName,subtype:existingIdentity.subtype,address:existingIdentity.address,aliases:existingIdentity.aliases};// Mutations! Method must not fail after this comment.\nthis._nameToId.delete(existingIdentity.name);this._nameToId.set(newName,identityId);this._lowercaseNames.delete(existingIdentity.name.toLowerCase());this._lowercaseNames.add(newName.toLowerCase());account.identity=updatedIdentity;}/**\n   * Add an alias for a identity.\n   *\n   * If that alias is associated with past Grain payments (because it\n   * was unlinked from another identity), those past Grain payments will be\n   * associated with the newly linked identity.\n   *\n   * Will fail if the identity does not exist.\n   * Will fail if the alias is already claimed by any identity.\n   */addAlias(identityId,alias){this._createAndProcessEvent({type:\"ADD_ALIAS\",identityId,alias});return this;}_addAlias(_ref4){let{identityId,alias}=_ref4;if(!this._accounts.has(identityId)){throw new Error(\"addAlias: no identity matches id \".concat(identityId));}const account=this._mutableAccount(identityId);const existingIdentity=account.identity;const existingAliases=existingIdentity.aliases;if(existingAliases.map(a=>a.address).indexOf(alias.address)!==-1){throw new Error(\"addAlias: identity already has alias: \".concat(existingIdentity.name,\", \").concat(_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].toString(alias.address)));}if(this._aliasAddressToIdentity.has(alias.address)){// Some other identity has this alias; fail.\nthrow new Error(\"addAlias: alias \".concat(_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].toString(alias.address),\" already bound\"));}// Mutations below; method must not fail after this line.\nthis._aliasAddressToIdentity.set(alias.address,identityId);const updatedAliases=existingIdentity.aliases.slice();updatedAliases.push(alias);const updatedIdentity={id:existingIdentity.id,name:existingIdentity.name,subtype:existingIdentity.subtype,aliases:updatedAliases,address:existingIdentity.address};account.identity=updatedIdentity;}/**\n   * Activate an account, making it eligible to send and recieve Grain.\n   *\n   * If the account is already active, this will no-op (without emitting any\n   * event).\n   */activate(id){if(!this._accounts.has(id)){throw new Error(\"identity \".concat(id,\" not found\"));}const{active}=this.account(id);if(active){// no-op; account already active\nreturn this;}else{this._createAndProcessEvent({type:\"TOGGLE_ACTIVATION\",identityId:id});return this;}}/**\n   * Deactivate an account, making it ineligible to send or recieve Grain.\n   *\n   * The account's Grain balance will remain untouched until it is reactivated.\n   *\n   * If the account is already inactive, this will no-op (without emitting any\n   * event).\n   */deactivate(id){if(!this._accounts.has(id)){throw new Error(\"identity \".concat(id,\" not found\"));}const{active}=this.account(id);if(active){this._createAndProcessEvent({type:\"TOGGLE_ACTIVATION\",identityId:id});return this;}else{// no-op; account already inactive\nreturn this;}}_toggleActivation(_ref5){let{identityId}=_ref5;const account=this._mutableAccount(identityId);// Cannot fail below this line.\naccount.active=!account.active;}/**\n   * Canonicalize a Grain distribution in the ledger.\n   *\n   * Fails if any of the recipients are not active.\n   */distributeGrain(distribution){this._createAndProcessEvent({type:\"DISTRIBUTE_GRAIN\",distribution});return this;}_distributeGrain(_ref6){let{distribution}=_ref6;const parseResult=_distribution__WEBPACK_IMPORTED_MODULE_5__[\"parser\"].parse(distribution);if(!parseResult.ok){throw new Error(\"invalid distribution: \".concat(parseResult.err));}for(const{receipts}of distribution.allocations){for(const{id,amount}of receipts){if(!this._accounts.has(id)){throw new Error(\"cannot distribute; invalid id \".concat(id));}if(_grain__WEBPACK_IMPORTED_MODULE_7__[\"lt\"](amount,_grain__WEBPACK_IMPORTED_MODULE_7__[\"ZERO\"])){throw new Error(\"negative Grain amount: \".concat(amount));}const{active}=this.account(id);if(!active){throw new Error(\"attempt to distribute to inactive account: \".concat(id));}}}// Mutations beckon: method must not fail after this comment\nthis._distributions.set(distribution.id,distribution);for(const allocation of distribution.allocations){this._allocations.set(allocation.id,allocation);this._allocationsToDistributions.set(allocation.id,distribution.id);for(const grainReceipt of allocation.receipts){this._allocateGrain({grainReceipt,allocationId:allocation.id,credTimestampMs:distribution.credTimestamp});}}if(this._lastDistributionTimestamp===null||distribution.credTimestamp>this._lastDistributionTimestamp){this._lastDistributionTimestamp=distribution.credTimestamp;}if(this._shouldTrackGrainIntegration){this._grainIntegrationStatuses.set(distribution.id,false);}}/**\n   * Transfer Grain from one account to another.\n   *\n   * Fails if the sender does not have enough Grain, or if the Grain amount is\n   * negative.\n   * Fails if either the sender or the receipient have not been activated.\n   * Self-transfers are supported.\n   * An optional memo may be added.\n   *\n   * Note: The arguments need to be bundled together in an object with named\n   * keys, to avoid getting confused about which positional argument is `from`\n   * and which one is `to`.\n   */transferGrain(opts){const{from,to,amount,memo}=opts;this._createAndProcessEvent({from,to,amount,memo,type:\"TRANSFER_GRAIN\"});return this;}_transferGrain(_ref7){let{from,to,amount}=_ref7;if(!this._accounts.has(from)){throw new Error(\"invalid sender: \".concat(from));}if(!this._accounts.has(to)){throw new Error(\"invalid recipient: \".concat(to));}const fromAccount=this._mutableAccount(from);const toAccount=this._mutableAccount(to);if(!fromAccount.active){throw new Error(\"transfer from inactive account: \".concat(from));}if(!toAccount.active){throw new Error(\"transfer to inactive account: \".concat(to));}if(_grain__WEBPACK_IMPORTED_MODULE_7__[\"lt\"](amount,_grain__WEBPACK_IMPORTED_MODULE_7__[\"ZERO\"])){throw new Error(\"cannot transfer negative Grain amount: \".concat(amount));}if(_grain__WEBPACK_IMPORTED_MODULE_7__[\"gt\"](amount,fromAccount.balance)){throw new Error(\"transferGrain: \".concat(from,\" has insufficient balance for transfer: \").concat(amount,\" > \").concat(fromAccount.balance));}// Mutation ahead: May not fail after this comment\nfromAccount.balance=_grain__WEBPACK_IMPORTED_MODULE_7__[\"sub\"](fromAccount.balance,amount);toAccount.balance=_grain__WEBPACK_IMPORTED_MODULE_7__[\"add\"](toAccount.balance,amount);}changeIdentityType(identityId,newType){this._createAndProcessEvent({type:\"CHANGE_IDENTITY_TYPE\",newType,identityId});return this;}_changeIdentityType(_ref8){let{identityId,newType}=_ref8;const parseResult=_identity__WEBPACK_IMPORTED_MODULE_0__[\"identityTypeParser\"].parse(newType);if(!parseResult.ok){throw new Error(\"changeIdentityType: invalid type \".concat(newType));}if(!this._accounts.has(identityId)){throw new Error(\"changeIdentityType: no identity matches id \".concat(identityId));}const account=this._mutableAccount(identityId);const existingIdentity=account.identity;if(existingIdentity.subtype===newType){// We error rather than silently succeed because we don't want the ledger\n// to get polluted with no-op records (no successful operations are\n// idempotent, since they do add to the ledger logs)\nthrow new Error(\"changeIdentityType: identity already has type \".concat(newType));}const updatedIdentity={id:identityId,name:existingIdentity.name,subtype:newType,address:existingIdentity.address,aliases:existingIdentity.aliases};// Mutations! Method must not fail after this comment.\naccount.identity=updatedIdentity;}/**\n   * setPayoutAddress allows participants to set a payable address to collect\n   * grain. These addresses are keyed on a specific currency, which ensures that\n   * users don't erroneously receive a grain distribution to an address that\n   * cannot handle it (such as a custodial wallet, or rigidly-designed\n   * contract) and effectively lose that reward.\n   *\n   * An address may be deleted by passing in `null` for the\n   * `payoutAddress` parameter. This is useful in case the underlying private key\n   * is compromised or the exchange hosting a custodial account is hacked.\n   */setPayoutAddress(id,payoutAddress,chainId,tokenAddress){this._createAndProcessEvent({type:\"SET_PAYOUT_ADDRESS\",id,payoutAddress,currency:Object(_currency__WEBPACK_IMPORTED_MODULE_1__[\"buildCurrency\"])(chainId,tokenAddress)});return this;}_setPayoutAddress(_ref9){let{id,currency,payoutAddress}=_ref9;if(!this._accounts.has(id)){throw new Error(\"setPayoutAddress: no identity matches id \".concat(id));}const account=this._mutableAccount(id);const currencyResult=_currency__WEBPACK_IMPORTED_MODULE_1__[\"currencyParser\"].parse(currency);if(!currencyResult.ok){throw new Error(\"Invalid chainId or tokenAddress:\\n        \".concat(currencyResult.err));}if(payoutAddress!==null){const addressResult=_plugins_ethereum_ethAddress__WEBPACK_IMPORTED_MODULE_6__[\"ethAddressParser\"].parse(payoutAddress);if(!addressResult.ok){throw new Error(\"setPayoutAddress: invalid payout address: \".concat(payoutAddress));}// Mutations! Method must not fail below this comment.\naccount.payoutAddresses.set(Object(_currency__WEBPACK_IMPORTED_MODULE_1__[\"getCurrencyKey\"])(currencyResult.value),payoutAddress);return;}// else (payoutAddress === null) and we delete the entry\naccount.payoutAddresses.delete(Object(_currency__WEBPACK_IMPORTED_MODULE_1__[\"getCurrencyKey\"])(currencyResult.value));}/**\n   * no-ops if integration tracking is already enabled\n   */enableIntegrationTracking(){if(!this._shouldTrackGrainIntegration){this._createAndProcessEvent({type:\"ENABLE_GRAIN_INTEGRATION\"});}return this;}/**\n   * no-ops if integration tracking is already disabled\n   */disableIntegrationTracking(){if(this._shouldTrackGrainIntegration){this._createAndProcessEvent({type:\"DISABLE_GRAIN_INTEGRATION\"});}return this;}_enableGrainIntegrationTracking(_){this._shouldTrackGrainIntegration=true;}_disableGrainIntegrationTracking(_){this._shouldTrackGrainIntegration=false;this._grainIntegrationStatuses.clear();}/**\n   * Mark integrations as executed.\n   * Validates that:\n   * a) executions are tracked\n   * b) executions are not yet marked as executed\n   * c) distribution tracking is enabled\n   */markDistributionExecuted(id){if(!this._shouldTrackGrainIntegration){throw new Error(\"integration tracking not enabled\");}if(this._grainIntegrationStatuses.get(id)===undefined){throw new Error(\"Distribution not eligible to executed\");}if(this._grainIntegrationStatuses.get(id)===true){throw new Error(\"Integration has already executed this distribution\");}this._createAndProcessEvent({type:\"MARK_DISTRIBUTION_EXECUTED\",id});return this;}_markDistributionExecuted(_ref10){let{id}=_ref10;this._grainIntegrationStatuses.set(id,true);}/**\n   * Is cleared each time `disableIntegrationTracking` is called\n   */trackedDistributions(){return this._grainIntegrationStatuses.keys();}/**\n   * Returns the status of a tracked distribution\n   * If the distribution has not been executed by the integration, `false` is\n   * returned.\n   * If the distribution has been executed, `true` is returned.\n   * If the distribution is untracked, `undefined` is returned.\n   */isGrainIntegrationExecuted(id){return this._grainIntegrationStatuses.get(id);}/**\n   * Retrieve the log of all actions in the Ledger's history.\n   *\n   * May be used to reconstruct the Ledger after serialization.\n   */eventLog(){return Array.from(this._ledgerEventLog.values());}/**\n   * Reconstruct a Ledger from a LedgerLog.\n   */static fromEventLog(log){const ledger=new Ledger();for(const e of log){ledger._processEvent(e);}return ledger;}/**\n   * Serialize the events as a JsonLog-style newline-delimited JSON\n   * string.\n   */serialize(){return this._ledgerEventLog.toString();}/**\n   * Parse events serialized as a JsonLog-style newline-delimited JSON\n   * string (e.g., by `serialize`).\n   */static parse(eventLog){const jsonLog=_util_jsonLog__WEBPACK_IMPORTED_MODULE_8__[\"JsonLog\"].fromString(eventLog,ledgerEventParser);return Ledger.fromEventLog(Array.from(jsonLog.values()));}/**\n   * Return the cred-effective timestamp for the last Grain distribution.\n   *\n   * We provide this because we may want to have a policy that issues one\n   * distribution for each interval in the history of the project.\n   *\n   * If there were never any distributions, then null will be returned.\n   */lastDistributionTimestamp(){return this._lastDistributionTimestamp;}_processAction(action){switch(action.type){case\"CREATE_IDENTITY\":this._createIdentity(action);break;case\"RENAME_IDENTITY\":this._renameIdentity(action);break;case\"ADD_ALIAS\":this._addAlias(action);break;case\"MERGE_IDENTITIES\":this._mergeIdentities(action);break;case\"TOGGLE_ACTIVATION\":this._toggleActivation(action);break;case\"DISTRIBUTE_GRAIN\":this._distributeGrain(action);break;case\"TRANSFER_GRAIN\":this._transferGrain(action);break;case\"CHANGE_IDENTITY_TYPE\":this._changeIdentityType(action);break;case\"SET_PAYOUT_ADDRESS\":this._setPayoutAddress(action);break;case\"ENABLE_GRAIN_INTEGRATION\":this._enableGrainIntegrationTracking(action);break;case\"DISABLE_GRAIN_INTEGRATION\":this._disableGrainIntegrationTracking(action);break;case\"MARK_DISTRIBUTION_EXECUTED\":this._markDistributionExecuted(action);break;// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(\"Unknown type: \".concat(action.type));}}_processEvent(e){const{action,ledgerTimestamp}=e;if(ledgerTimestamp==null||!isFinite(ledgerTimestamp)){throw new Error(\"ledger: invalid timestamp \".concat(ledgerTimestamp));}if(ledgerTimestamp<this._latestTimestamp){throw new Error(\"ledger: out-of-order timestamp: \".concat(ledgerTimestamp,\" < \").concat(this._latestTimestamp));}this._processAction(action);this._latestTimestamp=ledgerTimestamp;this._ledgerEventLog.append(e);}_createAndProcessEvent(action){const ledgerTimestamp=_getTimestamp();const ledgerEvent={ledgerTimestamp,action,version:\"1\",uuid:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"random\"]()};this._processEvent(ledgerEvent);}// Helper method for recording that Grain was allocated to a identity.\n// Increases the identity's paid amount and balance in sync.\n_allocateGrain(params){const account=this._mutableAccount(params.grainReceipt.id);account.paid=_grain__WEBPACK_IMPORTED_MODULE_7__[\"add\"](params.grainReceipt.amount,account.paid);account.allocationHistory.push(params);account.balance=_grain__WEBPACK_IMPORTED_MODULE_7__[\"add\"](params.grainReceipt.amount,account.balance);}}const createIdentityParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"CREATE_IDENTITY\"]),identity:_identity__WEBPACK_IMPORTED_MODULE_0__[\"identityParser\"]});const renameIdentityParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"RENAME_IDENTITY\"]),identityId:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"],newName:_identity__WEBPACK_IMPORTED_MODULE_0__[\"nameParser\"]});const changeIdentityTypeParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"CHANGE_IDENTITY_TYPE\"]),identityId:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"],newType:_identity__WEBPACK_IMPORTED_MODULE_0__[\"identityTypeParser\"]});const addAliasParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"ADD_ALIAS\"]),identityId:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"],alias:_identity__WEBPACK_IMPORTED_MODULE_0__[\"aliasParser\"]});const mergeIdentitiesParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"MERGE_IDENTITIES\"]),base:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"],target:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"]});const toggleActivationParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"TOGGLE_ACTIVATION\"]),identityId:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"]});const distributeGrainParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"DISTRIBUTE_GRAIN\"]),distribution:_distribution__WEBPACK_IMPORTED_MODULE_5__[\"parser\"]});const setPayoutAddressParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"SET_PAYOUT_ADDRESS\"]),id:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"],currency:_currency__WEBPACK_IMPORTED_MODULE_1__[\"currencyParser\"],payoutAddress:_plugins_ethereum_ethAddress__WEBPACK_IMPORTED_MODULE_6__[\"ethAddressParser\"]});const transferGrainParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"TRANSFER_GRAIN\"]),from:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"],to:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"],amount:_grain__WEBPACK_IMPORTED_MODULE_7__[\"parser\"],memo:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"orElse\"]([_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"string\"],_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"null_\"]])});const enableGrainIntegrationParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"ENABLE_GRAIN_INTEGRATION\"])});const disableGrainIntegrationParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"DISABLE_GRAIN_INTEGRATION\"])});const executeDistributionParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({type:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"MARK_DISTRIBUTION_EXECUTED\"]),id:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"]});const actionParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"orElse\"]([createIdentityParser,renameIdentityParser,changeIdentityTypeParser,addAliasParser,mergeIdentitiesParser,toggleActivationParser,distributeGrainParser,transferGrainParser,setPayoutAddressParser,enableGrainIntegrationParser,disableGrainIntegrationParser,executeDistributionParser]);const ledgerEventParser=_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"object\"]({action:actionParser,ledgerTimestamp:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"number\"],version:_util_combo__WEBPACK_IMPORTED_MODULE_9__[\"exactly\"]([\"1\"]),uuid:_util_uuid__WEBPACK_IMPORTED_MODULE_4__[\"parser\"]});const _getTimestamp=()=>Date.now();\n\n//# sourceURL=webpack:///./src/core/ledger/ledger.js?");

/***/ }),

/***/ "./src/core/ledger/nonnegativeGrain.js":
/*!*********************************************!*\
  !*** ./src/core/ledger/nonnegativeGrain.js ***!
  \*********************************************/
/*! exports provided: fromGrain, fromInteger, fromString, fromFloatString, grainParser, numberParser, numberOrFloatStringParser, stringParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromGrain\", function() { return fromGrain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromInteger\", function() { return fromInteger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromString\", function() { return fromString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromFloatString\", function() { return fromFloatString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"grainParser\", function() { return grainParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"numberParser\", function() { return numberParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"numberOrFloatStringParser\", function() { return numberOrFloatStringParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringParser\", function() { return stringParser; });\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/**\n * The NonnegativeGrain type ensures Grain amount is >= 0,\n * which is particularly useful in the case of policy budgets\n * or grain transfers.\n */function fromGrain(g){if(_grain__WEBPACK_IMPORTED_MODULE_0__[\"lt\"](g,_grain__WEBPACK_IMPORTED_MODULE_0__[\"ZERO\"])){throw new Error(\"Grain amount must be nonnegative, got \".concat(g));}return g;}function fromInteger(n){return fromGrain(_grain__WEBPACK_IMPORTED_MODULE_0__[\"fromInteger\"](n));}function fromString(s){return fromGrain(_grain__WEBPACK_IMPORTED_MODULE_0__[\"fromString\"](s));}function fromFloatString(s){return fromGrain(_grain__WEBPACK_IMPORTED_MODULE_0__[\"fromFloatString\"](s));}const grainParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_grain__WEBPACK_IMPORTED_MODULE_0__[\"parser\"],fromGrain);const numberParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],fromInteger);const numberOrFloatStringParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"]([_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"integer\"],fromInteger),_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"],fromFloatString)]);const stringParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"],fromString);\n\n//# sourceURL=webpack:///./src/core/ledger/nonnegativeGrain.js?");

/***/ }),

/***/ "./src/core/ledger/policies/balanced.js":
/*!**********************************************!*\
  !*** ./src/core/ledger/policies/balanced.js ***!
  \**********************************************/
/*! exports provided: balancedReceipts, balancedRawParser, balancedConfigParser, balancedPolicyParser, toString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"balancedReceipts\", function() { return balancedReceipts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"balancedRawParser\", function() { return balancedRawParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"balancedConfigParser\", function() { return balancedConfigParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"balancedPolicyParser\", function() { return balancedPolicyParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toString\", function() { return toString; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../nonnegativeGrain */ \"./src/core/ledger/nonnegativeGrain.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * Allocate a fixed budget of Grain to the users who were \"most underpaid\".\n *\n * We consider a user underpaid if they have received a smaller proportion of\n * past earnings than their share of score. They are balanced paid if their\n * proportion of earnings is equal to their score share, and they are overpaid\n * if their proportion of earnings is higher than their share of the score.\n *\n * We start by imagining a hypothetical world, where the entire grain supply of\n * the project (including this allocation) was allocated according to the\n * current scores. Based on this, we can calculate the \"balanced\" lifetime earnings\n * for each participant. Usually, some will be \"underpaid\" (they received less\n * than this amount) and others are \"overpaid\".\n *\n * We can sum across all users who were underpaid to find the \"total\n * underpayment\".\n *\n * Now that we've calculated each actor's underpayment, and the total\n * underpayment, we divide the allocation's grain budget across users in\n * proportion to their underpayment.\n *\n * You should use this allocation when you want to divide a fixed budget of grain\n * across participants in a way that aligns long-term payment with total cred\n * scores.\n */function balancedReceipts(policy,credGrainView,effectiveTimestamp){if(policy.numIntervalsLookback<0){throw new Error(\"numIntervalsLookback must be at least 0, got \".concat(policy.numIntervalsLookback));}if(!Number.isInteger(policy.numIntervalsLookback)){throw new Error(\"numIntervalsLookback must be an integer, got \".concat(policy.numIntervalsLookback));}const timeLimitedCredGrainView=credGrainView.withTimeScopeFromLookback(effectiveTimestamp,policy.numIntervalsLookback);const timeLimitedParticipants=timeLimitedCredGrainView.activeParticipants();const totalCred=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(timeLimitedParticipants.map(participant=>participant.cred));const totalEverPaid=_grain__WEBPACK_IMPORTED_MODULE_1__[\"sum\"](timeLimitedParticipants.map(participant=>participant.grainEarned));const targetTotalDistributed=_grain__WEBPACK_IMPORTED_MODULE_1__[\"add\"](totalEverPaid,policy.budget);const targetGrainPerCred=_grain__WEBPACK_IMPORTED_MODULE_1__[\"multiplyFloat\"](targetTotalDistributed,1/totalCred);const userUnderpayment=timeLimitedParticipants.map(participant=>{const lookbackCred=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(participant.credPerInterval);const target=_grain__WEBPACK_IMPORTED_MODULE_1__[\"multiplyFloat\"](targetGrainPerCred,lookbackCred);if(_grain__WEBPACK_IMPORTED_MODULE_1__[\"gt\"](target,participant.grainEarned)){return _grain__WEBPACK_IMPORTED_MODULE_1__[\"sub\"](target,participant.grainEarned);}else{return _grain__WEBPACK_IMPORTED_MODULE_1__[\"ZERO\"];}});const floatUnderpayment=userUnderpayment.map(x=>Number(x));const grainAmounts=_grain__WEBPACK_IMPORTED_MODULE_1__[\"splitBudget\"](policy.budget,floatUnderpayment);return timeLimitedParticipants.map((_ref,i)=>{let{identity}=_ref;return{id:identity.id,amount:grainAmounts[i]};});}const balancedRawParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"exactly\"]([\"BALANCED\"]),budget:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"orElse\"]([_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"string\"],_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]]),numIntervalsLookback:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]});const balancedConfigParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"exactly\"]([\"BALANCED\"]),budget:_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__[\"numberOrFloatStringParser\"],numIntervalsLookback:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]});const balancedPolicyParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"exactly\"]([\"BALANCED\"]),budget:_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__[\"grainParser\"]},{numIntervalsLookback:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]}),policy=>_objectSpread(_objectSpread({},policy),{},{numIntervalsLookback:policy.numIntervalsLookback!=null?policy.numIntervalsLookback:0}));function toString(policy){return[policy.policyType+\" Policy\",\"Budget \"+_grain__WEBPACK_IMPORTED_MODULE_1__[\"format\"](policy.budget,3)].join(\"\\n\");}\n\n//# sourceURL=webpack:///./src/core/ledger/policies/balanced.js?");

/***/ }),

/***/ "./src/core/ledger/policies/immediate.js":
/*!***********************************************!*\
  !*** ./src/core/ledger/policies/immediate.js ***!
  \***********************************************/
/*! exports provided: immediateReceipts, immediateRawParser, immediateConfigParser, immediatePolicyParser, toString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"immediateReceipts\", function() { return immediateReceipts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"immediateRawParser\", function() { return immediateRawParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"immediateConfigParser\", function() { return immediateConfigParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"immediatePolicyParser\", function() { return immediatePolicyParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toString\", function() { return toString; });\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _nonnegativeGrain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../nonnegativeGrain */ \"./src/core/ledger/nonnegativeGrain.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * Split a grain budget in proportion to the cred scores in\n * the most recent time interval, with the option to extend the interval\n * to include the last {numIntervalsLookback} weeks.\n */function immediateReceipts(policy,credGrainView,effectiveTimestamp){// Default to 1 interval to preserve back-compat with old ledger events\nif(policy.numIntervalsLookback<1){throw new Error(\"numIntervalsLookback must be at least 1, got \".concat(policy.numIntervalsLookback));}if(!Number.isInteger(policy.numIntervalsLookback)){throw new Error(\"numIntervalsLookback must be an integer, got \".concat(policy.numIntervalsLookback));}const timeLimitedCredGrainView=credGrainView.withTimeScopeFromLookback(effectiveTimestamp,policy.numIntervalsLookback);const timeLimitedParticipants=timeLimitedCredGrainView.activeParticipants();const shortTermCredPerIdentity=timeLimitedParticipants.map(p=>p.cred);const amounts=_grain__WEBPACK_IMPORTED_MODULE_0__[\"splitBudget\"](policy.budget,shortTermCredPerIdentity);return timeLimitedParticipants.map((_ref,i)=>{let{identity}=_ref;return{id:identity.id,amount:amounts[i]};});}const immediateRawParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"exactly\"]([\"IMMEDIATE\"]),budget:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"]([_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"],_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"]]),numIntervalsLookback:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"]});const immediateConfigParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"exactly\"]([\"IMMEDIATE\"]),budget:_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_2__[\"numberOrFloatStringParser\"],numIntervalsLookback:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"]});const immediatePolicyParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"exactly\"]([\"IMMEDIATE\"]),budget:_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_2__[\"grainParser\"]},{numIntervalsLookback:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"]}),policy=>_objectSpread(_objectSpread({},policy),{},{numIntervalsLookback:policy.numIntervalsLookback!=null?policy.numIntervalsLookback:1}));function toString(policy){return[policy.policyType+\" Policy\",\"Budget \"+_grain__WEBPACK_IMPORTED_MODULE_0__[\"format\"](policy.budget,3)].join(\"\\n\");}\n\n//# sourceURL=webpack:///./src/core/ledger/policies/immediate.js?");

/***/ }),

/***/ "./src/core/ledger/policies/index.js":
/*!*******************************************!*\
  !*** ./src/core/ledger/policies/index.js ***!
  \*******************************************/
/*! exports provided: balancedReceipts, balancedPolicyParser, immediateReceipts, immediatePolicyParser, recentReceipts, recentPolicyParser, specialReceipts, specialPolicyParser, allocationConfigParser, policyConfigParser, allocationPolicyParser, toString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"allocationConfigParser\", function() { return allocationConfigParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"policyConfigParser\", function() { return policyConfigParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"allocationPolicyParser\", function() { return allocationPolicyParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toString\", function() { return toString; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _balanced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./balanced */ \"./src/core/ledger/policies/balanced.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"balancedReceipts\", function() { return _balanced__WEBPACK_IMPORTED_MODULE_1__[\"balancedReceipts\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"balancedPolicyParser\", function() { return _balanced__WEBPACK_IMPORTED_MODULE_1__[\"balancedPolicyParser\"]; });\n\n/* harmony import */ var _immediate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./immediate */ \"./src/core/ledger/policies/immediate.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"immediateReceipts\", function() { return _immediate__WEBPACK_IMPORTED_MODULE_2__[\"immediateReceipts\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"immediatePolicyParser\", function() { return _immediate__WEBPACK_IMPORTED_MODULE_2__[\"immediatePolicyParser\"]; });\n\n/* harmony import */ var _recent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./recent */ \"./src/core/ledger/policies/recent.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"recentReceipts\", function() { return _recent__WEBPACK_IMPORTED_MODULE_3__[\"recentReceipts\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"recentPolicyParser\", function() { return _recent__WEBPACK_IMPORTED_MODULE_3__[\"recentPolicyParser\"]; });\n\n/* harmony import */ var _special__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./special */ \"./src/core/ledger/policies/special.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"specialReceipts\", function() { return _special__WEBPACK_IMPORTED_MODULE_4__[\"specialReceipts\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"specialPolicyParser\", function() { return _special__WEBPACK_IMPORTED_MODULE_4__[\"specialPolicyParser\"]; });\n\n// Simply verifies and types what is in a config with no mutations.\nconst allocationConfigParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"]([_balanced__WEBPACK_IMPORTED_MODULE_1__[\"balancedRawParser\"],_immediate__WEBPACK_IMPORTED_MODULE_2__[\"immediateRawParser\"],_recent__WEBPACK_IMPORTED_MODULE_3__[\"recentRawParser\"],_special__WEBPACK_IMPORTED_MODULE_4__[\"specialRawParser\"]]);// Mutates a config into a policy.\nconst policyConfigParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"]([_balanced__WEBPACK_IMPORTED_MODULE_1__[\"balancedConfigParser\"],_immediate__WEBPACK_IMPORTED_MODULE_2__[\"immediateConfigParser\"],_recent__WEBPACK_IMPORTED_MODULE_3__[\"recentConfigParser\"],_special__WEBPACK_IMPORTED_MODULE_4__[\"specialConfigParser\"]]);// Verifies and possibly mutates a serialized policy into a\n// deserialized policy. This is for use with the ledger log.\nconst allocationPolicyParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"]([_balanced__WEBPACK_IMPORTED_MODULE_1__[\"balancedPolicyParser\"],_immediate__WEBPACK_IMPORTED_MODULE_2__[\"immediatePolicyParser\"],_recent__WEBPACK_IMPORTED_MODULE_3__[\"recentPolicyParser\"],_special__WEBPACK_IMPORTED_MODULE_4__[\"specialPolicyParser\"]]);function toString(policy){switch(policy.policyType){case\"BALANCED\":return Object(_balanced__WEBPACK_IMPORTED_MODULE_1__[\"toString\"])(policy);case\"IMMEDIATE\":return Object(_immediate__WEBPACK_IMPORTED_MODULE_2__[\"toString\"])(policy);case\"RECENT\":return Object(_recent__WEBPACK_IMPORTED_MODULE_3__[\"toString\"])(policy);case\"SPECIAL\":return Object(_special__WEBPACK_IMPORTED_MODULE_4__[\"toString\"])(policy);}}\n\n//# sourceURL=webpack:///./src/core/ledger/policies/index.js?");

/***/ }),

/***/ "./src/core/ledger/policies/recent.js":
/*!********************************************!*\
  !*** ./src/core/ledger/policies/recent.js ***!
  \********************************************/
/*! exports provided: recentReceipts, recentRawParser, recentConfigParser, recentPolicyParser, toDiscount, toString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"recentReceipts\", function() { return recentReceipts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"recentRawParser\", function() { return recentRawParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"recentConfigParser\", function() { return recentConfigParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"recentPolicyParser\", function() { return recentPolicyParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toDiscount\", function() { return toDiscount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toString\", function() { return toString; });\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _nonnegativeGrain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../nonnegativeGrain */ \"./src/core/ledger/nonnegativeGrain.js\");\n/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../identity */ \"./src/core/identity/index.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * The Recent policy distributes cred using a time discount factor, weighing\n * recent contributions higher. The policy takes a history of cred scores, progressively\n * discounting past cred scores, and then taking the sum over the discounted scores.\n *\n * A cred score at time t reads as follows: \"The discounted cred c' at a timestep which is\n * n timesteps back from the most recent one is its cred score c multiplied by the discount\n * factor to the nth power.\"\n *\n * c' =  c * (1 - discount) ** n\n *\n * Discounts range from 0 to 1, with a higher discount weighing recent contribution\n * higher.\n *\n * Note that this is a generalization of the Immediate policy, where Immediate\n * is the same as Recent with a full discount, i.e. a discount factor 1 (100%).\n *\n */ /**\n * Split a grain budget based on exponentially weighted recent\n * cred.\n */function recentReceipts(policy,credGrainView,effectiveTimestamp){const lookback=0;const timeLimitedCredGrainView=credGrainView.withTimeScopeFromLookback(effectiveTimestamp,lookback);const timeLimitedParticipants=timeLimitedCredGrainView.activeParticipants().filter(participant=>!policy.exclusions.includes(participant.identity.id));const computeDecayedCred=participant=>{return participant.credPerInterval.reduce((acc,cred)=>acc*(1-policy.discount)+cred,0);};const decayedCredPerIdentity=timeLimitedParticipants.map(computeDecayedCred);const amounts=_grain__WEBPACK_IMPORTED_MODULE_0__[\"splitBudget\"](policy.budget,decayedCredPerIdentity);return timeLimitedParticipants.map((_ref,i)=>{let{identity}=_ref;return{id:identity.id,amount:amounts[i]};});}const recentRawParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"exactly\"]([\"RECENT\"]),budget:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"]([_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"],_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"]]),discount:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],toDiscount)},{exclusions:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"array\"](_identity__WEBPACK_IMPORTED_MODULE_3__[\"delimitedIdentityIdParser\"])});const recentConfigParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"exactly\"]([\"RECENT\"]),budget:_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_2__[\"numberOrFloatStringParser\"],discount:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],toDiscount)},{exclusions:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"array\"](_identity__WEBPACK_IMPORTED_MODULE_3__[\"delimitedIdentityIdParser\"])}),config=>_objectSpread(_objectSpread({},config),{},{exclusions:config.exclusions||[]}));const recentPolicyParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"exactly\"]([\"RECENT\"]),budget:_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_2__[\"grainParser\"],discount:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],toDiscount)},{exclusions:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"array\"](_identity__WEBPACK_IMPORTED_MODULE_3__[\"delimitedIdentityIdParser\"])}),config=>_objectSpread(_objectSpread({},config),{},{exclusions:config.exclusions||[]}));function toDiscount(n){if(n<0||n>1){throw new Error(\"Discount must be in range [0,1]\");}return n;}function toString(policy){return[policy.policyType+\" Policy\",\"Budget \"+_grain__WEBPACK_IMPORTED_MODULE_0__[\"format\"](policy.budget,3),\"Discount: \"+policy.discount].join(\"\\n\");}\n\n//# sourceURL=webpack:///./src/core/ledger/policies/recent.js?");

/***/ }),

/***/ "./src/core/ledger/policies/special.js":
/*!*********************************************!*\
  !*** ./src/core/ledger/policies/special.js ***!
  \*********************************************/
/*! exports provided: specialReceipts, specialRawParser, specialConfigParser, specialPolicyParser, toString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"specialReceipts\", function() { return specialReceipts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"specialRawParser\", function() { return specialRawParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"specialConfigParser\", function() { return specialConfigParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"specialPolicyParser\", function() { return specialPolicyParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toString\", function() { return toString; });\n/* harmony import */ var _util_uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/uuid */ \"./src/util/uuid.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grain */ \"./src/core/ledger/grain.js\");\n/* harmony import */ var _nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../nonnegativeGrain */ \"./src/core/ledger/nonnegativeGrain.js\");\n/**\n * The Special policy is a power-maintainer tool for directly paying Grain\n * to a target identity. I'm including it because we will use it to create\n * \"initialization\" payouts to contributors with prior Grain balances in our old\n * ledger.\n *\n * This has potential for abuse, I don't recommend making it easy to make special\n * payouts from the UI, since it subverts the \"Grain comes from Cred\" model.\n */function specialReceipts(policy,identities){for(const{id}of identities){if(id===policy.recipient){return[{id,amount:policy.budget}];}}throw new Error(\"no active grain account for identity: \".concat(policy.recipient));}const specialRawParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"exactly\"]([\"SPECIAL\"]),budget:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"]([_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"],_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"]]),memo:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"],recipient:_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"parser\"]});const specialConfigParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"exactly\"]([\"SPECIAL\"]),budget:_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__[\"numberOrFloatStringParser\"],memo:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"],recipient:_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"parser\"]});const specialPolicyParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({policyType:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"exactly\"]([\"SPECIAL\"]),budget:_nonnegativeGrain__WEBPACK_IMPORTED_MODULE_3__[\"grainParser\"],memo:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"],recipient:_util_uuid__WEBPACK_IMPORTED_MODULE_0__[\"parser\"]});function toString(policy){return[policy.policyType+\" Policy\",\"Budget \"+_grain__WEBPACK_IMPORTED_MODULE_2__[\"format\"](policy.budget,3),\"Memo: \"+policy.memo,\"Recepient: \"+policy.recipient].join(\"\\n\");}\n\n//# sourceURL=webpack:///./src/core/ledger/policies/special.js?");

/***/ }),

/***/ "./src/core/mintBudget.js":
/*!********************************!*\
  !*** ./src/core/mintBudget.js ***!
  \********************************/
/*! exports provided: intervalLengthParser, applyBudget, _computeReweighting, _reweightingForEntry, _reweightGraph, _anyCommonPrefixes, _findCurrentBudgetValue, _computeWeightNormalizer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intervalLengthParser\", function() { return intervalLengthParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyBudget\", function() { return applyBudget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_computeReweighting\", function() { return _computeReweighting; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_reweightingForEntry\", function() { return _reweightingForEntry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_reweightGraph\", function() { return _reweightGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_anyCommonPrefixes\", function() { return _anyCommonPrefixes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_findCurrentBudgetValue\", function() { return _findCurrentBudgetValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_computeWeightNormalizer\", function() { return _computeWeightNormalizer; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ \"d3-array\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_findlast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.findlast */ \"lodash.findlast\");\n/* harmony import */ var lodash_findlast__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_findlast__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _weights__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./weights */ \"./src/core/weights.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./graph */ \"./src/core/graph.js\");\n/* harmony import */ var _algorithm_weightEvaluator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./algorithm/weightEvaluator */ \"./src/core/algorithm/weightEvaluator.js\");\n/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interval */ \"./src/core/interval.js\");\nconst intervalLengthParser=_util_combo__WEBPACK_IMPORTED_MODULE_4__[\"exactly\"]([\"WEEKLY\"]);/**\n * Given a WeightedGraph and a budget, return a new WeightedGraph which ensures\n * that the budget constraint is satisfied.\n *\n * Concretely, this means that the weights in the Graph may be reduced, as\n * necessary, in order to bring the total minted Cred within an interval down\n * to the budget's requirements.\n */function applyBudget(wg,budget){// It'd be really nice to support the case where some budgets are subsets of\n// other budgets. As an example, imagine saying: The GitHub plugin can mint\n// at most 1000 Cred per week, and within that, this particular GitHub repo\n// can mint at most 200, that one can mint at most 400, etc. However, I\n// didn't want to figure out the math for solving those constraints just yet,\n// since the initial use case of limiting minting per plugin doesn't need to\n// worry about intersections between the budgets.\n//\n// So let's just throw an error if there are any overlapping prefixes for\n// now, and we can improve the implementation later once we want to do more\n// sophisticated budget policies.\nif(_anyCommonPrefixes(budget.entries.map(x=>x.prefix))){throw new Error(\"budget prefix conflict detected\");}if(budget.intervalLength!==\"WEEKLY\"){throw new Error(\"non-weekly budgets not supported\");}const reweighting=_computeReweighting(wg,budget);return _reweightGraph(wg,reweighting);}/**\n * Given the WeightedGraph and the Budget, returns an array of every {addres,\n * weight} pair where the address needs to be re-weighted in order to satisfy\n * the budget constraint.\n */function _computeReweighting(wg,budget){const evaluator=Object(_algorithm_weightEvaluator__WEBPACK_IMPORTED_MODULE_6__[\"nodeWeightEvaluator\"])(wg.weights);const partition=Object(_interval__WEBPACK_IMPORTED_MODULE_7__[\"partitionGraph\"])(wg.graph);const reweightingsForEachBudget=budget.entries.map(entry=>_reweightingForEntry({evaluator,partition,entry}));return[].concat(...reweightingsForEachBudget);}/**\n * Given a the time-partitioned graph, the weight evaluator, and a particular\n * entry for the budget, return every {address, weight} pair where the\n * corresponding address needs to be reweighted in order to satisfy this budget\n * entry.\n */function _reweightingForEntry(args){const{evaluator,partition,entry}=args;const{periods,prefix}=entry;// Check that the budget's periods are in time-sorted order.\nif(!inSortedOrder(periods.map(x=>x.startTimeMs))){throw new Error(\"budget for \".concat(_graph__WEBPACK_IMPORTED_MODULE_5__[\"NodeAddress\"].toString(prefix),\" has periods out-of-order\"));}const results=[];for(const{interval,nodes}of partition){const budgetValue=_findCurrentBudgetValue(periods,interval.startTimeMs);const addresses=nodes.map(n=>n.address);const filteredAddresses=addresses.filter(a=>_graph__WEBPACK_IMPORTED_MODULE_5__[\"NodeAddress\"].hasPrefix(a,prefix));const addressWeights=filteredAddresses.map(a=>({address:a,weight:evaluator(a)}));const normalizer=_computeWeightNormalizer(addressWeights,budgetValue);// If the normalizer is exactly 1, no re-weighting is necessary.\nif(normalizer!==1){// Re-weight every address matching this budget entry\n// equally.\nfor(const address of filteredAddresses){results.push({address,weight:normalizer});}}}return results;}/**\n * Given a WeightedGraph and the reweighting, return a new WeightedGraph which\n * has had its weights updated accordingly, without mutating the original\n * WeightedGraph.\n */function _reweightGraph(wg,reweighting){const newWeights=_weights__WEBPACK_IMPORTED_MODULE_3__[\"copy\"](wg.weights);for(const{address,weight}of reweighting){const existingWeight=_util_null__WEBPACK_IMPORTED_MODULE_2__[\"orElse\"](wg.weights.nodeWeights.get(address),1);newWeights.nodeWeights.set(address,existingWeight*weight);}return{graph:wg.graph.copy(),weights:newWeights};}/**\n * Given an array of node addresses, return true if any node address is a prefix\n * of another address.\n *\n * This method runs in O(n^2). This should be fine because it's intended to be\n * run on small arrays (~one per plugin). If this becomes a performance\n * hotpsot, we can write a more performant version.\n */function _anyCommonPrefixes(addresses){for(let i=0;i<addresses.length;i++){for(let j=i;j<addresses.length;j++){if(i===j){continue;}// Check both if A is prefix of B and if B is prefix of A\n// (not symmetrical)\nif(_graph__WEBPACK_IMPORTED_MODULE_5__[\"NodeAddress\"].hasPrefix(addresses[i],addresses[j])){return true;}if(_graph__WEBPACK_IMPORTED_MODULE_5__[\"NodeAddress\"].hasPrefix(addresses[j],addresses[i])){return true;}}}return false;}function inSortedOrder(xs){let last=-Infinity;for(const x of xs){if(x<last){return false;}last=x;}return true;}// Given an array of periods, and a timestamp, choose the last period whose\n// startTimeMs is <= the timestamp, and then return its budget. Returns\n// Infinity if there is no matching budget.\nfunction _findCurrentBudgetValue(periods,timestamp){const currentPeriod=lodash_findlast__WEBPACK_IMPORTED_MODULE_1___default()(periods,period=>period.startTimeMs<=timestamp);return currentPeriod?currentPeriod.budgetValue:Infinity;}// For the given array of AddressWeights, and a budget that they must fit within, return\n// a normalization coefficient which can be used to reweight all of these AddressWeights\n// so that they fit within the budget. Will be a number in the range [0, 1], where 0\n// implies the budget is 0 (so everything gets set to 0) and 1 implies the AddressWeights\n// are already fitting within the budget.\nfunction _computeWeightNormalizer(aws,budgetValue){const totalWeight=Object(d3_array__WEBPACK_IMPORTED_MODULE_0__[\"sum\"])(aws,aw=>aw.weight);if(totalWeight<=budgetValue){return 1;}else{return budgetValue/totalWeight;}}\n\n//# sourceURL=webpack:///./src/core/mintBudget.js?");

/***/ }),

/***/ "./src/core/references/cascadingReferenceDetector.js":
/*!***********************************************************!*\
  !*** ./src/core/references/cascadingReferenceDetector.js ***!
  \***********************************************************/
/*! exports provided: CascadingReferenceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CascadingReferenceDetector\", function() { return CascadingReferenceDetector; });\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * A class for composing ReferenceDetectors. Calls ReferenceDetectors in the order\n * they're given in the constructor, returning the first NodeAddressT it encounters.\n */class CascadingReferenceDetector{constructor(refs){_defineProperty(this,\"refs\",void 0);this.refs=refs;}addressFromUrl(url){for(const ref of this.refs){const addr=ref.addressFromUrl(url);if(addr)return addr;}}}\n\n//# sourceURL=webpack:///./src/core/references/cascadingReferenceDetector.js?");

/***/ }),

/***/ "./src/core/references/index.js":
/*!**************************************!*\
  !*** ./src/core/references/index.js ***!
  \**************************************/
/*! exports provided: MappedReferenceDetector, CascadingReferenceDetector, TranslatingReferenceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mappedReferenceDetector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mappedReferenceDetector */ \"./src/core/references/mappedReferenceDetector.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MappedReferenceDetector\", function() { return _mappedReferenceDetector__WEBPACK_IMPORTED_MODULE_0__[\"MappedReferenceDetector\"]; });\n\n/* harmony import */ var _cascadingReferenceDetector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cascadingReferenceDetector */ \"./src/core/references/cascadingReferenceDetector.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CascadingReferenceDetector\", function() { return _cascadingReferenceDetector__WEBPACK_IMPORTED_MODULE_1__[\"CascadingReferenceDetector\"]; });\n\n/* harmony import */ var _translatingReferenceDetector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./translatingReferenceDetector */ \"./src/core/references/translatingReferenceDetector.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TranslatingReferenceDetector\", function() { return _translatingReferenceDetector__WEBPACK_IMPORTED_MODULE_2__[\"TranslatingReferenceDetector\"]; });\n\n\n\n//# sourceURL=webpack:///./src/core/references/index.js?");

/***/ }),

/***/ "./src/core/references/mappedReferenceDetector.js":
/*!********************************************************!*\
  !*** ./src/core/references/mappedReferenceDetector.js ***!
  \********************************************************/
/*! exports provided: MappedReferenceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MappedReferenceDetector\", function() { return MappedReferenceDetector; });\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * A reference detector which uses a pregenerated `Map<URL, NodeAddressT>` as a\n * lookup table.\n *\n * Note: this is sensitive to canonicalization issues because it's based on string\n * comparisons. For example:\n * - \"http://foo.bar/123\" != \"http://foo.bar/123#chapter-2\"\n * - \"http://foo.bar/?a=1&b=2\" != \"http://foo.bar/?b=2&a=1\"\n * - \"http://foo.bar/space+bar\" != \"http://foo.bar/space%20bar\"\n */class MappedReferenceDetector{constructor(map){_defineProperty(this,\"map\",void 0);this.map=map;}addressFromUrl(url){return this.map.get(url);}}\n\n//# sourceURL=webpack:///./src/core/references/mappedReferenceDetector.js?");

/***/ }),

/***/ "./src/core/references/translatingReferenceDetector.js":
/*!*************************************************************!*\
  !*** ./src/core/references/translatingReferenceDetector.js ***!
  \*************************************************************/
/*! exports provided: TranslatingReferenceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TranslatingReferenceDetector\", function() { return TranslatingReferenceDetector; });\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * A ReferenceDetector which takes a base ReferenceDetector and applies a\n * translate function to any results.\n */class TranslatingReferenceDetector{constructor(base,translate){_defineProperty(this,\"translate\",void 0);_defineProperty(this,\"base\",void 0);this.base=base;this.translate=translate;}addressFromUrl(url){const baseAddr=this.base.addressFromUrl(url);if(!baseAddr)return;return this.translate(baseAddr);}}\n\n//# sourceURL=webpack:///./src/core/references/translatingReferenceDetector.js?");

/***/ }),

/***/ "./src/core/storage/disk.js":
/*!**********************************!*\
  !*** ./src/core/storage/disk.js ***!
  \**********************************/
/*! exports provided: DiskStorage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiskStorage\", function() { return DiskStorage; });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_pathNormalize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/pathNormalize */ \"./src/util/pathNormalize.js\");\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs-extra */ \"fs-extra\");\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs_extra__WEBPACK_IMPORTED_MODULE_2__);\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * Disk Storage abstracts away low-level file I/O operations.\n */class DiskStorage{/**\n   * basePath will resolve to '.' if an empty string is passed in\n   */constructor(basePath){_defineProperty(this,\"_basePath\",void 0);this._basePath=Object(_util_pathNormalize__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(basePath);}/**\n   * The `path` parameter must be relative to the `basePath` set at\n   * construction. Any I/O errors when attempting to read contents at the path\n   * will cause an error to be thrown.\n   */async get(path){const validPath=this._checkPathPrefix(path);return fs_extra__WEBPACK_IMPORTED_MODULE_2___default.a.readFile(validPath);}/**\n   * The `path` parameter must be relative to the `basePath` set at\n   * construction. Any I/O errors when attempting to write contents at the path\n   * will cause an error to be thrown.\n   */async set(path,contents){const validPath=this._checkPathPrefix(path);return fs_extra__WEBPACK_IMPORTED_MODULE_2___default.a.writeFile(validPath,contents);}/**\n   * `path` is a relative file path to the `basePath`. The normalized\n   * result cannot be above the instance's base path. This is ensures that any\n   * attempts at accessing the file system outside of the instance\n   * will cause an error to throw.\n   */_checkPathPrefix(path){const fullPath=Object(_util_pathNormalize__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Object(path__WEBPACK_IMPORTED_MODULE_0__[\"join\"])(this._basePath,path));// Ensure normalized path isn't outside basePath\nif(!(fullPath.startsWith(this._basePath)||this._basePath===\".\")){throw new Error(\"Path construction error; possible path traversal attack\");}return fullPath;}}\n\n//# sourceURL=webpack:///./src/core/storage/disk.js?");

/***/ }),

/***/ "./src/core/storage/index.js":
/*!***********************************!*\
  !*** ./src/core/storage/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./src/core/storage/index.js?");

/***/ }),

/***/ "./src/core/storage/networkStorage.js":
/*!********************************************!*\
  !*** ./src/core/storage/networkStorage.js ***!
  \********************************************/
/*! exports provided: NetworkStorage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NetworkStorage\", function() { return NetworkStorage; });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"./src/core/storage/index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_index__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cross-fetch */ \"cross-fetch\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_1__);\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * This class serves as a simple wrapper for http GET requests using fetch.\n * If an empty string is passed as the base, the base will be interpretted\n * as '.'\n */class NetworkStorage{constructor(base){_defineProperty(this,\"_base\",void 0);this._base=base;}/**\n   * This get method will error if a non-200 or 300-level status was returned,\n   * or if the resource traverses above the base path.\n   */async get(resource){const path=new URL(resource,this._base).href;if(!path.startsWith(this._base))throw new Error(\"Path traversal is not allowed. \".concat(path,\" does not begin with \").concat(this._base,\" -- try adding trailing / to base\"));const result=await cross_fetch__WEBPACK_IMPORTED_MODULE_1___default()(path);if(!result.ok){const error=new Error(\"Error fetching \".concat(resource,\": \").concat(result.status,\" \").concat(result.statusText));error.number=result.status;throw error;}return new Uint8Array(await result.arrayBuffer());}}\n\n//# sourceURL=webpack:///./src/core/storage/networkStorage.js?");

/***/ }),

/***/ "./src/core/storage/originStorage.js":
/*!*******************************************!*\
  !*** ./src/core/storage/originStorage.js ***!
  \*******************************************/
/*! exports provided: OriginStorage, PostableOriginStorage, createPostableLedgerStorage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OriginStorage\", function() { return OriginStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PostableOriginStorage\", function() { return PostableOriginStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPostableLedgerStorage\", function() { return createPostableLedgerStorage; });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"./src/core/storage/index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_index__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_pathNormalize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/pathNormalize */ \"./src/util/pathNormalize.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cross-fetch */ \"cross-fetch\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_3__);\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * This class serves as a simple wrapper for http GET requests using fetch.\n */class OriginStorage{constructor(base){_defineProperty(this,\"_base\",void 0);this._base=Object(_util_pathNormalize__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(base);}/**\n   * This get method will error if a non-200 or 300-level status was returned.\n   */async get(resource){const path=Object(_util_pathNormalize__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(this._base,resource));if(!path.startsWith(this._base)&&(path.startsWith(\"..\")||Object(path__WEBPACK_IMPORTED_MODULE_2__[\"isAbsolute\"])(path)||this._base!==\".\"))throw new Error(\"Path traversal is not allowed. \".concat(path,\" is not a subpath of \").concat(this._base));const result=await cross_fetch__WEBPACK_IMPORTED_MODULE_3___default()(path);if(!result.ok){const error=new Error(\"Error fetching \".concat(resource,\": \").concat(result.status,\" \").concat(result.statusText));error.number=result.status;throw error;}return new Uint8Array(await result.arrayBuffer());}}class PostableOriginStorage extends OriginStorage{constructor(base,headers){super(base);_defineProperty(this,\"_headers\",void 0);this._headers=headers;}async set(path,body){let payload;if(typeof window!==\"undefined\"){payload=new Blob([body.buffer]);}else{payload=body.buffer;}await cross_fetch__WEBPACK_IMPORTED_MODULE_3___default()(path,{headers:this._headers,method:\"POST\",body:payload});}}const createPostableLedgerStorage=base=>{return new PostableOriginStorage(base,{Accept:\"text/plain\",\"Content-Type\":\"text/plain\"});};\n\n//# sourceURL=webpack:///./src/core/storage/originStorage.js?");

/***/ }),

/***/ "./src/core/storage/textEncoding.js":
/*!******************************************!*\
  !*** ./src/core/storage/textEncoding.js ***!
  \******************************************/
/*! exports provided: encode, decode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"encode\", function() { return encode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decode\", function() { return decode; });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_0__);\nlet encoder,decoder;// ensure jest skips this condition\nif(typeof window!==\"undefined\"&&typeof process===\"undefined\"){if(!(window.TextEncoder&&window.TextDecoder)){throw new Error(\"No Encoder classes available.\");}decoder=window.TextDecoder;encoder=window.TextEncoder;}else{// load imported libraries or fallback to globals if imports are unavailable\n/* eslint-disable no-undef */ // $FlowIssue[cannot-resolve-name]\ndecoder=util__WEBPACK_IMPORTED_MODULE_0__[\"TextDecoder\"]||globalThis.TextDecoder;// $FlowIssue[cannot-resolve-name]\nencoder=util__WEBPACK_IMPORTED_MODULE_0__[\"TextEncoder\"]||globalThis.TextEncoder;}// $FlowIssue[incompatible-call]\nconst decode=a=>new decoder().decode(a);const encode=s=>new encoder().encode(s);\n\n//# sourceURL=webpack:///./src/core/storage/textEncoding.js?");

/***/ }),

/***/ "./src/core/storage/zip.js":
/*!*********************************!*\
  !*** ./src/core/storage/zip.js ***!
  \*********************************/
/*! exports provided: ZipStorage, WritableZipStorage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZipStorage\", function() { return ZipStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WritableZipStorage\", function() { return WritableZipStorage; });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"./src/core/storage/index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_index__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pako */ \"pako\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_1__);\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * The ZipStorage class composes with other WritableDataStorage implementations.\n * It compresses `value`s before passing them into the underlying `baseStorage`\n * implementation, and decompresses them upon receit  from `baseStorage`.\n */class ZipStorage{constructor(baseStorage){_defineProperty(this,\"_baseStorage\",void 0);this._baseStorage=baseStorage;}async get(key){const data=await this._baseStorage.get(key);return Object(pako__WEBPACK_IMPORTED_MODULE_1__[\"inflate\"])(data,{to:\"Uint8Array\"});}}class WritableZipStorage extends ZipStorage{constructor(baseStorage){super(baseStorage);_defineProperty(this,\"_baseStorage\",void 0);this._baseStorage=baseStorage;}async set(key,value){this._baseStorage.set(key,Object(pako__WEBPACK_IMPORTED_MODULE_1__[\"deflate\"])(value));}}\n\n//# sourceURL=webpack:///./src/core/storage/zip.js?");

/***/ }),

/***/ "./src/core/trie.js":
/*!**************************!*\
  !*** ./src/core/trie.js ***!
  \**************************/
/*! exports provided: NodeTrie, EdgeTrie */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NodeTrie\", function() { return NodeTrie; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgeTrie\", function() { return EdgeTrie; });\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph */ \"./src/core/graph.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const EMPTY_ENTRY_SYMBOL=Symbol(\"EMPTY\");class BaseTrie{/**\n   * Create an empty trie backed by the given address module.\n   */constructor(m){_defineProperty(this,\"addressModule\",void 0);_defineProperty(this,\"entry\",void 0);this.addressModule=m;this.entry={value:EMPTY_ENTRY_SYMBOL,map:new Map()};}/**\n   * Add key `k` to this trie with value `v`. Return `this`.\n   */add(k,val){const parts=this.addressModule.toParts(k);let entry=this.entry;for(const part of parts){if(!entry.map.has(part)){entry.map.set(part,{map:new Map(),value:EMPTY_ENTRY_SYMBOL});}entry=_util_null__WEBPACK_IMPORTED_MODULE_1__[\"get\"](entry.map.get(part));}if(entry.value!==EMPTY_ENTRY_SYMBOL){throw new Error(\"Tried to overwrite entry at \".concat(this.addressModule.toString(k)));}entry.value=val;return this;}/**\n   * Get the values in this trie along the path to `k`.\n   *\n   * More specifically, this method has the following observable\n   * behavior. Let `inits` be the list of all prefixes of `k`, ordered\n   * by length (shortest to longest). Observe that the length of `inits`\n   * is `n + 1`, where `n` is the number of parts of `k`; `inits` begins\n   * with the empty address and ends with `k` itself. Initialize the\n   * result to an empty array. For each prefix `p` in `inits`, if `p`\n   * was added to this trie with value `v`, then append `v` to\n   * `result`. Return `result`.\n   */get(k){const parts=this.addressModule.toParts(k);const result=[];let entry=this.entry;// nb: if parts has length `n`, there are `n+1` opportunities to add a\n// value to the resultant array, which is correct as there may be `n+1`\n// appropriate values to return: one for each part, and another for the\n// empty address.\nfor(const part of parts){if(entry.value!==EMPTY_ENTRY_SYMBOL){const value=entry.value;result.push(value);}const tmpEntry=entry.map.get(part);if(tmpEntry==null){return result;}else{entry=tmpEntry;}}if(entry.value!==EMPTY_ENTRY_SYMBOL){const value=entry.value;result.push(value);}return result;}/**\n   * Get the last stored value `v` in the path to key `k`.\n   * Returns undefined if no value is available.\n   */getLast(k){const path=this.get(k);return path[path.length-1];}}class NodeTrie extends BaseTrie{constructor(){super(_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"]);}}class EdgeTrie extends BaseTrie{constructor(){super(_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"]);}}\n\n//# sourceURL=webpack:///./src/core/trie.js?");

/***/ }),

/***/ "./src/core/version.js":
/*!*****************************!*\
  !*** ./src/core/version.js ***!
  \*****************************/
/*! exports provided: VERSION_SHORT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION_SHORT\", function() { return VERSION_SHORT; });\nconst packageJson=__webpack_require__(/*! ../../package.json */ \"./package.json\");const VERSION_SHORT=\"v\".concat(packageJson.version);\n\n//# sourceURL=webpack:///./src/core/version.js?");

/***/ }),

/***/ "./src/core/weightedGraph.js":
/*!***********************************!*\
  !*** ./src/core/weightedGraph.js ***!
  \***********************************/
/*! exports provided: empty, toJSON, fromJSON, merge, overrideWeights */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"empty\", function() { return empty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toJSON\", function() { return toJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromJSON\", function() { return fromJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"merge\", function() { return merge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"overrideWeights\", function() { return overrideWeights; });\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph */ \"./src/core/graph.js\");\n/* harmony import */ var _weights__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./weights */ \"./src/core/weights.js\");\n/* harmony import */ var _util_compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/compat */ \"./src/util/compat.js\");\n/** The WeightedGraph a Graph alongside associated Weights\n *\n * Any combination of Weights and Graph can make a valid WeightedGraph. If the\n * Weights contains weights for node or edge addresses that are not present in\n * the graph, then those weights will be ignored. If the graph contains nodes\n * or edges which do not correspond to any weights, then default weights will\n * be inferred.\n */const COMPAT_INFO={type:\"sourcecred/weightedGraph\",version:\"0.1.0\"};/**\n * Create a new, empty WeightedGraph.\n */function empty(){return{graph:new _graph__WEBPACK_IMPORTED_MODULE_0__[\"Graph\"](),weights:_weights__WEBPACK_IMPORTED_MODULE_1__[\"empty\"]()};}function toJSON(w){const graphJSON=w.graph.toJSON();const weightsJSON=_weights__WEBPACK_IMPORTED_MODULE_1__[\"toJSON\"](w.weights);return Object(_util_compat__WEBPACK_IMPORTED_MODULE_2__[\"toCompat\"])(COMPAT_INFO,{graphJSON,weightsJSON});}function fromJSON(j){const{graphJSON,weightsJSON}=Object(_util_compat__WEBPACK_IMPORTED_MODULE_2__[\"fromCompat\"])(COMPAT_INFO,j);const graph=_graph__WEBPACK_IMPORTED_MODULE_0__[\"Graph\"].fromJSON(graphJSON);const weights=_weights__WEBPACK_IMPORTED_MODULE_1__[\"fromJSON\"](weightsJSON);return{graph,weights};}/**\n * Merge multiple WeightedGraphs together.\n *\n * This delegates to the semantics of Graph.merge and Weights.merge.\n */function merge(ws){const graph=_graph__WEBPACK_IMPORTED_MODULE_0__[\"Graph\"].merge(ws.map(w=>w.graph));const weights=_weights__WEBPACK_IMPORTED_MODULE_1__[\"merge\"](ws.map(w=>w.weights));return{graph,weights};}/**\n * Create a new WeightedGraph where default weights have been overriden.\n *\n * This takes a base WeightedGraph along with a set of \"override\" weights. The\n * new graph has the union of both the base and override weights; wherever\n * there is a conflict, the override weights will replace the base weights.\n * This is useful in situations where we want to let the user manually specify\n * some weights, and ensure that the user's decisions will trump any defaults.\n *\n * This method does not mutuate any of the original arguments. For performance\n * reasons, it is not a full copy; the input and output WeightedGraphs have the\n * exact same underlying Graph, which should not be modified.\n */function overrideWeights(wg,overrides){const weights=_weights__WEBPACK_IMPORTED_MODULE_1__[\"merge\"]([wg.weights,overrides],{nodeResolver:(a,b)=>b,edgeResolver:(a,b)=>b});return{graph:wg.graph,weights};}\n\n//# sourceURL=webpack:///./src/core/weightedGraph.js?");

/***/ }),

/***/ "./src/core/weights.js":
/*!*****************************!*\
  !*** ./src/core/weights.js ***!
  \*****************************/
/*! exports provided: edgeWeightParser, empty, copy, merge, parser, toJSON, fromJSON, compareWeights */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeWeightParser\", function() { return edgeWeightParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"empty\", function() { return empty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"merge\", function() { return merge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toJSON\", function() { return toJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromJSON\", function() { return fromJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compareWeights\", function() { return compareWeights; });\n/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.isequal */ \"lodash.isequal\");\n/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/map */ \"./src/util/map.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _util_compat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/compat */ \"./src/util/compat.js\");\n/**\n * Represents the weight for a particular Node (or node address prefix).\n * Weight 1 is the default value and signifies normal importance.\n * Weights are linear, so 2 is twice as important as 1.\n */const edgeWeightParser=_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({forwards:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],backwards:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"]});/**\n * Creates new, empty weights.\n */function empty(){return{nodeWeights:new Map(),edgeWeights:new Map()};}function copy(w){return{nodeWeights:new Map(w.nodeWeights),edgeWeights:new Map(w.edgeWeights)};}/** Merge multiple Weights together.\n *\n * The resultant Weights will have every weight specified by each of the input\n * weights.\n *\n * When there are overlaps (i.e. the same address is present in two or more of\n * the Weights), then the appropriate resolver will be invoked to resolve the\n * conflict. The resolver takes two weights and combines them to return a new\n * weight.\n *\n * When no resolvers are explicitly provided, merge defaults to\n * conservative \"error on conflict\" resolvers.\n */function merge(ws,resolvers){if(resolvers==null){const nodeResolver=(_unused_a,_unused_b)=>{throw new Error(\"node weight conflict detected, but no resolver specified\");};const edgeResolver=(_unused_a,_unused_b)=>{throw new Error(\"edge weight conflict detected, but no resolver specified\");};resolvers={nodeResolver,edgeResolver};}const weights=empty();const{nodeWeights,edgeWeights}=weights;const{nodeResolver,edgeResolver}=resolvers;for(const w of ws){for(const[addr,val]of w.nodeWeights.entries()){const existing=nodeWeights.get(addr);if(existing==null){nodeWeights.set(addr,val);}else{try{nodeWeights.set(addr,nodeResolver(existing,val));}catch(e){throw new Error(\"\".concat(e,\" when resolving \").concat(_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"NodeAddress\"].toString(addr)));}}}for(const[addr,val]of w.edgeWeights.entries()){const existing=edgeWeights.get(addr);if(existing==null){edgeWeights.set(addr,val);}else{try{edgeWeights.set(addr,edgeResolver(existing,val));}catch(e){throw new Error(\"Error \".concat(e,\" when resolving \").concat(_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"EdgeAddress\"].toString(addr)));}}}}return weights;}function serialize_0_2_0(weights){return{nodeWeights:_util_map__WEBPACK_IMPORTED_MODULE_1__[\"toObject\"](weights.nodeWeights),edgeWeights:_util_map__WEBPACK_IMPORTED_MODULE_1__[\"toObject\"](weights.edgeWeights)};}function deserialize_0_2_0(weights){return{nodeWeights:_util_map__WEBPACK_IMPORTED_MODULE_1__[\"fromObject\"](weights.nodeWeights),edgeWeights:_util_map__WEBPACK_IMPORTED_MODULE_1__[\"fromObject\"](weights.edgeWeights)};}const Parse_0_2_0=(()=>{return _util_combo__WEBPACK_IMPORTED_MODULE_2__[\"object\"]({nodeWeights:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"dict\"](_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"number\"],_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"NodeAddress\"].parser),edgeWeights:_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"dict\"](edgeWeightParser,_core_graph__WEBPACK_IMPORTED_MODULE_3__[\"EdgeAddress\"].parser)});})();const COMPAT_INFO={type:\"sourcecred/weights\",version:\"0.2.0\"};const parser=Object(_util_compat__WEBPACK_IMPORTED_MODULE_4__[\"compatibleParser\"])(COMPAT_INFO.type,{\"0.2.0\":_util_combo__WEBPACK_IMPORTED_MODULE_2__[\"fmap\"](Parse_0_2_0,deserialize_0_2_0)});function toJSON(weights){return Object(_util_compat__WEBPACK_IMPORTED_MODULE_4__[\"toCompat\"])(COMPAT_INFO,serialize_0_2_0(weights));}function fromJSON(json){return parser.parseOrThrow(json);}function compareWeights(firstWeights,secondWeights){const nodeWeightDiffs=[];const edgeWeightDiffs=[];const nodeAddresses=new Set([...firstWeights.nodeWeights.keys(),...secondWeights.nodeWeights.keys()]);for(const address of nodeAddresses){const first=firstWeights.nodeWeights.get(address);const second=secondWeights.nodeWeights.get(address);if(!lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(first,second)){nodeWeightDiffs.push({address,first,second});}}const edgeAddresses=new Set([...firstWeights.edgeWeights.keys(),...secondWeights.edgeWeights.keys()]);for(const address of edgeAddresses){const first=firstWeights.edgeWeights.get(address);const second=secondWeights.edgeWeights.get(address);if(!lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(first,second)){edgeWeightDiffs.push({address,first,second});}}const weightsAreEqual=nodeWeightDiffs.length===0&&edgeWeightDiffs.length===0;return{weightsAreEqual,nodeWeightDiffs,edgeWeightDiffs};}\n\n//# sourceURL=webpack:///./src/core/weights.js?");

/***/ }),

/***/ "./src/graphql/mirror.js":
/*!*******************************!*\
  !*** ./src/graphql/mirror.js ***!
  \*******************************/
/*! exports provided: Mirror, _buildSchemaInfo, _FIELD_PREFIXES, _makeSingleUpdateFunction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mirror\", function() { return Mirror; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_buildSchemaInfo\", function() { return _buildSchemaInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_FIELD_PREFIXES\", function() { return _FIELD_PREFIXES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_makeSingleUpdateFunction\", function() { return _makeSingleUpdateFunction; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/map */ \"./src/util/map.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./schema */ \"./src/graphql/schema.js\");\n/* harmony import */ var _queries__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./queries */ \"./src/graphql/queries.js\");\nvar _templateObject,_templateObject2,_templateObject3,_templateObject4,_templateObject5,_templateObject6,_templateObject7,_templateObject8,_templateObject9,_templateObject10,_templateObject11,_templateObject12,_templateObject13,_templateObject14,_templateObject15,_templateObject16,_templateObject17,_templateObject18,_templateObject19,_templateObject20,_templateObject21,_templateObject22,_templateObject23,_templateObject24,_templateObject25,_templateObject26,_templateObject27,_templateObject28,_templateObject29,_templateObject30,_templateObject31,_templateObject32,_templateObject33,_templateObject34,_templateObject35,_templateObject36,_templateObject37;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * A local mirror of a subset of a GraphQL database.\n *\n * Clients should interact with this module as follows:\n *\n *   - Invoke the constructor to acquire a `Mirror` instance.\n *   - Invoke `registerObject` to register a root object of interest.\n *   - Invoke `update` to update all transitive dependencies.\n *   - Invoke `extract` to retrieve the data in structured form.\n *\n * See the relevant methods for documentation.\n */ /*\n * NOTE(perf): The implementation of this class is not particularly\n * optimized. In particular, when we interact with SQLite, we compile\n * our prepared statements many times over the lifespan of an\n * instance. It may be beneficial to precompile them at instance\n * construction time.\n */class Mirror{/**\n   * Create a GraphQL mirror using the given database connection and\n   * GraphQL schema.\n   *\n   * The connection must be to a database that either (a) is empty and\n   * unused, or (b) has been previously used for a GraphQL mirror with\n   * an identical GraphQL schema and options. The database attached to\n   * the connection must not be modified by any other clients. In other\n   * words, passing a connection to this constructor entails\n   * transferring ownership of the attached database to this module.\n   *\n   * If the database attached to the connection has been used with an\n   * incompatible GraphQL schema or an outdated version of this module,\n   * an error will be thrown and the database will remain unmodified.\n   *\n   * If a list of blacklisted IDs is provided, then any object with\n   * matching ID will be treated as `null` when it appears as the target\n   * of a node reference, nested node reference, or connection entry.\n   * This can be used to work around bugs in remote schemas.\n   *\n   * If `guessTypename` is provided, it should attempt to guess the\n   * typename of an object given its ID, returning `null` if no guess\n   * can be made. This will be used as a cross-check against results\n   * returned from the server to provide an early warning in cases where\n   * the results differ, potentially due to server-side contract\n   * violations. This option only affects console warnings, not the\n   * final state of the mirror.\n   */constructor(db,schema,options){_defineProperty(this,\"_db\",void 0);_defineProperty(this,\"_schema\",void 0);_defineProperty(this,\"_schemaInfo\",void 0);_defineProperty(this,\"_blacklistedIds\",void 0);_defineProperty(this,\"_guessTypename\",void 0);if(db==null)throw new Error(\"db: \"+String(db));if(schema==null)throw new Error(\"schema: \"+String(schema));const fullOptions=_objectSpread({blacklistedIds:[],guessTypename:()=>null},options||{});this._db=db;this._schema=schema;this._schemaInfo=_buildSchemaInfo(this._schema);this._blacklistedIds=(()=>{const result={};for(const id of fullOptions.blacklistedIds){result[id]=true;}return result;})();this._guessTypename=fullOptions.guessTypename;this._initialize();}/**\n   * Embed the GraphQL schema into the database, initializing it for use\n   * as a mirror.\n   *\n   * This method should only be invoked once, at construction time.\n   *\n   * If the database has already been initialized with the same schema\n   * and version, no action is taken and no error is thrown. If the\n   * database has been initialized with a different schema or version,\n   * the database is left unchanged, and an error is thrown.\n   *\n   * A discussion of the database structure follows.\n   *\n   * ---\n   *\n   * Objects have three kinds of fields: connections, links, and\n   * primitives. The database likewise has a `connections` table,\n   * `links` table, and `primitives` table, each storing corresponding\n   * data for all GraphQL object types.\n   *\n   * In more detail:\n   *\n   *   - The `connections` table has a row for each `(id, fieldname)`\n   *     pair, where `fieldname` is the name of a connection field on the\n   *     object with the given ID. This stores metadata about the\n   *     connection: its total count, when it was last updated, etc. It\n   *     does not store the actual entries in the connection (the nodes\n   *     that the connection points to); `connection_entries` stores\n   *     these.\n   *\n   *   - The `links` table has a row for each `(id, fieldname)` pair,\n   *     where `fieldname` is the name of a link field on the object\n   *     with the given ID. This simply points to the referenced object.\n   *\n   *   - The `primitives` table has a row for each `(id, fieldname)`\n   *     pair, where `fieldname` is the name of a (non-ID) primitive\n   *     field on the object with the given ID. The `value` column holds\n   *     the JSON-stringified primitive value: so, for instance, the\n   *     JSON value `null` is represented as the SQL string 'null',\n   *     _not_ SQL NULL, while the JSON string \"null\" is represented as\n   *     the SQL string '\"null\"'. This is primarily to accommodate\n   *     storing booleans: SQLite has no boolean storage class, and we\n   *     cannot simply encode `true` and `false` as `1` and `0` because\n   *     we need to be able to distinguish between these respective\n   *     values when we read them back out. There are other ways to do\n   *     this more efficiently in both space and time (see discussion on\n   *     #883 for some options).\n   *\n   * These fields are type-specific, and so only exist once a node's\n   * typename is set.\n   *\n   * We refer to node and primitive data together as \"own data\", because\n   * this is the data that can be queried uniformly for all elements of\n   * a type; querying connection data, by contrast, requires the\n   * object-specific end cursor.\n   *\n   * Nested fields merit additional explanation. The nested field itself\n   * exists on the `primitives` table with SQL value NULL, 0, or 1 (as\n   * SQL integers, not strings). As with all other primitives, `NULL`\n   * indicates that the value has never been fetched. If the value has\n   * been fetched, it is 0 if the nested field itself was `null` on the\n   * GraphQL result, or 1 if it was present. This field lets us\n   * distinguish \"author: null\" from \"author: {user: null}\".\n   *\n   * The \"eggs\" of a nested field are treated as normal primitive or\n   * link values, whose fieldname is the nested fieldname and egg\n   * fieldname joined by a period. So, if object type `Foo` has nested\n   * field `bar: Schema.nested({baz: Schema.primitive()})`, then the\n   * `primitives` table will include a row with fieldname 'bar.baz'.\n   * Likewise, a row in the `links` table might have fieldname\n   * 'quux.zod'.\n   *\n   * All aforementioned tables are keyed by object ID. Each object also\n   * appears once in the `objects` table, which relates its ID,\n   * typename, and last own-data update. Each connection has its own\n   * last-update value, because connections can be updated independently\n   * of each other and of own-data. An object's typename may be `NULL`\n   * if we have only reached the object through edges of unfaithful\n   * type, in which case we will perform an extra query to definitively\n   * determine fetch the object's type before requesting its own data or\n   * connections.\n   *\n   * Note that any object in the database should have entries in the\n   * `connections`, `links`, and `primitives` tables for all relevant\n   * fields, even if the node has never been updated. This is for\n   * convenience of implementation: it means that the first fetch for a\n   * node is the same as subsequent fetches (a simple SQL `UPDATE`\n   * instead of first requiring an existence check).\n   *\n   * A table `network_log` logs all GraphQL requests made by this module\n   * and their corresponding responses, as well as the update created\n   * from the response. This is for debugging. For example, if a node in\n   * the database is corrupt in some way, inspecting the network log\n   * will show exactly which queries caused it to enter its broken\n   * state. In theory, it should be possible to replay the network log\n   * to re-create the database state exactly, though no tooling exists\n   * to do so automatically.\n   *\n   * Finally, a table `meta` is used to store metadata about the mirror\n   * itself. This is used to make sure that the mirror is not loaded\n   * with an incompatible version of the code or schema. It is never\n   * updated after it is first set.\n   */_initialize(){// The following version number must be updated if there is any\n// change to the way in which a GraphQL schema is mapped to a SQL\n// schema or the way in which the resulting SQL schema is\n// interpreted. If you've made a change and you're not sure whether\n// it requires bumping the version, bump it: requiring some extra\n// one-time cache resets is okay; doing the wrong thing is not.\nconst blob=json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default()({version:\"MIRROR_v9\",schema:this._schema,options:{blacklistedIds:this._blacklistedIds}});const db=this._db;db.transaction(()=>{// We store the metadata in a singleton table `meta`, whose unique row\n// has primary key `0`. Only the first ever insert will succeed; we\n// are locked into the first config.\ndb.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"          CREATE TABLE IF NOT EXISTS meta (\\n              zero INTEGER PRIMARY KEY,\\n              config TEXT NOT NULL\\n          )\\n        \"],[\"\\\\\\n          CREATE TABLE IF NOT EXISTS meta (\\n              zero INTEGER PRIMARY KEY,\\n              config TEXT NOT NULL\\n          )\\n        \"])))).run();const existingBlob=db.prepare(\"SELECT config FROM meta\").pluck().get();if(existingBlob===blob){// Already set up; nothing to do.\nreturn;}else if(existingBlob!==undefined){throw new Error(\"Database already populated with \"+\"incompatible schema, options, or version\");}db.prepare(\"INSERT INTO meta (zero, config) VALUES (0, ?)\").run(blob);const tables=[// Time is stored in milliseconds since 1970-01-01T00:00Z, with\n// ECMAScript semantics (leap seconds ignored, exactly 86.4M ms\n// per day, etc.).\n//\n// We use milliseconds rather than seconds because (a) this\n// simplifies JavaScript interop to a simple `+new Date()` and\n// `new Date(value)`, and (b) this avoids a lurking Year 2038\n// problem by surfacing >32-bit values immediately. (We have\n// over 200,000 years before the number of milliseconds since\n// epoch is more than `Number.MAX_SAFE_INTEGER`.)\nObject(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"          CREATE TABLE updates (\\n              rowid INTEGER PRIMARY KEY,\\n              time_epoch_millis INTEGER NOT NULL\\n          )\\n        \"],[\"\\\\\\n          CREATE TABLE updates (\\n              rowid INTEGER PRIMARY KEY,\\n              time_epoch_millis INTEGER NOT NULL\\n          )\\n        \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject3||(_templateObject3=_taggedTemplateLiteral([\"          CREATE TABLE objects (\\n              id TEXT NOT NULL PRIMARY KEY,\\n              typename TEXT,\\n              last_update INTEGER,\\n              FOREIGN KEY(last_update) REFERENCES updates(rowid),\\n              CHECK((last_update IS NOT NULL) <= (typename IS NOT NULL))\\n          )\\n        \"],[\"\\\\\\n          CREATE TABLE objects (\\n              id TEXT NOT NULL PRIMARY KEY,\\n              typename TEXT,\\n              last_update INTEGER,\\n              FOREIGN KEY(last_update) REFERENCES updates(rowid),\\n              CHECK((last_update IS NOT NULL) <= (typename IS NOT NULL))\\n          )\\n        \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject4||(_templateObject4=_taggedTemplateLiteral([\"          CREATE TABLE primitives (\\n              rowid INTEGER PRIMARY KEY,\\n              object_id TEXT NOT NULL,\\n              fieldname TEXT NOT NULL,\\n              value,  -- JSON string, or SQL 0 or 1 for nest fields\\n              UNIQUE(object_id, fieldname),\\n              FOREIGN KEY(object_id) REFERENCES objects(id)\\n          )\\n        \"],[\"\\\\\\n          CREATE TABLE primitives (\\n              rowid INTEGER PRIMARY KEY,\\n              object_id TEXT NOT NULL,\\n              fieldname TEXT NOT NULL,\\n              value,  -- JSON string, or SQL 0 or 1 for nest fields\\n              UNIQUE(object_id, fieldname),\\n              FOREIGN KEY(object_id) REFERENCES objects(id)\\n          )\\n        \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject5||(_templateObject5=_taggedTemplateLiteral([\"          CREATE UNIQUE INDEX idx_primitives__object_id__fieldname\\n          ON primitives (object_id, fieldname)\\n        \"],[\"\\\\\\n          CREATE UNIQUE INDEX idx_primitives__object_id__fieldname\\n          ON primitives (object_id, fieldname)\\n        \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject6||(_templateObject6=_taggedTemplateLiteral([\"          CREATE TABLE links (\\n              rowid INTEGER PRIMARY KEY,\\n              parent_id TEXT NOT NULL,\\n              fieldname TEXT NOT NULL,\\n              child_id TEXT,\\n              UNIQUE(parent_id, fieldname),\\n              FOREIGN KEY(parent_id) REFERENCES objects(id),\\n              FOREIGN KEY(child_id) REFERENCES objects(id)\\n          )\\n        \"],[\"\\\\\\n          CREATE TABLE links (\\n              rowid INTEGER PRIMARY KEY,\\n              parent_id TEXT NOT NULL,\\n              fieldname TEXT NOT NULL,\\n              child_id TEXT,\\n              UNIQUE(parent_id, fieldname),\\n              FOREIGN KEY(parent_id) REFERENCES objects(id),\\n              FOREIGN KEY(child_id) REFERENCES objects(id)\\n          )\\n        \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject7||(_templateObject7=_taggedTemplateLiteral([\"          CREATE UNIQUE INDEX idx_links__parent_id__fieldname\\n          ON links (parent_id, fieldname)\\n        \"],[\"\\\\\\n          CREATE UNIQUE INDEX idx_links__parent_id__fieldname\\n          ON links (parent_id, fieldname)\\n        \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject8||(_templateObject8=_taggedTemplateLiteral([\"          CREATE TABLE connections (\\n              rowid INTEGER PRIMARY KEY,\\n              object_id TEXT NOT NULL,\\n              fieldname TEXT NOT NULL,\\n              last_update INTEGER,\\n              -- Each of the below fields must be NULL if the connection\\n              -- has never been updated.\\n              total_count INTEGER,\\n              has_next_page BOOLEAN,\\n              -- The end cursor may be NULL if no items are in the connection;\\n              -- this is a consequence of GraphQL and the Relay pagination spec.\\n              -- (It may also be NULL if the connection was never updated.)\\n              end_cursor TEXT,\\n              CHECK((last_update IS NULL) = (total_count IS NULL)),\\n              CHECK((last_update IS NULL) = (has_next_page IS NULL)),\\n              CHECK((last_update IS NULL) <= (end_cursor IS NULL)),\\n              UNIQUE(object_id, fieldname),\\n              FOREIGN KEY(object_id) REFERENCES objects(id),\\n              FOREIGN KEY(last_update) REFERENCES updates(rowid)\\n          )\\n        \"],[\"\\\\\\n          CREATE TABLE connections (\\n              rowid INTEGER PRIMARY KEY,\\n              object_id TEXT NOT NULL,\\n              fieldname TEXT NOT NULL,\\n              last_update INTEGER,\\n              -- Each of the below fields must be NULL if the connection\\n              -- has never been updated.\\n              total_count INTEGER,\\n              has_next_page BOOLEAN,\\n              -- The end cursor may be NULL if no items are in the connection;\\n              -- this is a consequence of GraphQL and the Relay pagination spec.\\n              -- (It may also be NULL if the connection was never updated.)\\n              end_cursor TEXT,\\n              CHECK((last_update IS NULL) = (total_count IS NULL)),\\n              CHECK((last_update IS NULL) = (has_next_page IS NULL)),\\n              CHECK((last_update IS NULL) <= (end_cursor IS NULL)),\\n              UNIQUE(object_id, fieldname),\\n              FOREIGN KEY(object_id) REFERENCES objects(id),\\n              FOREIGN KEY(last_update) REFERENCES updates(rowid)\\n          )\\n        \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject9||(_templateObject9=_taggedTemplateLiteral([\"          CREATE UNIQUE INDEX idx_connections__object_id__fieldname\\n          ON connections (object_id, fieldname)\\n        \"],[\"\\\\\\n          CREATE UNIQUE INDEX idx_connections__object_id__fieldname\\n          ON connections (object_id, fieldname)\\n        \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject10||(_templateObject10=_taggedTemplateLiteral([\"          CREATE TABLE connection_entries (\\n              rowid INTEGER PRIMARY KEY,\\n              connection_id INTEGER NOT NULL,\\n              idx INTEGER NOT NULL,  -- impose an ordering\\n              child_id TEXT,\\n              UNIQUE(connection_id, idx),\\n              FOREIGN KEY(connection_id) REFERENCES connections(rowid),\\n              FOREIGN KEY(child_id) REFERENCES objects(id)\\n          )\\n        \"],[\"\\\\\\n          CREATE TABLE connection_entries (\\n              rowid INTEGER PRIMARY KEY,\\n              connection_id INTEGER NOT NULL,\\n              idx INTEGER NOT NULL,  -- impose an ordering\\n              child_id TEXT,\\n              UNIQUE(connection_id, idx),\\n              FOREIGN KEY(connection_id) REFERENCES connections(rowid),\\n              FOREIGN KEY(child_id) REFERENCES objects(id)\\n          )\\n        \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject11||(_templateObject11=_taggedTemplateLiteral([\"          CREATE INDEX idx_connection_entries__connection_id\\n          ON connection_entries (connection_id)\\n        \"],[\"\\\\\\n          CREATE INDEX idx_connection_entries__connection_id\\n          ON connection_entries (connection_id)\\n        \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject12||(_templateObject12=_taggedTemplateLiteral([\"          CREATE TABLE network_log (\\n              rowid INTEGER PRIMARY KEY,\\n              query TEXT,\\n              query_parameters TEXT,  -- stringified JSON object\\n              request_time_epoch_millis INTEGER,\\n              response TEXT,\\n              response_time_epoch_millis INTEGER,\\n              update_id INTEGER,\\n              CHECK((query IS NULL) = (query_parameters IS NULL)),\\n              CHECK((request_time_epoch_millis IS NULL) = (query IS NULL)),\\n              CHECK((response_time_epoch_millis IS NULL) = (response IS NULL)),\\n              FOREIGN KEY(update_id) REFERENCES updates(rowid)\\n          )\\n        \"],[\"\\\\\\n          CREATE TABLE network_log (\\n              rowid INTEGER PRIMARY KEY,\\n              query TEXT,\\n              query_parameters TEXT,  -- stringified JSON object\\n              request_time_epoch_millis INTEGER,\\n              response TEXT,\\n              response_time_epoch_millis INTEGER,\\n              update_id INTEGER,\\n              CHECK((query IS NULL) = (query_parameters IS NULL)),\\n              CHECK((request_time_epoch_millis IS NULL) = (query IS NULL)),\\n              CHECK((response_time_epoch_millis IS NULL) = (response IS NULL)),\\n              FOREIGN KEY(update_id) REFERENCES updates(rowid)\\n          )\\n        \"])))];for(const sql of tables){db.prepare(sql).run();}})();}/**\n   * Register a new update, representing one communication with the\n   * remote server. A unique ID will be created and returned.\n   */_createUpdate(updateTimestamp){return this._db.prepare(\"INSERT INTO updates (time_epoch_millis) VALUES (?)\").run(+updateTimestamp).lastInsertRowid;}/**\n   * Inform the GraphQL mirror of the existence of an object. The\n   * object's ID must be specified. The object's concrete type may also\n   * be specified, in which case it must be an OBJECT type in the\n   * GraphQL schema.\n   *\n   * If the object has previously been registered with the same type, no\n   * action is taken and no error is raised. If the object has\n   * previously been registered with a different type, an error is\n   * thrown, and the database is left unchanged.\n   */registerObject(object){this._db.transaction(()=>{this._nontransactionallyRegisterObject(object);})();}/**\n   * As `registerObject`, but do not enter any transactions. Other\n   * methods may call this method as a subroutine in a larger\n   * transaction.\n   *\n   * This internal method also permits registering an object without\n   * specifying its typename.\n   */_nontransactionallyRegisterObject(object,guessMismatchMessage){const db=this._db;const{typename,id}=object;if(guessMismatchMessage==null){guessMismatchMessage=guess=>{const s=JSON.stringify;const message=\"object \".concat(s(object.id),\" \")+\"looks like it should have type \".concat(s(guess),\", \")+\"not \".concat(s(object.typename));return message;};}const existingTypename=db.prepare(\"SELECT typename FROM objects WHERE id = ?\").pluck().get(id);if(existingTypename===typename){// Already registered, and no typename upgrade; nothing to do.\nreturn;}else if(existingTypename!=null&&typename==null){// Already registered, and already have typename; nothing to do.\nreturn;}else if(existingTypename===undefined){// OK: New registration.\n}else if(existingTypename===null){// OK: Typename upgrade. Take the user-supplied type as reliable.\n// We still need to add primitives, links, and connections rows.\n}else{// Not OK: Already had a typename, but it didn't match.\nconst s=JSON.stringify;throw new Error(\"Inconsistent type for ID \".concat(s(id),\": \")+\"expected \".concat(s(existingTypename),\", got \").concat(s(typename)));}if(typename!=null){if(this._schema[typename]==null){throw new Error(\"Unknown type: \"+JSON.stringify(typename));}if(this._schema[typename].type!==\"OBJECT\"){throw new Error(\"Cannot add object of non-object type: \"+\"\".concat(JSON.stringify(typename),\" (\").concat(this._schema[typename].type,\")\"));}const guess=this._guessTypename(object.id);if(guess!=null&&guess!==object.typename){console.warn(\"Warning: \"+guessMismatchMessage(guess));}}if(existingTypename===undefined){this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject13||(_templateObject13=_taggedTemplateLiteral([\"            INSERT INTO objects (id, last_update, typename)\\n            VALUES (:id, NULL, :typename)\\n          \"],[\"\\\\\\n            INSERT INTO objects (id, last_update, typename)\\n            VALUES (:id, NULL, :typename)\\n          \"])))).run({id,typename});}else{// Should be a typename upgrade.\nconst stmt=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject14||(_templateObject14=_taggedTemplateLiteral([\"          UPDATE objects SET typename = :typename\\n          WHERE id = :id\\n          AND typename IS NULL  -- sanity check\\n          AND :typename IS NOT NULL  -- sanity check\\n        \"],[\"\\\\\\n          UPDATE objects SET typename = :typename\\n          WHERE id = :id\\n          AND typename IS NULL  -- sanity check\\n          AND :typename IS NOT NULL  -- sanity check\\n        \"]))));_makeSingleUpdateFunction(stmt)({id,typename});}if(typename==null){// Can't add fields if typename not known.\nreturn;}const addPrimitive=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject15||(_templateObject15=_taggedTemplateLiteral([\"\\n        INSERT INTO primitives (object_id, fieldname, value)\\n        VALUES (:id, :fieldname, NULL)\\n      \"]))));const addLink=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject16||(_templateObject16=_taggedTemplateLiteral([\"        INSERT INTO links (parent_id, fieldname, child_id)\\n        VALUES (:id, :fieldname, NULL)\\n      \"],[\"\\\\\\n        INSERT INTO links (parent_id, fieldname, child_id)\\n        VALUES (:id, :fieldname, NULL)\\n      \"]))));const addConnection=this._db.prepare(// These fields are initialized to NULL because there has\n// been no update and so they have no meaningful values:\n// last_update, total_count, has_next_page, end_cursor.\nObject(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject17||(_templateObject17=_taggedTemplateLiteral([\"        INSERT INTO connections (object_id, fieldname)\\n        VALUES (:id, :fieldname)\\n      \"],[\"\\\\\\n        INSERT INTO connections (object_id, fieldname)\\n        VALUES (:id, :fieldname)\\n      \"]))));const objectType=this._schemaInfo.objectTypes[typename];for(const fieldname of objectType.primitiveFieldNames){addPrimitive.run({id,fieldname});}for(const fieldname of objectType.linkFieldNames){addLink.run({id,fieldname});}for(const parentFieldname of objectType.nestedFieldNames){addPrimitive.run({id,fieldname:parentFieldname});const children=objectType.nestedFields[parentFieldname];for(const childFieldname of Object.keys(children.primitives)){const fieldname=\"\".concat(parentFieldname,\".\").concat(childFieldname);addPrimitive.run({id,fieldname});}for(const childFieldname of Object.keys(children.nodes)){const fieldname=\"\".concat(parentFieldname,\".\").concat(childFieldname);addLink.run({id,fieldname});}}for(const fieldname of objectType.connectionFieldNames){addConnection.run({id,fieldname});}}/**\n   * Register an object corresponding to the provided `NodeFieldResult`,\n   * if any, returning the object's ID. If the provided value is `null`,\n   * no action is taken, no error is thrown, and `null` is returned.\n   *\n   * As with `registerObject`, an error is thrown if an object by the\n   * given ID already exists with a different typename.\n   *\n   * This method does not begin or end any transactions. Other methods\n   * may call this method as a subroutine in a larger transaction.\n   *\n   * See: `registerObject`.\n   */_nontransactionallyRegisterNodeFieldResult(result,context){if(result==null){return null;}else if(this._blacklistedIds[result.id]){return null;}else{// If queried via an unfaithful field, typename will be missing;\n// in that case, register the object with unknown type (`null`).\nconst typename=result.__typename===undefined?null:result.__typename;const id=result.id;const object={typename,id};this._nontransactionallyRegisterObject(object,guess=>{const s=JSON.stringify;const message=\"object \".concat(s(object.id),\" \")+\"looks like it should have type \".concat(s(guess),\", \")+\"but the server claims that it has type \".concat(s(object.typename));return\"\".concat(context(),\": \").concat(message);});return object.id;}}/**\n   * Find objects and connections that are not known to be up-to-date.\n   *\n   * An object's typename is up-to-date if it has ever been fetched from\n   * a faithful field reference or a direct typename query.\n   *\n   * An object is up-to-date if its own data has been loaded at least as\n   * recently as the provided date.\n   *\n   * A connection is up-to-date if it has been fetched at least as\n   * recently as the provided date, and at the time of fetching there\n   * were no more pages.\n   */_findOutdated(since){const db=this._db;return db.transaction(()=>{const typenames=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject18||(_templateObject18=_taggedTemplateLiteral([\"            SELECT id AS id\\n            FROM objects\\n            WHERE typename IS NULL\\n          \"],[\"\\\\\\n            SELECT id AS id\\n            FROM objects\\n            WHERE typename IS NULL\\n          \"])))).pluck().all();const objects=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject19||(_templateObject19=_taggedTemplateLiteral([\"            SELECT typename AS typename, id AS id\\n            FROM objects\\n            LEFT OUTER JOIN updates ON objects.last_update = updates.rowid\\n            WHERE\\n                typename IS NOT NULL\\n                AND (\\n                    objects.last_update IS NULL\\n                    OR updates.time_epoch_millis < :timeEpochMillisThreshold\\n                )\\n          \"],[\"\\\\\\n            SELECT typename AS typename, id AS id\\n            FROM objects\\n            LEFT OUTER JOIN updates ON objects.last_update = updates.rowid\\n            WHERE\\n                typename IS NOT NULL\\n                AND (\\n                    objects.last_update IS NULL\\n                    OR updates.time_epoch_millis < :timeEpochMillisThreshold\\n                )\\n          \"])))).all({timeEpochMillisThreshold:+since});const connections=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject20||(_templateObject20=_taggedTemplateLiteral([\"            SELECT\\n                objects.typename AS objectTypename,\\n                connections.object_id AS objectId,\\n                connections.fieldname AS fieldname,\\n                connections.last_update IS NULL AS neverUpdated,\\n                connections.end_cursor AS endCursor\\n            FROM connections\\n            LEFT OUTER JOIN updates\\n                ON connections.last_update = updates.rowid\\n            JOIN objects\\n                ON connections.object_id = objects.id\\n            WHERE\\n                objectTypename IS NOT NULL\\n                AND (\\n                    connections.has_next_page\\n                    OR connections.last_update IS NULL\\n                    OR updates.time_epoch_millis < :timeEpochMillisThreshold\\n                )\\n          \"],[\"\\\\\\n            SELECT\\n                objects.typename AS objectTypename,\\n                connections.object_id AS objectId,\\n                connections.fieldname AS fieldname,\\n                connections.last_update IS NULL AS neverUpdated,\\n                connections.end_cursor AS endCursor\\n            FROM connections\\n            LEFT OUTER JOIN updates\\n                ON connections.last_update = updates.rowid\\n            JOIN objects\\n                ON connections.object_id = objects.id\\n            WHERE\\n                objectTypename IS NOT NULL\\n                AND (\\n                    connections.has_next_page\\n                    OR connections.last_update IS NULL\\n                    OR updates.time_epoch_millis < :timeEpochMillisThreshold\\n                )\\n          \"])))).all({timeEpochMillisThreshold:+since}).map(entry=>{const result=_objectSpread({},entry);if(result.neverUpdated){result.endCursor=undefined;// as opposed to `null`\n}delete result.neverUpdated;return result;});return{typenames,objects,connections};})();}/**\n   * Check whether the given query plan indicates that the mirror is\n   * already up to date and no further queries are required.\n   */_isUpToDate(queryPlan){return queryPlan.typenames.length===0&&queryPlan.objects.length===0&&queryPlan.connections.length===0;}/**\n   * Create a GraphQL selection set to fetch data corresponding to the\n   * given query plan.\n   *\n   * The resulting GraphQL should be embedded into a top-level query.\n   *\n   * The result of this query is an `UpdateResult`.\n   *\n   * This function is pure: it does not interact with the database.\n   */_queryFromPlan(queryPlan,options){const fetchTypenamesFor=queryPlan.typenames.slice(0,options.typenamesLimit);const typenameBatches=[];for(let i=0;i<fetchTypenamesFor.length;i+=options.nodesOfTypeLimit){typenameBatches.push(fetchTypenamesFor.slice(i,i+options.nodesOfTypeLimit));}// Group objects by type, so that we have to specify each type's\n// fieldset fewer times (only once per `nodesOfTypeLimit` nodes\n// instead of for every node).\nconst objectsByType=new Map();for(const object of queryPlan.objects.slice(0,options.nodesLimit)){_util_map__WEBPACK_IMPORTED_MODULE_3__[\"pushValue\"](objectsByType,object.typename,object.id);}const paginatedObjectsByType=[];for(const[typename,allIds]of objectsByType.entries()){for(let i=0;i<allIds.length;i+=options.nodesOfTypeLimit){const ids=allIds.slice(i,i+options.nodesOfTypeLimit);paginatedObjectsByType.push({typename,ids});}}// Group connections by object, so that we only have to fetch the\n// node once.\nconst connectionsByObject=new Map();for(const connection of queryPlan.connections.slice(0,options.connectionLimit)){let existing=connectionsByObject.get(connection.objectId);if(existing==null){existing={typename:connection.objectTypename,connections:[]};connectionsByObject.set(connection.objectId,existing);}else{if(connection.objectTypename!==existing.typename){const s=JSON.stringify;throw new Error(\"Query plan has inconsistent typenames for \"+\"object \".concat(s(connection.objectId),\": \")+\"\".concat(s(existing.typename),\" vs. \").concat(s(connection.objectTypename)));}}existing.connections.push({fieldname:connection.fieldname,endCursor:connection.endCursor});}const b=_queries__WEBPACK_IMPORTED_MODULE_6__[\"build\"];// Each top-level field other than `typenames` corresponds to either\n// an object type (fetching own data for objects of that type) or a\n// particular node (updating connections on that node). We alias\n// each such field, which is necessary to ensure that their names\n// are all unique. The names chosen are sufficient to identify which\n// _kind_ of query the field corresponds to (type's own data vs\n// node's connections), but do not need to identify the particular\n// type or node in question. This is because all descendant\n// selections are self-describing: they include the ID of any\n// relevant objects.\nreturn[].concat(typenameBatches.map((typenames,i)=>{const name=\"\".concat(_FIELD_PREFIXES.TYPENAMES).concat(i);return b.alias(name,b.field(\"nodes\",{ids:b.list(typenames.map(id=>b.literal(id)))},this._queryTypename()));}),paginatedObjectsByType.map((_ref,i)=>{let{typename,ids}=_ref;const name=\"\".concat(_FIELD_PREFIXES.OWN_DATA).concat(i);return b.alias(name,b.field(\"nodes\",{ids:b.list(ids.map(id=>b.literal(id)))},[b.inlineFragment(typename,this._queryOwnData(typename))]));}),_util_map__WEBPACK_IMPORTED_MODULE_3__[\"mapToArray\"](connectionsByObject,(_ref2,i)=>{let[id,{typename,connections}]=_ref2;const name=\"\".concat(_FIELD_PREFIXES.NODE_CONNECTIONS).concat(i);return b.alias(name,b.field(\"node\",{id:b.literal(id)},[b.field(\"id\"),b.inlineFragment(typename,[].concat(...connections.map(_ref3=>{let{fieldname,endCursor}=_ref3;return this._queryConnection(typename,fieldname,endCursor,options.connectionPageSize);})))]));}));}/**\n   * Ingest data given by an `UpdateResult`. This is porcelain over\n   * `_updateConnection` and `_updateOwnData`.\n   *\n   * See: `_findOutdated`.\n   * See: `_queryFromPlan`.\n   */_updateData(updateId,queryResult){this._db.transaction(()=>{this._nontransactionallyUpdateData(updateId,queryResult);})();}/**\n   * As `_updateData`, but do not enter any transactions. Other methods\n   * may call this method as a subroutine in a larger transaction.\n   */_nontransactionallyUpdateData(updateId,queryResult){for(const topLevelKey of Object.keys(queryResult)){const rawValue=queryResult[topLevelKey];if(topLevelKey.startsWith(_FIELD_PREFIXES.TYPENAMES)){const updateRecord=rawValue;this._nontransactionallyUpdateTypenames(updateRecord);}else if(topLevelKey.startsWith(_FIELD_PREFIXES.OWN_DATA)){const updateRecord=rawValue;this._nontransactionallyUpdateOwnData(updateId,updateRecord);}else if(topLevelKey.startsWith(_FIELD_PREFIXES.NODE_CONNECTIONS)){const updateRecord=rawValue;for(const fieldname of Object.keys(updateRecord)){if(fieldname===\"id\"){continue;}this._nontransactionallyUpdateConnection(updateId,updateRecord.id,fieldname,updateRecord[fieldname]);}}else{throw new Error(\"Bad key in query result: \"+JSON.stringify(topLevelKey));}}}/**\n   * Save the request query and query parameters to the database.\n   */_logRequest(body,variables,timestamp){const query=_queries__WEBPACK_IMPORTED_MODULE_6__[\"stringify\"].body(body,_queries__WEBPACK_IMPORTED_MODULE_6__[\"inlineLayout\"]());const queryParameters=json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default()(variables);return this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject21||(_templateObject21=_taggedTemplateLiteral([\"          INSERT INTO network_log (\\n              query, query_parameters, request_time_epoch_millis\\n          )\\n          VALUES (:query, :queryParameters, :requestTimestamp)\\n        \"],[\"\\\\\\n          INSERT INTO network_log (\\n              query, query_parameters, request_time_epoch_millis\\n          )\\n          VALUES (:query, :queryParameters, :requestTimestamp)\\n        \"])))).run({query,queryParameters,requestTimestamp:+timestamp}).lastInsertRowid;}/**\n   * Save the network response and response timestamp to the table row\n   * corresponding to the request that generated it.\n   */_logResponse(rowid,jsonResponse,timestamp){const response=json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default()(jsonResponse);const stmt=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject22||(_templateObject22=_taggedTemplateLiteral([\"        UPDATE network_log\\n        SET\\n            response = :response,\\n            response_time_epoch_millis = :responseTimestamp\\n        WHERE rowid = :rowid\\n      \"],[\"\\\\\\n        UPDATE network_log\\n        SET\\n            response = :response,\\n            response_time_epoch_millis = :responseTimestamp\\n        WHERE rowid = :rowid\\n      \"]))));const saveResponse=_makeSingleUpdateFunction(stmt);saveResponse({response,responseTimestamp:+timestamp,rowid});}/**\n   * Save the UpdateId in the table row corresponding to the network request\n   * that generated it.\n   */_logRequestUpdateId(rowid,updateId){const stmt=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject23||(_templateObject23=_taggedTemplateLiteral([\"        UPDATE network_log\\n        SET\\n            update_id = :updateId\\n        WHERE rowid = :rowid\\n      \"],[\"\\\\\\n        UPDATE network_log\\n        SET\\n            update_id = :updateId\\n        WHERE rowid = :rowid\\n      \"]))));const saveUpdateId=_makeSingleUpdateFunction(stmt);saveUpdateId({rowid,updateId});}/**\n   * Perform one step of the update loop: find outdated entities, fetch\n   * their updates, and feed the results back into the database.\n   *\n   * Returns a promise that resolves to `true` if any changes were made.\n   */async _updateStep(postQuery,options){const queryPlan=this._findOutdated(options.since);if(this._isUpToDate(queryPlan)){return Promise.resolve(false);}const querySelections=this._queryFromPlan(queryPlan,{// TODO(@wchargin): Expose `typenamesLimit` as an option and fix\n// up callers.\ntypenamesLimit:options.nodesLimit,nodesLimit:options.nodesLimit,nodesOfTypeLimit:options.nodesOfTypeLimit,connectionPageSize:options.connectionPageSize,connectionLimit:options.connectionLimit});const body=[_queries__WEBPACK_IMPORTED_MODULE_6__[\"build\"].query(\"MirrorUpdate\",[],querySelections)];const variables={};const requestRowId=this._logRequest(body,variables,options.now());const result=await postQuery({body,variables});this._logResponse(requestRowId,result,options.now());this._db.transaction(()=>{const updateId=this._createUpdate(options.now());this._logRequestUpdateId(requestRowId,updateId);this._nontransactionallyUpdateData(updateId,result);})();return Promise.resolve(true);}/**\n   * Update this mirror with new information from a remote GraphQL\n   * server.\n   *\n   * The `postQuery` function should post a GraphQL query to the remote\n   * server and return the `data` contents of its response, rejecting if\n   * there are any errors. (Note that this requirement may change\n   * backward-incompatibly in future versions of this module, in the\n   * case that we wish to handle deletions without regenerating all\n   * data.)\n   *\n   * The options are as follows:\n   *\n   *   - `since`: Fetch all data that is not known to be up-to-date as\n   *     of the provided time. For instance, to fetch all objects more\n   *     than a day old, use `new Date(new Date() - 86400e3)`.\n   *\n   *   - `now`: Function to yield the current date, which will be used\n   *     as the modification time for any objects or connections updated\n   *     in this process. Should probably be `() => new Date()`.\n   *\n   *   - `connectionPageSize`: Maximum number of entries to fetch in any\n   *     given connection. Some providers have a hard limit of 100 on\n   *     this value.\n   *\n   *   - `connectionLimit`: Maximum number of connections to fetch in a\n   *     single query.\n   *\n   * See: `registerObject`.\n   * See: `extract`.\n   */async update(postQuery,options){while(await this._updateStep(postQuery,options));}/**\n   * Create a GraphQL selection set required to identify an object of\n   * the given declared type, which may be either an object type or a\n   * union type. This is the minimal required data whenever we find a\n   * reference to an object that we want to traverse later.\n   *\n   * The `fidelity` argument should be the fidelity of the field being\n   * traversed. If it is faithful, the object's typename will be queried\n   * as well; if it is unfaithful, the typename will not be requested.\n   *\n   * The resulting GraphQL should be embedded in the context of any node\n   * of the provided type. For instance, `_queryShallow(\"Issue\")`\n   * returns a selection set that might replace the `?` in any of the\n   * following queries:\n   *\n   *     repository(owner: \"foo\", name: \"bar\") {\n   *       issues(first: 1) {\n   *         nodes { ? }\n   *       }\n   *     }\n   *\n   *     nodes(ids: [\"issue#1\", \"issue#2\"]) { ? }\n   *\n   * The result of this query has type `NodeFieldResult`.\n   *\n   * This function is pure: it does not interact with the database.\n   */_queryShallow(typename,fidelity){const type=this._schema[typename];if(type==null){// Should not be reachable via APIs.\nthrow new Error(\"No such type: \"+JSON.stringify(typename));}const b=_queries__WEBPACK_IMPORTED_MODULE_6__[\"build\"];const typenameQuery=[];switch(fidelity.type){case\"FAITHFUL\":typenameQuery.push(b.field(\"__typename\"));break;case\"UNFAITHFUL\":// Do not query typename.\nbreak;// istanbul ignore next\ndefault:throw new Error(fidelity.type);}switch(type.type){case\"SCALAR\":throw new Error(\"Cannot create selections for scalar type: \"+JSON.stringify(typename));case\"ENUM\":throw new Error(\"Cannot create selections for enum type: \"+JSON.stringify(typename));case\"OBJECT\":return[...typenameQuery,b.field(\"id\")];case\"UNION\":return[// Known issue: This selection set may be empty if the field\n// is unfaithful and the union type has no clauses. This would\n// emit an invalid GraphQL query; the GraphQL syntax requires\n// at least one selection. However, empty union types are also\n// disallowed in GraphQL, so this should not be a problem on a\n// well-formed schema. Handling this properly would require\n// transitively upward-pruning the query and seems unlikely to\n// be worth it at this time.\n...typenameQuery,...this._schemaInfo.unionTypes[typename].clauses.map(clause=>b.inlineFragment(clause,[b.field(\"id\")]))];// istanbul ignore next\ndefault:throw new Error(type.type);}}/**\n   * Get the current value of the end cursor on a connection, or\n   * `undefined` if the object has never been fetched. If no object by\n   * the given ID is known, or the object does not have a connection of\n   * the given name, then an error is thrown.\n   *\n   * Note that `null` is a valid end cursor and is distinct from\n   * `undefined`.\n   */_getEndCursor(objectId,fieldname){const result=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject24||(_templateObject24=_taggedTemplateLiteral([\"          SELECT\\n              last_update IS NOT NULL AS initialized,\\n              end_cursor AS endCursor\\n          FROM connections\\n          WHERE object_id = :objectId AND fieldname = :fieldname\\n        \"],[\"\\\\\\n          SELECT\\n              last_update IS NOT NULL AS initialized,\\n              end_cursor AS endCursor\\n          FROM connections\\n          WHERE object_id = :objectId AND fieldname = :fieldname\\n        \"]))))// No need to worry about corruption in the form of multiple\n// matches: there is a UNIQUE(object_id, fieldname) constraint.\n.get({objectId,fieldname});if(result===undefined){const s=JSON.stringify;throw new Error(\"No such connection: \".concat(s(objectId),\".\").concat(s(fieldname)));}return result.initialized?result.endCursor:undefined;}/**\n   * Create a GraphQL selection set to fetch elements from a collection,\n   * specified by its enclosing object type and the connection field\n   * name (for instance, \"Repository\" and \"issues\").\n   *\n   * If the connection has been queried before and you wish to fetch new\n   * elements, use an appropriate end cursor. Use `undefined` otherwise.\n   * Note that `null` is a valid end cursor and is distinct from\n   * `undefined`. Note that these semantics are compatible with the\n   * return value of `_getEndCursor`.\n   *\n   * If an end cursor for a particular node's connection was specified,\n   * then the resulting GraphQL should be embedded in the context of\n   * that node. For instance, if repository \"foo/bar\" has ID \"baz\" and\n   * an end cursor of \"c000\" on its \"issues\" connection, then the\n   * GraphQL emitted by `_queryConnection(\"issues\", \"c000\")` might\n   * replace the `?` in the following query:\n   *\n   *     node(id: \"baz\") { ? }\n   *\n   * If no end cursor was specified, then the resulting GraphQL may be\n   * embedded in the context of _any_ node with a connection of the\n   * appropriate fieldname. For instance, `_queryConnection(\"issues\")`\n   * emits GraphQL that may replace the `?` in either of the following\n   * queries:\n   *\n   *     node(id: \"baz\") { ? }  # where \"baz\" is a repository ID\n   *     repository(owner: \"foo\", name: \"bar\") { ? }\n   *\n   * Note, however, that this query will fetch nodes from the _start_ of\n   * the connection. It would be wrong to append these results onto an\n   * connection for which we have already fetched data.\n   *\n   * The result of this query has type `ConnectionFieldResult`.\n   *\n   * This function is pure: it does not interact with the database.\n   *\n   * See: `_getEndCursor`.\n   * See: `_updateConnection`.\n   */_queryConnection(typename,fieldname,endCursor,connectionPageSize){if(this._schema[typename]==null){throw new Error(\"No such type: \"+JSON.stringify(typename));}if(this._schema[typename].type!==\"OBJECT\"){const s=JSON.stringify;throw new Error(\"Cannot query connection on non-object type \".concat(s(typename),\" \")+\"(\".concat(this._schema[typename].type,\")\"));}const field=this._schemaInfo.objectTypes[typename].fields[fieldname];if(field==null){const s=JSON.stringify;throw new Error(\"Object type \".concat(s(typename),\" has no field \").concat(s(fieldname)));}if(field.type!==\"CONNECTION\"){const s=JSON.stringify;throw new Error(\"Cannot query non-connection field \".concat(s(typename),\".\").concat(s(fieldname),\" \")+\"(\".concat(field.type,\")\"));}const b=_queries__WEBPACK_IMPORTED_MODULE_6__[\"build\"];const connectionArguments={first:b.literal(connectionPageSize)};if(endCursor!==undefined){connectionArguments.after=b.literal(endCursor);}return[b.field(fieldname,connectionArguments,[b.field(\"totalCount\"),b.field(\"pageInfo\",{},[b.field(\"endCursor\"),b.field(\"hasNextPage\")]),b.field(\"nodes\",{},this._queryShallow(field.elementType,field.fidelity))])];}/**\n   * Ingest new entries in a connection on an existing object.\n   *\n   * The connection's last update will be set to the given value, which\n   * must be an existing update lest an error be thrown.\n   *\n   * If the object does not exist or does not have a connection by the\n   * given name, an error will be thrown.\n   *\n   * See: `_queryConnection`.\n   * See: `_createUpdate`.\n   */_updateConnection(updateId,objectId,fieldname,queryResult){this._db.transaction(()=>{this._nontransactionallyUpdateConnection(updateId,objectId,fieldname,queryResult);})();}/**\n   * As `_updateConnection`, but do not enter any transactions. Other\n   * methods may call this method as a subroutine in a larger\n   * transaction.\n   */_nontransactionallyUpdateConnection(updateId,objectId,fieldname,queryResult){const db=this._db;const connectionId=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject25||(_templateObject25=_taggedTemplateLiteral([\"          SELECT rowid FROM connections\\n          WHERE object_id = :objectId AND fieldname = :fieldname\\n        \"],[\"\\\\\\n          SELECT rowid FROM connections\\n          WHERE object_id = :objectId AND fieldname = :fieldname\\n        \"])))).pluck().get({objectId,fieldname});// There is a UNIQUE(object_id, fieldname) constraint, so we don't\n// have to worry about pollution due to duplicates. But it's\n// possible that no such connection exists, indicating that the\n// object has not been registered. This is an error.\nif(connectionId===undefined){const s=JSON.stringify;throw new Error(\"No such connection: \".concat(s(objectId),\".\").concat(s(fieldname)));}db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject26||(_templateObject26=_taggedTemplateLiteral([\"          UPDATE connections\\n          SET\\n              last_update = :updateId,\\n              total_count = :totalCount,\\n              has_next_page = :hasNextPage,\\n              end_cursor = :endCursor\\n          WHERE rowid = :connectionId\\n        \"],[\"\\\\\\n          UPDATE connections\\n          SET\\n              last_update = :updateId,\\n              total_count = :totalCount,\\n              has_next_page = :hasNextPage,\\n              end_cursor = :endCursor\\n          WHERE rowid = :connectionId\\n        \"])))).run({updateId,totalCount:queryResult.totalCount,hasNextPage:+queryResult.pageInfo.hasNextPage,endCursor:queryResult.pageInfo.endCursor,connectionId});let nextIndex=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject27||(_templateObject27=_taggedTemplateLiteral([\"          SELECT IFNULL(MAX(idx), 0) + 1 FROM connection_entries\\n          WHERE connection_id = :connectionId\\n        \"],[\"\\\\\\n          SELECT IFNULL(MAX(idx), 0) + 1 FROM connection_entries\\n          WHERE connection_id = :connectionId\\n        \"])))).pluck().get({connectionId});const addEntry=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject28||(_templateObject28=_taggedTemplateLiteral([\"        INSERT INTO connection_entries (connection_id, idx, child_id)\\n        VALUES (:connectionId, :idx, :childId)\\n      \"],[\"\\\\\\n        INSERT INTO connection_entries (connection_id, idx, child_id)\\n        VALUES (:connectionId, :idx, :childId)\\n      \"]))));for(const node of queryResult.nodes){const childId=this._nontransactionallyRegisterNodeFieldResult(node,()=>{const s=JSON.stringify;return\"when processing \"+\"\".concat(s(fieldname),\" connection of object \").concat(s(objectId));});const idx=nextIndex++;addEntry.run({connectionId,idx,childId});}}/**\n   * Create a GraphQL selection set required to fetch the own-data\n   * (primitives and node references) of an object, but not its\n   * connection entries. The result depends only on the (concrete) type\n   * of the object, not its ID.\n   *\n   * The provided typename must correspond to an object type, not a\n   * union type; otherwise, an error will be thrown.\n   *\n   * The resulting GraphQL can be embedded into the context of any node\n   * with the provided typename. For instance, if there are issues with\n   * IDs \"#1\" and \"#2\", then `_queryOwnData(\"Issue\")` emits GraphQL\n   * that may replace the `?` in any of the following queries:\n   *\n   *     repository(owner: \"foo\", name: \"bar\") {\n   *       issues(first: 1) { ? }\n   *     }\n   *     nodes(ids: [\"#1\", \"#2\") { ... on Issue { ? } }\n   *     node(id: \"#1\") { ... on Issue { ? } }\n   *\n   * The result of this query has type `E`, where `E` is the element\n   * type of `OwnDataUpdateResult`. That is, it is an object with shape\n   * that depends on the provided typename: the name of each ID or\n   * primitive field is a key mapping to a primitive value, and the name\n   * of each node field is a key mapping to a `NodeFieldResult`.\n   * Additionally, the attribute \"__typename\" maps to the node's\n   * typename.\n   *\n   * This function is pure: it does not interact with the database.\n   */_queryOwnData(typename){const type=this._schema[typename];if(type==null){throw new Error(\"No such type: \".concat(JSON.stringify(typename)));}if(type.type!==\"OBJECT\"){throw new Error(\"Not an object type: \".concat(JSON.stringify(typename),\" (\").concat(type.type,\")\"));}const b=_queries__WEBPACK_IMPORTED_MODULE_6__[\"build\"];return[b.field(\"__typename\"),...Object.keys(type.fields).map(fieldname=>{const field=type.fields[fieldname];switch(field.type){case\"ID\":return b.field(fieldname);case\"PRIMITIVE\":return b.field(fieldname);case\"NODE\":return b.field(fieldname,{},this._queryShallow(field.elementType,field.fidelity));case\"CONNECTION\":// Not handled by this function.\nreturn null;case\"NESTED\":return b.field(fieldname,{},Object.keys(field.eggs).map(childFieldname=>{const childField=field.eggs[childFieldname];switch(childField.type){case\"PRIMITIVE\":return b.field(childFieldname);case\"NODE\":return b.field(childFieldname,{},this._queryShallow(childField.elementType,childField.fidelity));// istanbul ignore next\ndefault:throw new Error(childField.type);}}));// istanbul ignore next\ndefault:throw new Error(field.type);}}).filter(Boolean)];}/**\n   * Ingest own-data (primitive and link) updates for many objects of a\n   * fixed concrete type. Every object in the input list must have the\n   * same `__typename` attribute, which must be the name of a valid\n   * object type.\n   *\n   * See: `_queryOwnData`.\n   */_updateOwnData(updateId,queryResult){this._db.transaction(()=>{this._nontransactionallyUpdateOwnData(updateId,queryResult);})();}/**\n   * As `_updateOwnData`, but do not enter any transactions. Other\n   * methods may call this method as a subroutine in a larger\n   * transaction.\n   */_nontransactionallyUpdateOwnData(updateId,queryResult){if(queryResult.length===0){return;}const typename=queryResult[0].__typename;if(this._schema[typename]==null){throw new Error(\"Unknown type: \"+JSON.stringify(typename));}if(this._schema[typename].type!==\"OBJECT\"){throw new Error(\"Cannot update data for non-object type: \"+\"\".concat(JSON.stringify(typename),\" (\").concat(this._schema[typename].type,\")\"));}const db=this._db;const objectType=this._schemaInfo.objectTypes[typename];// First, make sure that all objects for which we're given own data\n// actually exist and have the correct typename.\n{const checkTypename=db.prepare(\"SELECT typename IS NOT NULL FROM objects WHERE id = ?\").pluck();for(const entry of queryResult){const hasTypename=checkTypename.get(entry.id);if(hasTypename==null){throw new Error(\"Cannot update data for nonexistent node: \"+JSON.stringify(entry.id));}if(!hasTypename){throw new Error(\"Cannot update data before typename known: \"+JSON.stringify(entry.id));}if(entry.__typename!==typename){const s=JSON.stringify;throw new Error(\"Result set has inconsistent typenames: \"+\"\".concat(s(typename),\" vs. \").concat(s(entry.__typename)));}}}// Set each node's `lastUpdate` time.\n{const setLastUpdate=(()=>{const stmt=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject29||(_templateObject29=_taggedTemplateLiteral([\"            UPDATE objects SET last_update = :updateId\\n            WHERE id = :objectId\\n          \"],[\"\\\\\\n            UPDATE objects SET last_update = :updateId\\n            WHERE id = :objectId\\n          \"]))));const update=_makeSingleUpdateFunction(stmt);return objectId=>update({objectId,updateId});})();for(const entry of queryResult){setLastUpdate(entry.id);}}// Update each node's primitive data.\n//\n// (This typedef would be in the following block statement but for\n// facebook/flow#6961.)\n{const parameterNameFor={topLevelField(fieldname){return[\"t\",fieldname].join(\"_\");},nestedField(nestFieldname,eggFieldname){return[\"n\",String(nestFieldname.length),nestFieldname,eggFieldname].join(\"_\");}};const updatePrimitive=_makeSingleUpdateFunction(db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject30||(_templateObject30=_taggedTemplateLiteral([\"            UPDATE primitives\\n            SET value = :value\\n            WHERE object_id = :id AND fieldname = :fieldname\\n          \"],[\"\\\\\\n            UPDATE primitives\\n            SET value = :value\\n            WHERE object_id = :id AND fieldname = :fieldname\\n          \"])))));for(const entry of queryResult){const primitives={id:entry.id};// Add top-level primitives.\nfor(const fieldname of objectType.primitiveFieldNames){const value=entry[fieldname];const primitive=value;if(primitive===undefined){const s=JSON.stringify;throw new Error(\"Missing primitive \".concat(s(fieldname),\" on \").concat(s(entry.id),\" \")+\"of type \".concat(s(typename),\" (got \").concat(primitive,\")\"));}const jsonValue=JSON.stringify(primitive);primitives[parameterNameFor.topLevelField(fieldname)]=jsonValue;updatePrimitive({id:entry.id,fieldname,value:jsonValue});}// Add nested primitives.\nfor(const nestFieldname of objectType.nestedFieldNames){const nestValue=entry[nestFieldname];const topLevelNested=nestValue;if(topLevelNested===undefined){const s=JSON.stringify;throw new Error(\"Missing nested field \"+\"\".concat(s(nestFieldname),\" on \").concat(s(entry.id),\" \")+\"of type \".concat(s(typename),\" (got \").concat(topLevelNested,\")\"));}primitives[parameterNameFor.topLevelField(nestFieldname)]=topLevelNested==null?0:1;updatePrimitive({id:entry.id,fieldname:nestFieldname,value:topLevelNested==null?0:1});const eggFields=objectType.nestedFields[nestFieldname].primitives;for(const eggFieldname of Object.keys(eggFields)){const eggValue=topLevelNested==null?null:topLevelNested[eggFieldname];const primitive=eggValue;if(primitive===undefined){const s=JSON.stringify;throw new Error(\"Missing nested field \"+\"\".concat(s(nestFieldname),\".\").concat(s(eggFieldname),\" \")+\"on \".concat(s(entry.id),\" \")+\"of type \".concat(s(typename),\" (got \").concat(primitive,\")\"));}const jsonValue=JSON.stringify(primitive);primitives[parameterNameFor.nestedField(nestFieldname,eggFieldname)]=jsonValue;updatePrimitive({id:entry.id,fieldname:\"\".concat(nestFieldname,\".\").concat(eggFieldname),value:jsonValue});}}}}// Update each node's links.\n{const updateLink=(()=>{const stmt=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject31||(_templateObject31=_taggedTemplateLiteral([\"            UPDATE links SET child_id = :childId\\n            WHERE parent_id = :parentId AND fieldname = :fieldname\\n          \"],[\"\\\\\\n            UPDATE links SET child_id = :childId\\n            WHERE parent_id = :parentId AND fieldname = :fieldname\\n          \"]))));return _makeSingleUpdateFunction(stmt);})();for(const entry of queryResult){// Add top-level links.\nfor(const fieldname of objectType.linkFieldNames){const value=entry[fieldname];const link=value;if(link===undefined){const s=JSON.stringify;throw new Error(\"Missing node reference \".concat(s(fieldname),\" on \").concat(s(entry.id),\" \")+\"of type \".concat(s(typename),\" (got \").concat(link,\")\"));}const parentId=entry.id;const childId=this._nontransactionallyRegisterNodeFieldResult(link,()=>\"when setting \"+\"\".concat(typename,\"[\").concat(JSON.stringify(parentId),\"].\").concat(fieldname));updateLink({parentId,fieldname,childId});}// Add nested links.\nfor(const nestFieldname of objectType.nestedFieldNames){const nestValue=entry[nestFieldname];const topLevelNested=nestValue;// No need for an extra safety check that this is present: we\n// handled that while covering primitive fields.\nconst childFields=objectType.nestedFields[nestFieldname].nodes;for(const childFieldname of Object.keys(childFields)){const childValue=topLevelNested==null?null:topLevelNested[childFieldname];const link=childValue;if(link===undefined){const s=JSON.stringify;throw new Error(\"Missing nested field \"+\"\".concat(s(nestFieldname),\".\").concat(s(childFieldname),\" \")+\"on \".concat(s(entry.id),\" \")+\"of type \".concat(s(typename),\" (got \").concat(link,\")\"));}const fieldname=\"\".concat(nestFieldname,\".\").concat(childFieldname);const parentId=entry.id;const childId=this._nontransactionallyRegisterNodeFieldResult(link,()=>\"when setting \"+\"\".concat(typename,\"[\").concat(JSON.stringify(parentId),\"].\").concat(fieldname));updateLink({parentId,fieldname,childId});}}}}// Last-updates, primitives, and links all updated: we're done.\n}/**\n   * Create a GraphQL selection set required to fetch the typename of an\n   * object. The resulting GraphQL can be embedded in any node context.\n   *\n   * The result of this query has type `E`, where `E` is the element\n   * type of `TypenamesUpdateResult`.\n   *\n   * This function is pure: it does not interact with the database.\n   */_queryTypename(){const b=_queries__WEBPACK_IMPORTED_MODULE_6__[\"build\"];return[b.field(\"__typename\"),b.field(\"id\")];}/**\n   * Ingest typenames for many object IDs.\n   *\n   * See: `_queryTypenames`.\n   */_updateTypenames(queryResult){this._db.transaction(()=>{this._nontransactionallyUpdateTypenames(queryResult);})();}/**\n   * As `_updateTypenames`, but do not enter any transactions. Other\n   * methods may call this method as a subroutine in a larger\n   * transaction.\n   */_nontransactionallyUpdateTypenames(queryResult){for(const datum of queryResult){// Need to go through `registerObject` to ensure that primitives,\n// links, and connections are initialized.\nthis._nontransactionallyRegisterObject({id:datum.id,typename:datum.__typename});}}/**\n   * Extract a structured object and all of its transitive dependencies\n   * from the database.\n   *\n   * The result is an object whose keys are fieldnames, and whose values\n   * are:\n   *\n   *   - for \"__typename\": the object's GraphQL typename;\n   *   - for \"id\": the object's GraphQL ID;\n   *   - for primitive fields: the corresponding primitive value;\n   *   - for node reference fields: a reference to the corresponding\n   *     extracted object, which may be `null`;\n   *   - for connection fields: an in-order array of the corresponding\n   *     extracted objects, each of which may be `null`;\n   *   - for nested fields: an object with primitive and node reference\n   *     fields in the same form as above (note: nested objects do not\n   *     automatically have a \"__typename\" field).\n   *\n   * For instance, the result of `extract(\"issue:1\")` might be:\n   *\n   *     {\n   *       __typename: \"Issue\",\n   *       id: \"issue:1172\",\n   *       title: \"bug: holding <Space> causes CPU to overheat\",\n   *       body: \"We should fix this immediately.\",\n   *       author: {\n   *         __typename: \"User\",\n   *         id: \"user:admin\",\n   *         login: \"admin\",\n   *       },\n   *       comments: [\n   *         {\n   *           __typename: \"IssueComment\",\n   *           body: \"I depend on this behavior; please do not change it.\",\n   *           author: {\n   *             __typename: \"User\",\n   *             id: \"user:longtimeuser4\",\n   *             login: \"longtimeuser4\",\n   *           },\n   *         },\n   *         {\n   *           __typename: \"IssueComment\",\n   *           body: \"That's horrifying.\",\n   *           author: {\n   *             __typename: \"User\",\n   *             id: \"user:admin\",\n   *             login: \"admin\",\n   *           },\n   *         },\n   *       ],\n   *       timeline: [\n   *         {\n   *           __typename: \"Commit\",\n   *           messageHeadline: \"reinstate CPU warmer (fixes #1172)\",\n   *           author: {\n   *             date: \"2001-02-03T04:05:06-07:00\",\n   *             user: {\n   *               __typename: \"User\",\n   *               id: \"user:admin\",\n   *               login: \"admin\",\n   *             }\n   *           }\n   *         }\n   *       ],\n   *     }\n   *\n   * (Here, \"title\" is a primitive, the \"author\" field on an issue is a\n   * node reference, \"comments\" is a connection, and the \"author\" field\n   * on a commit is a nested object.)\n   *\n   * The returned structure may be circular.\n   *\n   * If a node appears more than one time in the result---for instance,\n   * the \"user:admin\" node above---all instances will refer to the same\n   * object. However, objects are distinct across calls to `extract`, so\n   * it is safe to deeply mutate the result of this function.\n   *\n   * The provided object ID must correspond to a known object, or an\n   * error will be thrown. Furthermore, all transitive dependencies of\n   * the object must have been at least partially loaded at some point,\n   * or an error will be thrown.\n   */extract(rootId){const db=this._db;return db.transaction(()=>{// Pre-compute transitive dependencies into a temporary table.\ndb.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject32||(_templateObject32=_taggedTemplateLiteral([\"          CREATE TEMPORARY TABLE transitive_dependencies (\\n              id TEXT NOT NULL PRIMARY KEY,\\n              typename TEXT NOT NULL\\n          )\\n        \"],[\"\\\\\\n          CREATE TEMPORARY TABLE transitive_dependencies (\\n              id TEXT NOT NULL PRIMARY KEY,\\n              typename TEXT NOT NULL\\n          )\\n        \"])))).run();try{db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject33||(_templateObject33=_taggedTemplateLiteral([\"            WITH RECURSIVE\\n            cte_direct_deps (parent_id, child_id) AS (\\n                SELECT parent_id, child_id FROM links\\n                WHERE child_id IS NOT NULL\\n                UNION\\n                SELECT DISTINCT\\n                    connections.object_id AS parent_id,\\n                    connection_entries.child_id AS child_id\\n                FROM connections JOIN connection_entries\\n                ON connections.rowid = connection_entries.connection_id\\n                WHERE child_id IS NOT NULL\\n            ),\\n            cte_transitive_deps (id) AS (\\n                VALUES (:rootId) UNION\\n                SELECT cte_direct_deps.child_id\\n                FROM cte_transitive_deps JOIN cte_direct_deps\\n                ON cte_transitive_deps.id = cte_direct_deps.parent_id\\n            )\\n            INSERT INTO transitive_dependencies (id, typename)\\n            SELECT objects.id AS id, objects.typename AS typename\\n            FROM objects JOIN cte_transitive_deps\\n            ON objects.id = cte_transitive_deps.id\\n          \"],[\"\\\\\\n            WITH RECURSIVE\\n            cte_direct_deps (parent_id, child_id) AS (\\n                SELECT parent_id, child_id FROM links\\n                WHERE child_id IS NOT NULL\\n                UNION\\n                SELECT DISTINCT\\n                    connections.object_id AS parent_id,\\n                    connection_entries.child_id AS child_id\\n                FROM connections JOIN connection_entries\\n                ON connections.rowid = connection_entries.connection_id\\n                WHERE child_id IS NOT NULL\\n            ),\\n            cte_transitive_deps (id) AS (\\n                VALUES (:rootId) UNION\\n                SELECT cte_direct_deps.child_id\\n                FROM cte_transitive_deps JOIN cte_direct_deps\\n                ON cte_transitive_deps.id = cte_direct_deps.parent_id\\n            )\\n            INSERT INTO transitive_dependencies (id, typename)\\n            SELECT objects.id AS id, objects.typename AS typename\\n            FROM objects JOIN cte_transitive_deps\\n            ON objects.id = cte_transitive_deps.id\\n          \"])))).run({rootId});// Check to make sure all required objects and connections have\n// been updated at least once.\n{const neverUpdatedEntry=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject34||(_templateObject34=_taggedTemplateLiteral([\"                SELECT objects.id AS id, NULL as fieldname\\n                FROM transitive_dependencies\\n                JOIN objects USING (id)\\n                WHERE objects.last_update IS NULL\\n                UNION ALL\\n                SELECT objects.id AS id, connections.fieldname AS fieldname\\n                FROM transitive_dependencies\\n                JOIN objects\\n                    USING (id)\\n                LEFT OUTER JOIN connections\\n                    ON objects.id = connections.object_id\\n                WHERE\\n                    connections.rowid IS NOT NULL\\n                    AND connections.last_update IS NULL\\n              \"],[\"\\\\\\n                SELECT objects.id AS id, NULL as fieldname\\n                FROM transitive_dependencies\\n                JOIN objects USING (id)\\n                WHERE objects.last_update IS NULL\\n                UNION ALL\\n                SELECT objects.id AS id, connections.fieldname AS fieldname\\n                FROM transitive_dependencies\\n                JOIN objects\\n                    USING (id)\\n                LEFT OUTER JOIN connections\\n                    ON objects.id = connections.object_id\\n                WHERE\\n                    connections.rowid IS NOT NULL\\n                    AND connections.last_update IS NULL\\n              \"])))).get();if(neverUpdatedEntry!==undefined){const entry=neverUpdatedEntry;const s=JSON.stringify;const missingData=entry.fieldname==null?\"own data\":\"\".concat(s(entry.fieldname),\" connection\");throw new Error(\"\".concat(s(rootId),\" transitively depends on \").concat(s(entry.id),\", \")+\"but that object's \".concat(missingData,\" has never been fetched\"));}}// Constructing the result set inherently requires mutation,\n// because the object graph can have cycles. We start by\n// creating a record for each object, with just that object's\n// typename and ID. Then, we link in primitives, node\n// references, and connection entries.\nconst allObjects=new Map();// Initialize `allObjects`.\n{const getObjects=db.prepare(\"SELECT id AS id, typename AS typename FROM transitive_dependencies\");for(const object of getObjects.iterate()){allObjects.set(object.id,{id:object.id,__typename:object.typename});}}// Fill in primitive data.\n{const getPrimitives=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject35||(_templateObject35=_taggedTemplateLiteral([\"              SELECT\\n                object_id AS objectId,\\n                fieldname AS name,\\n                value AS value\\n              FROM transitive_dependencies JOIN primitives\\n              ON transitive_dependencies.id = primitives.object_id\\n              -- Order by field name to ensure that nested fields appear\\n              -- before their eggs: e.g., \\\"author\\\" before \\\"author.user\\\".\\n              ORDER BY fieldname ASC\\n            \"],[\"\\\\\\n              SELECT\\n                object_id AS objectId,\\n                fieldname AS name,\\n                value AS value\\n              FROM transitive_dependencies JOIN primitives\\n              ON transitive_dependencies.id = primitives.object_id\\n              -- Order by field name to ensure that nested fields appear\\n              -- before their eggs: e.g., \\\"author\\\" before \\\"author.user\\\".\\n              ORDER BY fieldname ASC\\n            \"]))));for(const field of getPrimitives.iterate()){const object=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](allObjects.get(field.objectId));if(field.value===0){// Nested object is absent.\nobject[field.name]=null;}else if(field.value===1){// Nested object is present.\nobject[field.name]={};}else{// Normal field, not nested object indicator.\nconst value=JSON.parse(field.value);const parts=field.name.split(\".\");switch(parts.length){case 1:object[field.name]=value;break;case 2:{const[nestName,eggName]=parts;if(object[nestName]!==null){object[nestName][eggName]=value;}break;}// istanbul ignore next: should not be possible\ndefault:throw new Error(\"Corruption: bad field name: \".concat(JSON.stringify(field.name)));}}}}// Add links.\n{const getLinks=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject36||(_templateObject36=_taggedTemplateLiteral([\"              SELECT\\n                parent_id AS parentId,\\n                fieldname AS fieldname,\\n                child_id AS childId\\n              FROM transitive_dependencies JOIN links\\n              ON transitive_dependencies.id = links.parent_id\\n            \"],[\"\\\\\\n              SELECT\\n                parent_id AS parentId,\\n                fieldname AS fieldname,\\n                child_id AS childId\\n              FROM transitive_dependencies JOIN links\\n              ON transitive_dependencies.id = links.parent_id\\n            \"]))));for(const link of getLinks.iterate()){const parent=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](allObjects.get(link.parentId));const child=link.childId==null?null:_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](allObjects.get(link.childId));const{fieldname}=link;const parts=fieldname.split(\".\");switch(parts.length){case 1:parent[fieldname]=child;break;case 2:{const[nestName,eggName]=parts;if(parent[nestName]!==null){parent[nestName][eggName]=child;}break;}// istanbul ignore next: should not be possible\ndefault:throw new Error(\"Corruption: bad link name: \".concat(JSON.stringify(fieldname)));}}}// Add connections.\n{const getConnectionData=db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject37||(_templateObject37=_taggedTemplateLiteral([\"              SELECT\\n                  objects.id AS parentId,\\n                  connections.fieldname AS fieldname,\\n                  connection_entries.connection_id IS NOT NULL AS hasContents,\\n                  connection_entries.child_id AS childId\\n              FROM transitive_dependencies\\n              JOIN objects\\n                  USING (id)\\n              JOIN connections\\n                  ON objects.id = connections.object_id\\n              LEFT OUTER JOIN connection_entries\\n                  ON connections.rowid = connection_entries.connection_id\\n              ORDER BY\\n                  objects.id, connections.fieldname, connection_entries.idx ASC\\n            \"],[\"\\\\\\n              SELECT\\n                  objects.id AS parentId,\\n                  connections.fieldname AS fieldname,\\n                  connection_entries.connection_id IS NOT NULL AS hasContents,\\n                  connection_entries.child_id AS childId\\n              FROM transitive_dependencies\\n              JOIN objects\\n                  USING (id)\\n              JOIN connections\\n                  ON objects.id = connections.object_id\\n              LEFT OUTER JOIN connection_entries\\n                  ON connections.rowid = connection_entries.connection_id\\n              ORDER BY\\n                  objects.id, connections.fieldname, connection_entries.idx ASC\\n            \"]))));for(const datum of getConnectionData.iterate()){const parent=_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](allObjects.get(datum.parentId));if(parent[datum.fieldname]===undefined){parent[datum.fieldname]=[];}if(datum.hasContents){const child=datum.childId==null?null:_util_null__WEBPACK_IMPORTED_MODULE_4__[\"get\"](allObjects.get(datum.childId));parent[datum.fieldname].push(child);}}}const result=allObjects.get(rootId);if(result===undefined){throw new Error(\"No such object: \"+JSON.stringify(rootId));}return result;}finally{this._db.prepare(\"DROP TABLE temp.transitive_dependencies\").run();}})();}}/**\n * Decomposition of a schema, grouping types by their kind (object vs.\n * union) and object fields by their kind (primitive vs. link vs.\n * connection).\n *\n * All arrays contain elements in arbitrary order.\n */function _buildSchemaInfo(schema){const result={objectTypes:{},unionTypes:{}};for(const typename of Object.keys(schema)){const type=schema[typename];switch(type.type){case\"SCALAR\":// Nothing to do.\nbreak;case\"ENUM\":// Nothing to do.\nbreak;case\"OBJECT\":{const entry={fields:type.fields,nestedFields:{},primitiveFieldNames:[],linkFieldNames:[],connectionFieldNames:[],nestedFieldNames:[]};result.objectTypes[typename]=entry;for(const fieldname of Object.keys(type.fields)){const field=type.fields[fieldname];switch(field.type){case\"ID\":break;case\"PRIMITIVE\":entry.primitiveFieldNames.push(fieldname);break;case\"NODE\":entry.linkFieldNames.push(fieldname);break;case\"CONNECTION\":entry.connectionFieldNames.push(fieldname);break;case\"NESTED\":{entry.nestedFieldNames.push(fieldname);const nestedFieldData={primitives:{},nodes:{}};for(const eggFieldname of Object.keys(field.eggs)){const eggField=field.eggs[eggFieldname];switch(eggField.type){case\"PRIMITIVE\":nestedFieldData.primitives[eggFieldname]=eggField;break;case\"NODE\":nestedFieldData.nodes[eggFieldname]=eggField;break;// istanbul ignore next\ndefault:throw new Error(eggField.type);}}entry.nestedFields[fieldname]=nestedFieldData;break;}// istanbul ignore next\ndefault:throw new Error(field.type);}}break;}case\"UNION\":{const entry={clauses:Object.keys(type.clauses)};result.unionTypes[typename]=entry;break;}// istanbul ignore next\ndefault:throw new Error(type.type);}}return result;}const _FIELD_PREFIXES=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({/**\n   * A key of an `UpdateResult` has this prefix if and only if the\n   * corresponding value represents `TypenamesUpdateResult`s.\n   */TYPENAMES:\"typenames_\",/**\n   * A key of an `UpdateResult` has this prefix if and only if the\n   * corresponding value represents `OwnDataUpdateResult`s.\n   */OWN_DATA:\"owndata_\",/**\n   * A key of an `UpdateResult` has this prefix if and only if the\n   * corresponding value represents `NodeConnectionsUpdateResult`s.\n   */NODE_CONNECTIONS:\"node_\"});/**\n * Convert a prepared statement into a JS function that executes that\n * statement and asserts that it makes exactly one change to the\n * database.\n *\n * The prepared statement must use only named parameters, not positional\n * parameters.\n *\n * The prepared statement must not return data (e.g., INSERT and UPDATE\n * are okay; SELECT is not).\n *\n * The statement is not executed inside an additional transaction, so in\n * the case that the assertion fails, the effects of the statement are\n * not rolled back by this function.\n *\n * This is useful when the statement is like `UPDATE ... WHERE id = ?`\n * and it is assumed that `id` is a primary key for a record already\n * exists---if either existence or uniqueness fails, this method will\n * raise an error quickly instead of leading to a corrupt state.\n *\n * For example, this code...\n *\n *     const setName: ({|+userId: string, +newName: string|}) => void =\n *       _makeSingleUpdateFunction(\n *         \"UPDATE users SET name = :newName WHERE id = :userId\"\n *       );\n *     setName({userId: \"user:foo\", newName: \"The Magnificent Foo\"});\n *\n * ...will update `user:foo`'s name, or throw an error if there is no\n * such user or if multiple users have this ID.\n */function _makeSingleUpdateFunction(stmt){if(stmt.reader){throw new Error(\"Cannot create update function for statement that returns data: \"+stmt.source);}return args=>{const result=stmt.run(args);if(result.changes!==1){throw new Error(\"Bad change count: \"+JSON.stringify({source:stmt.source,args,changes:result.changes}));}};}\n\n//# sourceURL=webpack:///./src/graphql/mirror.js?");

/***/ }),

/***/ "./src/graphql/queries.js":
/*!********************************!*\
  !*** ./src/graphql/queries.js ***!
  \********************************/
/*! exports provided: build, multilineLayout, inlineLayout, stringify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"build\", function() { return build; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multilineLayout\", function() { return multilineLayout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inlineLayout\", function() { return inlineLayout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringify\", function() { return stringify; });\n/**\n * GraphQL structured query data format.\n *\n * Main module exports:\n *   - lots of types for various GraphQL language constructs\n *   - the `build` object, providing a fluent builder API\n *   - the `stringify` object, and particularly `stringify.body`\n *   - the two layout strategies `multilineLayout` and `inlineLayout`\n */ // We only need opaque type handles; no need to embed the GraphQL type\n// system into Flow.\nconst build={query(name,params,selections){return{type:\"QUERY\",name,params,selections};},param(name,type){return{name,type};},fragment(name,typeCondition,selections){return{type:\"FRAGMENT\",name,typeCondition,selections};},field(name,args,selections){return{type:\"FIELD\",alias:null,name,args:args||{},selections:selections||[]};},alias(newAlias,field){return{type:\"FIELD\",alias:newAlias,name:field.name,args:field.args,selections:field.selections};},fragmentSpread(fragmentName){return{type:\"FRAGMENT_SPREAD\",fragmentName};},inlineFragment(typeCondition,selections){return{type:\"INLINE_FRAGMENT\",typeCondition,selections};},variable(name){return{type:\"VARIABLE\",data:name};},literal(value){return{type:\"LITERAL\",data:value};},enumLiteral(value){return{type:\"ENUM\",data:value};},list(data){return{type:\"LIST\",data:data};},object(data){return{type:\"OBJECT\",data:data};}};/**\n * A strategy for stringifying a sequence of GraphQL language tokens.\n */ /**\n * Create a layout strategy that lays out text over multiple lines,\n * indenting with the given tab string (such as \"\\t\" or \"  \").\n */function multilineLayout(tab){function strategy(indentLevel){return{atom:line=>{const indentation=Array(indentLevel).fill(tab).join(\"\");return indentation+line;},join:xs=>xs.join(\"\\n\"),next:()=>strategy(indentLevel+1)};}return strategy(0);}/**\n * Create a layout strategy that lays out all text on one line.\n */function inlineLayout(){const result={atom:line=>line,join:xs=>xs.join(\" \"),next:()=>result};return result;}/*\n * Map a stringification function across a list, and join the results\n * with a formatter.\n */function formatList(values,subformatter,ls){return ls.join(values.map(x=>subformatter(x,ls)));}/*\n * Map a stringification function across the values of an object, and\n * join the keys and their corresponding results with a formatter.\n */function formatObject(object,subformatter,ls){function formatKey(k,ls){return ls.join([ls.atom(\"\".concat(k,\":\")),subformatter(object[k],ls.next())]);}return formatList(Object.keys(object),formatKey,ls);}const stringify={body(body,ls){return formatList(body,stringify.definition,ls);},definition(definition,ls){switch(definition.type){case\"QUERY\":return stringify.queryDefinition(definition,ls);case\"FRAGMENT\":return stringify.fragmentDefinition(definition,ls);// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(\"Unknown definition type: \".concat(definition.type));}},queryDefinition(query,ls){const paramsPart=(()=>{if(query.params.length===0){return\"\";}else{const items=formatList(query.params,stringify.parameter,inlineLayout());return\"(\".concat(items,\")\");}})();const selectionsPart=formatList(query.selections,stringify.selection,ls.next());return ls.join([ls.atom(\"query \".concat(query.name).concat(paramsPart,\" {\")),selectionsPart,ls.atom(\"}\")]);},parameter(parameter,ls){return ls.atom(\"$\".concat(parameter.name,\": \").concat(parameter.type));},fragmentDefinition(fragment,ls){const selectionsPart=formatList(fragment.selections,stringify.selection,ls.next());return ls.join([ls.atom(\"fragment \".concat(fragment.name,\" on \").concat(fragment.typeCondition,\" {\")),selectionsPart,ls.atom(\"}\")]);},selection(selection,ls){switch(selection.type){case\"FIELD\":return stringify.field(selection,ls);case\"FRAGMENT_SPREAD\":return stringify.fragmentSpread(selection,ls);case\"INLINE_FRAGMENT\":return stringify.inlineFragment(selection,ls);// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(\"Unknown selection type: \".concat(selection.type));}},field(field,ls){const aliasPart=(()=>{if(field.alias==null){return\"\";}else{return\"\".concat(field.alias,\": \");}})();const argsPart=(()=>{if(Object.keys(field.args).length===0){return\"\";}else{const args=formatObject(field.args,stringify.value,inlineLayout());return\"(\".concat(args,\")\");}})();if(field.selections.length===0){return ls.atom(\"\".concat(field.name).concat(argsPart));}else{const selectionsPart=formatList(field.selections,stringify.selection,ls.next());return ls.join([ls.atom(\"\".concat(aliasPart).concat(field.name).concat(argsPart,\" {\")),selectionsPart,ls.atom(\"}\")]);}},fragmentSpread(fs,ls){return ls.atom(\"...\".concat(fs.fragmentName));},inlineFragment(fragment,ls){const typeConditionPart=fragment.typeCondition==null?\"\":\" on \".concat(fragment.typeCondition);const selectionsPart=formatList(fragment.selections,stringify.selection,ls.next());return ls.join([ls.atom(\"...\".concat(typeConditionPart,\" {\")),selectionsPart,ls.atom(\"}\")]);},value(value,ls){switch(value.type){case\"VARIABLE\":return stringify.variableValue(value,ls);case\"LITERAL\":return stringify.literalValue(value,ls);case\"ENUM\":return stringify.enumValue(value,ls);case\"LIST\":return stringify.listValue(value,ls);case\"OBJECT\":return stringify.objectValue(value,ls);// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(\"Unknown value type: \".concat(value.type));}},variableValue(value,ls){return ls.atom(\"$\".concat(value.data));},literalValue(value,ls){return ls.atom(JSON.stringify(value.data));},enumValue(value,ls){return ls.atom(value.data);},listValue(value,ls){return ls.join([ls.atom(\"[\"),formatList(value.data,stringify.value,ls.next()),ls.atom(\"]\")]);},objectValue(value,ls){return ls.join([ls.atom(\"{\"),formatObject(value.data,stringify.value,ls.next()),ls.atom(\"}\")]);}};\n\n//# sourceURL=webpack:///./src/graphql/queries.js?");

/***/ }),

/***/ "./src/graphql/schema.js":
/*!*******************************!*\
  !*** ./src/graphql/schema.js ***!
  \*******************************/
/*! exports provided: faithful, unfaithful, schema, scalar, enum, object, union, id, primitive, node, connection, nonNull, nullable, nested */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"faithful\", function() { return faithful; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unfaithful\", function() { return unfaithful; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"schema\", function() { return schema; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scalar\", function() { return scalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enum\", function() { return enum_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"object\", function() { return object; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"union\", function() { return union; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"id\", function() { return id; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"primitive\", function() { return primitive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"node\", function() { return node; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connection\", function() { return connection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nonNull\", function() { return nonNull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nullable\", function() { return nullable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nested\", function() { return nested; });\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * Data types to describe a particular subset of GraphQL schemata.\n * Schemata represented by this module must satisfy these constraints:\n *\n *   - Every object must have an `id` field of primitive type.\n *   - Every field of an object must be either a primitive, a reference\n *     to a single (possibly nullable) object, or a _connection_ as\n *     described in the Relay cursor connections specification. In\n *     particular, no field may directly contain a list.\n *   - Interface types must be represented as unions of all their\n *     implementations.\n */ // The name of a GraphQL type, like `Repository` or `Int`.\n// The name of a GraphQL object field, like `name` or `pullRequests`.\n// The database-wide unique ID of a GraphQL object.\n// Description of a GraphQL schema. Types are represented as follows:\n//   - An object type is represented directly as an `OBJECT`.\n//   - A union type is represented directly as a `UNION`.\n//   - An interface type is represented as a `UNION` of all its\n//     implementations.\n//   - Scalars and enums may only occur as object fields, and are\n//     represented as `PRIMITIVE`s (except for `ID`s).\n//   - Connections are supported as object fields, but arbitrary lists\n//     are not.\n//\n// Primitive and enum fields on an object type may optionally be\n// annotated with their representations.\n//\n// To accommodate schemata where some object types do not have IDs,\n// objects may have \"nested\" fields of primitive or node-reference type.\n// These may be nested to depth exactly 1. Suppose that `Foo` is an\n// object type that includes `bar: Bar!`, but `Bar` is an object type\n// without an `id`. Then `Bar` may not be a first-class type, but `Foo`\n// may pull properties off of it using\n//\n//     bar: nested({x: primitive(), y: node(\"Baz\")});\n//\n// The property \"bar\" in the above example is called a _nested_\n// property, and its fields \"x\" and \"y\" are called _eggs_. (The nest\n// contains the eggs.)\n// A field is _faithful_ if selecting its `__typename` and `id` will\n// always yield the correct `__typename` for the node of the given ID.\n// In theory, this should always be the case, but some remote schemas\n// are broken. For details, see:\n//\n//   - https://github.com/sourcecred/sourcecred/issues/996\n//   - https://github.com/sourcecred/sourcecred/issues/998\n//\n// For an unfaithful field, the `actualTypenames` property lists all the\n// types of objects that can _actually_ be returned when the field is\n// queried. (This set only affects generated Flow types, not runtime\n// semantics.) These must all be object types.\n//\n// It is always sound to represent an actually-faithful field as\n// unfaithful, but doing so may incur additional queries. Marking a type\n// as faithful should be seen as an optimization that may be performed\n// only when the server is abiding by its contract for that field.\nfunction faithful(){return{type:\"FAITHFUL\"};}function unfaithful(actualTypenames){const actualTypenamesObject={};for(const t of actualTypenames){actualTypenamesObject[t]=true;}return{type:\"UNFAITHFUL\",actualTypenames:actualTypenamesObject};}// Every object must have exactly one `id` field, and it must have this\n// name.\nconst ID_FIELD_NAME=\"id\";function schema(types){function assertKind(path,elementTypename,validKinds){let{isFidelity=false}=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};const self=(isFidelity?\"unfaithful typenames list of \":\"\")+\"field \".concat(path.map(x=>JSON.stringify(x)).join(\"/\"));const elementType=types[elementTypename];if(elementType==null){throw new Error(\"\".concat(self,\" has unknown type: \\\"\").concat(elementTypename,\"\\\"\"));}if(!validKinds.includes(elementType.type)){throw new Error(\"\".concat(self,\" has invalid type \\\"\").concat(elementTypename,\"\\\" \")+\"of kind \\\"\".concat(elementType.type,\"\\\"\"));}}function validateFidelity(path,fidelity){switch(fidelity.type){case\"FAITHFUL\":break;case\"UNFAITHFUL\":for(const typename of Object.keys(fidelity.actualTypenames)){assertKind(path,typename,[\"OBJECT\"],{isFidelity:true});}break;// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(fidelity.type);}}const result={};for(const typename of Object.keys(types)){const type=types[typename];switch(type.type){case\"SCALAR\":result[typename]={type:\"SCALAR\",representation:type.representation};break;case\"ENUM\":result[typename]={type:\"ENUM\",values:_objectSpread({},type.values)};break;case\"OBJECT\":for(const fieldname of Object.keys(type.fields)){const field=type.fields[fieldname];switch(field.type){case\"ID\":// Nothing to check.\nbreak;case\"PRIMITIVE\":if(field.annotation!=null){assertKind([typename,fieldname],field.annotation.elementType,[\"SCALAR\",\"ENUM\"]);}break;case\"NODE\":assertKind([typename,fieldname],field.elementType,[\"OBJECT\",\"UNION\"]);validateFidelity([typename,fieldname],field.fidelity);break;case\"CONNECTION\":assertKind([typename,fieldname],field.elementType,[\"OBJECT\",\"UNION\"]);validateFidelity([typename,fieldname],field.fidelity);break;case\"NESTED\":for(const eggName of Object.keys(field.eggs)){const egg=field.eggs[eggName];switch(egg.type){case\"PRIMITIVE\":if(egg.annotation!=null){assertKind([typename,fieldname,eggName],egg.annotation.elementType,[\"SCALAR\",\"ENUM\"]);}break;case\"NODE\":assertKind([typename,fieldname,eggName],egg.elementType,[\"OBJECT\",\"UNION\"]);validateFidelity([typename,fieldname,eggName],egg.fidelity);break;// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(egg.type);}}break;// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(field.type);}}result[typename]={type:\"OBJECT\",fields:_objectSpread({},type.fields)};break;case\"UNION\":for(const clause of Object.keys(type.clauses)){const clauseType=types[clause];if(clauseType==null){throw new Error(\"union has unknown clause: \\\"\".concat(typename,\"\\\"/\\\"\").concat(clause,\"\\\"\"));}if(clauseType.type!==\"OBJECT\"){// The GraphQL spec doesn't permit unions of interfaces or\n// other unions (or primitives). This is nice, because it\n// means that we don't have to worry about ill-founded\n// unions.\nthrow new Error(\"union has non-object type clause: \\\"\".concat(typename,\"\\\"/\\\"\").concat(clause,\"\\\"\"));}}result[typename]={type:\"UNION\",clauses:_objectSpread({},type.clauses)};break;// istanbul ignore next\ndefault:throw new Error(type.type);}}return result;}function scalar(representation){return{type:\"SCALAR\",representation};}function enum_(values){const valuesObject={};for(const v of values){valuesObject[v]=true;}return{type:\"ENUM\",values:valuesObject};}function object(fields){for(const fieldname of Object.keys(fields)){const field=fields[fieldname];if(fieldname===\"__typename\"){throw new Error(\"reserved field name: \"+fieldname);}if(field.type===\"ID\"&&fieldname!==ID_FIELD_NAME){throw new Error(\"invalid ID field with name \\\"\".concat(fieldname,\"\\\"\"));}}if(fields[ID_FIELD_NAME]==null){throw new Error(\"expected ID field with name \\\"\".concat(ID_FIELD_NAME,\"\\\"\"));}if(fields[ID_FIELD_NAME].type!==\"ID\"){throw new Error(\"field \\\"\".concat(ID_FIELD_NAME,\"\\\" must be an ID field\"));}// Workaround for <https://github.com/facebook/flow/issues/7128>.\nconst exactFields=_objectSpread({},fields);return{type:\"OBJECT\",fields:exactFields};}function union(clauses){const clausesMap={};for(const clause of clauses){if(clausesMap[clause]!=null){throw new Error(\"duplicate union clause: \\\"\".concat(clause,\"\\\"\"));}clausesMap[clause]=true;}return{type:\"UNION\",clauses:clausesMap};}function id(){return{type:\"ID\"};}function primitive(annotation){return{type:\"PRIMITIVE\",annotation:annotation||null};}function node(elementType){let fidelity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:faithful();return{type:\"NODE\",elementType,fidelity};}function connection(elementType){let fidelity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:faithful();return{type:\"CONNECTION\",elementType,fidelity};}function nonNull(elementType){return{nonNull:true,elementType};}function nullable(elementType){return{nonNull:false,elementType};}function nested(eggs){return{type:\"NESTED\",eggs:_objectSpread({},eggs)};}\n\n//# sourceURL=webpack:///./src/graphql/schema.js?");

/***/ }),

/***/ "./src/plugins/discord/config.js":
/*!***************************************!*\
  !*** ./src/plugins/discord/config.js ***!
  \***************************************/
/*! exports provided: _upgrade, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_upgrade\", function() { return _upgrade; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models */ \"./src/plugins/discord/models.js\");\nconst parserJson=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({guildId:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"delimited\"](\"//\"),reactionWeightConfig:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({weights:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"dict\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"]),defaultWeight:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],applyAveraging:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"boolean\"]},{confidenceDampener:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"]})},{roleWeightConfig:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({defaultWeight:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],weights:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"dict\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"delimited\"](\"//\"))}),channelWeightConfig:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"object\"]({defaultWeight:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],weights:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"dict\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"number\"],_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"delimited\"](\"//\"))}),propsChannels:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"]),includeNsfwChannels:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"boolean\"],simplifyGraph:_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"boolean\"]}));/**\n * Upgrade from the version on disk to the DiscordConfig.\n *\n * For now, this allows us to refactor to a cleaner internal type without breaking any existing users.\n * We may need this indefinitely if e.g. we decide to de-serialize the raw JSON into maps (since maps\n * can't be written directly to JSON).\n */function _upgrade(json){const defaultReactionWeights={defaultWeight:1,weights:{},applyAveraging:false};const defaultRoleWeights={defaultWeight:1,weights:{}};const defaultChannelWeights={defaultWeight:1,weights:{}};return json.map(config=>({guildId:config.guildId,weights:{roleWeights:_util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](config.roleWeightConfig,defaultRoleWeights),emojiWeights:_util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](config.reactionWeightConfig,defaultReactionWeights),channelWeights:_util_null__WEBPACK_IMPORTED_MODULE_0__[\"orElse\"](config.channelWeightConfig,defaultChannelWeights)},propsChannels:config.propsChannels||[],includeNsfwChannels:config.includeNsfwChannels||false,simplifyGraph:config.simplifyGraph||false}));}const parser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](parserJson,_upgrade);\n\n//# sourceURL=webpack:///./src/plugins/discord/config.js?");

/***/ }),

/***/ "./src/plugins/discord/createGraph.js":
/*!********************************************!*\
  !*** ./src/plugins/discord/createGraph.js ***!
  \********************************************/
/*! exports provided: userAddress, memberAddress, findGraphMessages, createGraph, _createGraphFromMessages */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"userAddress\", function() { return userAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memberAddress\", function() { return memberAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findGraphMessages\", function() { return findGraphMessages; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGraph\", function() { return createGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_createGraphFromMessages\", function() { return _createGraphFromMessages; });\n/* harmony import */ var entities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! entities */ \"entities\");\n/* harmony import */ var entities__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(entities__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_weights__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/weights */ \"./src/core/weights.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _mirrorRepository__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mirrorRepository */ \"./src/plugins/discord/mirrorRepository.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/discord/declaration.js\");\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./models */ \"./src/plugins/discord/models.js\");\n/* harmony import */ var _reactionWeights__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./reactionWeights */ \"./src/plugins/discord/reactionWeights.js\");\n// Display this many characters in description.\nconst MESSAGE_LENGTH=30;function messageUrl(guild,channel,message){return\"https://discordapp.com/channels/\".concat(guild,\"/\").concat(channel,\"/\").concat(message);}function userAddress(userId){return _core_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"memberNodeType\"].prefix,\"user\",userId);}function memberAddress(member){return _core_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"memberNodeType\"].prefix,member.user.bot?\"bot\":\"user\",member.user.id);}function messageAddress(message){return _core_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"messageNodeType\"].prefix,message.channelId,message.id);}function reactionAddress(reaction){// Hacky order, so we can boost categories.\nreturn _core_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"reactionNodeType\"].prefix,reaction.channelId,_models__WEBPACK_IMPORTED_MODULE_5__[\"emojiToRef\"](reaction.emoji),reaction.authorId,reaction.messageId);}function memberNode(member){const description=\"discord/\".concat(Object(entities__WEBPACK_IMPORTED_MODULE_0__[\"escape\"])(member.user.username.slice(0,20)),\"#\").concat(member.user.discriminator);return{address:memberAddress(member),description,timestampMs:null};}function messageNode(message,guild,channelName){const url=messageUrl(guild,message.channelId,message.id);const partialMessage=Object(entities__WEBPACK_IMPORTED_MODULE_0__[\"escape\"])(message.content.substring(0,MESSAGE_LENGTH));const description=\"#\".concat(channelName,\" message [\\\"\").concat(partialMessage,\"...\\\"](\").concat(url,\")\");return{address:messageAddress(message),description,timestampMs:message.timestampMs};}function authorsMessageEdge(message,author){const address=_core_graph__WEBPACK_IMPORTED_MODULE_2__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"authorsMessageEdgeType\"].prefix,author.user.bot?\"bot\":\"user\",author.user.id,message.channelId,message.id);return{address,timestampMs:message.timestampMs,src:memberAddress(author),dst:messageAddress(message)};}function reactionNode(reaction,timestampMs,guild){const msgUrl=messageUrl(guild,reaction.channelId,reaction.messageId);const reactionStr=reaction.emoji.id?\":\".concat(reaction.emoji.name,\":\"):reaction.emoji.name;const description=\"Reacted `\".concat(reactionStr,\"` to message [\").concat(reaction.messageId,\"](\").concat(msgUrl,\")\");return{address:reactionAddress(reaction),description,timestampMs};}function addsReactionEdge(reaction,member,timestampMs){const address=_core_graph__WEBPACK_IMPORTED_MODULE_2__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"addsReactionEdgeType\"].prefix,member.user.bot?\"bot\":\"user\",member.user.id,_models__WEBPACK_IMPORTED_MODULE_5__[\"emojiToRef\"](reaction.emoji),reaction.channelId,reaction.messageId);return{address,// TODO: for now using timestamp of the message,\n// as reactions don't have timestamps.\ntimestampMs,src:memberAddress(member),dst:reactionAddress(reaction)};}function reactsToEdge(reaction,message){const address=_core_graph__WEBPACK_IMPORTED_MODULE_2__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"reactsToEdgeType\"].prefix,_models__WEBPACK_IMPORTED_MODULE_5__[\"emojiToRef\"](reaction.emoji),reaction.authorId,reaction.channelId,reaction.messageId);return{address,// TODO: for now using timestamp of the message,\n// as reactions don't have timestamps.\ntimestampMs:message.timestampMs,src:reactionAddress(reaction),dst:messageAddress(message)};}function mentionsEdge(message,member){const address=_core_graph__WEBPACK_IMPORTED_MODULE_2__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"mentionsEdgeType\"].prefix,message.channelId,message.authorId,message.id,member.user.bot?\"bot\":\"user\",member.user.id);return{address,timestampMs:message.timestampMs,src:messageAddress(message),dst:memberAddress(member)};}function propsEdge(message,member){const address=_core_graph__WEBPACK_IMPORTED_MODULE_2__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"propsEdgeType\"].prefix,message.channelId,message.authorId,message.id,member.user.bot?\"bot\":\"user\",member.user.id);return{address,timestampMs:message.timestampMs,src:messageAddress(message),dst:memberAddress(member)};}/**\n * Find all of the messages that should go into the graph.\n * This will deliberately ignore messages that have no reactions, since\n * they have no Cred impact and don't need to go into the graph.\n */function*findGraphMessages(repo){const memberMap=new Map(repo.members().map(m=>[m.user.id,m]));for(const channel of repo.channels()){for(const message of repo.messages(channel.id)){if(message.nonUserAuthor){continue;}const reactions=[];for(const reaction of repo.reactions(channel.id,message.id)){const reactingMember=memberMap.get(reaction.authorId);if(!reactingMember){// Probably this user left the server.\n// Let's ignore this reaction (keeping the rest of the message)\ncontinue;}reactions.push({reaction,reactingMember});}const mentions=[];for(const{userId,count}of message.mentions){const mentionedMember=memberMap.get(userId);if(!mentionedMember){// Probably this user left the server.\n// We'll skip this mention (keeping the rest of the message)\ncontinue;}mentions.push({member:mentionedMember,count});}if(mentions.length===0&&reactions.length===0){// No valid mentions or reactions, meaning this message won't have real Cred effects.\n// let's skip it.\ncontinue;}const author=memberMap.get(message.authorId)||null;yield{message,author,reactions,mentions,channelName:channel.name,channelId:channel.id,channelParentId:channel.parentId};}}}function createGraph(config,repo){const graphMessages=findGraphMessages(repo);return _createGraphFromMessages(config,graphMessages);}function _createGraphFromMessages(config,messages){const wg={graph:new _core_graph__WEBPACK_IMPORTED_MODULE_2__[\"Graph\"](),weights:Object(_core_weights__WEBPACK_IMPORTED_MODULE_1__[\"empty\"])()};const{guildId,weights}=config;const propsChannels=new Set(config.propsChannels);for(const graphMessage of messages){const{message,author,reactions,mentions,channelName,channelId,channelParentId}=graphMessage;let messageWeight=0;for(const{reaction,reactingMember}of reactions){const weight=Object(_reactionWeights__WEBPACK_IMPORTED_MODULE_6__[\"reactionWeight\"])({weights,message,reaction,reactingMember,propsChannels,reactions,channelParentId});messageWeight+=weight;if(weight&&!config.simplifyGraph){const node=reactionNode(reaction,message.timestampMs,guildId);wg.weights.nodeWeights.set(node.address,weight);wg.graph.addNode(node);wg.graph.addNode(memberNode(reactingMember));wg.graph.addEdge(reactsToEdge(reaction,message));wg.graph.addEdge(addsReactionEdge(reaction,reactingMember,message.timestampMs));}}if(!messageWeight)continue;if(author){wg.graph.addNode(memberNode(author));wg.graph.addEdge(authorsMessageEdge(message,author));}wg.graph.addNode(messageNode(message,guildId,channelName));if(config.simplifyGraph)wg.weights.nodeWeights.set(messageAddress(message),messageWeight);for(const{member,count}of mentions){wg.graph.addNode(memberNode(member));let edge;if(propsChannels.has(channelId)){edge=propsEdge(message,member);}else{edge=mentionsEdge(message,member);}wg.graph.addEdge(edge);if(count>1)wg.weights.edgeWeights.set(edge.address,{forwards:count,backwards:1});}}return wg;}\n\n//# sourceURL=webpack:///./src/plugins/discord/createGraph.js?");

/***/ }),

/***/ "./src/plugins/discord/createIdentities.js":
/*!*************************************************!*\
  !*** ./src/plugins/discord/createIdentities.js ***!
  \*************************************************/
/*! exports provided: createIdentity, createIdentities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createIdentity\", function() { return createIdentity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createIdentities\", function() { return createIdentities; });\n/* harmony import */ var entities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! entities */ \"entities\");\n/* harmony import */ var entities__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(entities__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mirrorRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mirrorRepository */ \"./src/plugins/discord/mirrorRepository.js\");\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models */ \"./src/plugins/discord/models.js\");\n/* harmony import */ var _createGraph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createGraph */ \"./src/plugins/discord/createGraph.js\");\n/* harmony import */ var _core_identity_name__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/identity/name */ \"./src/core/identity/name.js\");\nfunction createIdentity(member){let name=member.nick||member.user.username;name=Object(_core_identity_name__WEBPACK_IMPORTED_MODULE_4__[\"coerce\"])(name.slice(0,39));if(name.match(/^-+$/)){name=Object(_core_identity_name__WEBPACK_IMPORTED_MODULE_4__[\"coerce\"])(\"discord-\"+member.user.id);}const description=\"discord/\".concat(Object(entities__WEBPACK_IMPORTED_MODULE_0__[\"escape\"])(name),\"#\").concat(member.user.discriminator);const alias={description,address:Object(_createGraph__WEBPACK_IMPORTED_MODULE_3__[\"memberAddress\"])(member)};const type=member.user.bot?\"BOT\":\"USER\";return{pluginName:Object(_core_identity_name__WEBPACK_IMPORTED_MODULE_4__[\"nameFromString\"])(\"discord\"),name,type,alias};}function createIdentities(repo){return repo.members().map(m=>createIdentity(m));}\n\n//# sourceURL=webpack:///./src/plugins/discord/createIdentities.js?");

/***/ }),

/***/ "./src/plugins/discord/declaration.js":
/*!********************************************!*\
  !*** ./src/plugins/discord/declaration.js ***!
  \********************************************/
/*! exports provided: nodePrefix, edgePrefix, memberNodeType, messageNodeType, reactionNodeType, authorsMessageEdgeType, addsReactionEdgeType, reactsToEdgeType, mentionsEdgeType, propsEdgeType, declaration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodePrefix\", function() { return nodePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgePrefix\", function() { return edgePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memberNodeType\", function() { return memberNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"messageNodeType\", function() { return messageNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reactionNodeType\", function() { return reactionNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authorsMessageEdgeType\", function() { return authorsMessageEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addsReactionEdgeType\", function() { return addsReactionEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reactsToEdgeType\", function() { return reactsToEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mentionsEdgeType\", function() { return mentionsEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"propsEdgeType\", function() { return propsEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"declaration\", function() { return declaration; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\nconst nodePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts([\"sourcecred\",\"discord\"]);const edgePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].fromParts([\"sourcecred\",\"discord\"]);const memberNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Member\",pluralName:\"Members\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"MEMBER\"),defaultWeight:0,description:\"A member of the Discord server\"});const messageNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Message\",pluralName:\"Messages\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"MESSAGE\"),defaultWeight:0,description:\"A Discord message, posted in a particular channel\"});const reactionNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Reaction\",pluralName:\"Reactions\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"REACTION\"),defaultWeight:1,description:\"A reaction by some user, directed at some message\"});const authorsMessageEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"authors message\",backwardName:\"message is authored by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"AUTHORS\",\"MESSAGE\"),defaultWeight:{forwards:1/4,backwards:1},description:\"Connects an author to a message they've created.\"});const addsReactionEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"adds reaction\",backwardName:\"reaction added by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"ADDS_REACTION\"),defaultWeight:{forwards:1,backwards:1/16},description:\"Connects a member to a reaction that they added.\"});const reactsToEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"reacts to\",backwardName:\"is reacted to by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"REACTS_TO\"),defaultWeight:{forwards:1,backwards:1/16},description:\"Connects a reaction to a message that it reacts to.\"});const mentionsEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"mentions\",backwardName:\"is mentioned by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"MENTIONS\"),defaultWeight:{forwards:1,backwards:1/16},description:\"Connects a message to the member being mentioned.\"});const propsEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"gives props to\",backwardName:\"recieves props from\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"PROPS\"),// We set the default forward weight to 19x because message authors get a\n// 1x weight by default, so in the most common case of a props with a\n// single recipient, the props author will get 5% of the Cred and the\n// props-ee will get 95%.\ndefaultWeight:{forwards:19,backwards:1/16},description:\"Connects a props message to the person getting props\"});const declaration=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Discord\",nodePrefix,edgePrefix,nodeTypes:[memberNodeType,messageNodeType,reactionNodeType],edgeTypes:[authorsMessageEdgeType,addsReactionEdgeType,reactsToEdgeType,mentionsEdgeType,propsEdgeType],userTypes:[memberNodeType]});\n\n//# sourceURL=webpack:///./src/plugins/discord/declaration.js?");

/***/ }),

/***/ "./src/plugins/discord/fetcher.js":
/*!****************************************!*\
  !*** ./src/plugins/discord/fetcher.js ***!
  \****************************************/
/*! exports provided: Fetcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fetcher\", function() { return Fetcher; });\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! isomorphic-fetch */ \"isomorphic-fetch\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models */ \"./src/plugins/discord/models.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const fetcherDefaults={apiUrl:\"https://discordapp.com/api\",token:null,fetch: (isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0___default())};class Fetcher{constructor(opts){_defineProperty(this,\"_options\",void 0);_defineProperty(this,\"_timeout\",void 0);this._options=_objectSpread(_objectSpread({},fetcherDefaults),opts);if(!this._options.token){throw new Error(\"A BotToken is required\");}this._timeout=0;}_fetch(endpoint){const{apiUrl,token}=this._options;if(!token){throw new Error(\"A BotToken is required\");}const requestOptions={method:\"GET\",headers:{Accept:\"application/json\",Authorization:\"Bot \".concat(token)}};const url=new URL(\"\".concat(apiUrl).concat(endpoint)).href;return this._options.fetch(url,requestOptions);}async _wait(){const currentTime=Date.now();// if timeout hasn't passed, we wait until it does\nif(currentTime<this._timeout){const restartDate=new Date(this._timeout);const waitTime=this._timeout-currentTime;console.warn(\"Discord Rate limit reached. Waiting for \".concat(waitTime/1000,\" seconds (until \").concat(restartDate.toLocaleString(),\")\"));await new Promise(resolve=>setTimeout(resolve,waitTime));}}_checkRateLimit(res){// The discord API returns this header to indicate how many requests remain\n// before hitting a cooldown.\nconst rateLimitRemaining=Number(res.headers.get(\"x-ratelimit-remaining\"));// The discord API returns this epoc time (in seconds) to let us know\n// when we can continue.\nconst rateLimitReset=Number(res.headers.get(\"x-ratelimit-reset\"))*1000;// wait until the timeout passes  before attempting another query\nif(rateLimitRemaining===0){this._timeout=rateLimitReset;}}async _fetchJson(endpoint){await this._wait();const res=await this._fetch(endpoint);failIfMissing(res);failForNotOk(res);this._checkRateLimit(res);return await res.json();}async guilds(){const guilds=await this._fetchJson(\"/users/@me/guilds\");return guilds.map(x=>({id:x.id,name:x.name,permissions:x.permissions}));}async emojis(guild){const emojis=await this._fetchJson(\"/guilds/\".concat(guild,\"/emojis\"));return emojis.map(x=>({id:x.id,name:x.name}));}async channels(guild){const channels=await this._fetchJson(\"/guilds/\".concat(guild,\"/channels\"));return channels.map(x=>({id:x.id,parentId:x.parent_id,name:x.name,type:_models__WEBPACK_IMPORTED_MODULE_1__[\"channelTypeFromId\"](x.type),nsfw:x.nsfw}));}async roles(guild){const roles=await this._fetchJson(\"/guilds/\".concat(guild,\"/roles\"));return roles.map(x=>({id:x.id,name:x.name}));}async members(guild){const limit=1000;let doneLoading=false;let allMembers=[];let after=\"0\";while(!doneLoading){const newMembers=await this._fetchJson(\"/guilds/\".concat(guild,\"/members?after=\").concat(after,\"&limit=\").concat(limit));if(newMembers.length<limit){doneLoading=true;}else{after=newMembers[newMembers.length-1].user.id;}allMembers=[...allMembers,...newMembers];}return allMembers.map(x=>({user:{id:x.user.id,username:x.user.username,discriminator:x.user.discriminator,bot:x.user.bot||x.user.system||false},nick:x.nick||null,roles:x.roles}));}async messages(channel,after,limit){const messages=await this._fetchJson(\"/channels/\".concat(channel,\"/messages?after=\").concat(after,\"&limit=\").concat(limit));return messages.map(x=>({id:x.id,channelId:channel,authorId:x.author.id,timestampMs:Date.parse(x.timestamp),content:x.content,reactionEmoji:(x.reactions||[]).map(r=>r.emoji),nonUserAuthor:x.webhook_id!=null||false,mentions:(x.mentions||[]).map(user=>({userId:user.id,count:Array.from(x.content.matchAll(\"<@!?\".concat(user.id,\">\"))).length}))}));}async reactions(channel,message,emoji){let doneLoading=false;let allReactingUsers=[];let after=\"0\";const limit=100;const emojiRef=_models__WEBPACK_IMPORTED_MODULE_1__[\"emojiToRef\"](emoji);while(!doneLoading){const newReactingUsers=await this._fetchJson(\"/channels/\".concat(channel,\"/messages/\").concat(message,\"/reactions/\").concat(emojiRef,\"?after=\").concat(after,\"&limit=\").concat(limit));if(newReactingUsers.length<limit){doneLoading=true;}else{after=newReactingUsers[newReactingUsers.length-1].id;}allReactingUsers=[...allReactingUsers,...newReactingUsers];}return allReactingUsers.map(x=>({channelId:channel,messageId:message,emoji,authorId:x.id}));}}function failIfMissing(response){if(response.status===404){throw new Error(\"404 Not Found on: \".concat(response.url,\"; maybe bad serverUrl?\"));}if(response.status===403){throw new Error(\"403 Forbidden: bad API username or key?\\n\".concat(response.url));}if(response.status===410){throw new Error(\"410 Gone\");}}function failForNotOk(response){if(!response.ok){throw new Error(\"not OK status \".concat(response.status,\" on \").concat(response.url));}}\n\n//# sourceURL=webpack:///./src/plugins/discord/fetcher.js?");

/***/ }),

/***/ "./src/plugins/discord/mirror.js":
/*!***************************************!*\
  !*** ./src/plugins/discord/mirror.js ***!
  \***************************************/
/*! exports provided: Mirror */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mirror\", function() { return Mirror; });\n/* harmony import */ var _util_taskReporter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/taskReporter */ \"./src/util/taskReporter.js\");\n/* harmony import */ var _mirrorRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mirrorRepository */ \"./src/plugins/discord/mirrorRepository.js\");\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models */ \"./src/plugins/discord/models.js\");\n/* harmony import */ var _reactionWeights__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reactionWeights */ \"./src/plugins/discord/reactionWeights.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}// How many messages for each channel to reload.\nconst RELOAD_DEPTH=50;class Mirror{constructor(repo,api,config){_defineProperty(this,\"_repo\",void 0);_defineProperty(this,\"_api\",void 0);_defineProperty(this,\"config\",void 0);this._repo=repo;this._api=api;this.config=config;}async update(reporter){const guild=await this.validateGuildId();reporter.start(\"discord/\".concat(guild.name));await this.addMembers();const channels=await this.addTextChannels();for(const channel of channels){reporter.start(\"discord/\".concat(guild.name,\"/#\").concat(channel.name));try{await this.addMessages(channel.id,channel.parentId);}catch(e){var _e$message;const warn=e!==null&&e!==void 0&&(_e$message=e.message)!==null&&_e$message!==void 0&&_e$message.includes(\"403\")?\"Skipping private channel.\":e;console.warn(warn);}reporter.finish(\"discord/\".concat(guild.name,\"/#\").concat(channel.name));}reporter.finish(\"discord/\".concat(guild.name));}async validateGuildId(){const guilds=await this._api.guilds();const guild=guilds.find(g=>g.id===this.config.guildId);if(!guild){throw new Error(\"Couldn't find guild with ID \".concat(this.config.guildId,\"\\nMaybe the bot has no access to it?\"));}// TODO: validate bot permissions\nreturn guild;}async addMembers(){const members=await this._api.members(this.config.guildId);for(const member of members){this._repo.addMember(member);}return this._repo.members();}async addTextChannels(){const channels=await this._api.channels(this.config.guildId);for(const channel of channels){if(channel.type!==\"GUILD_TEXT\")continue;if(!Object(_reactionWeights__WEBPACK_IMPORTED_MODULE_3__[\"channelWeight\"])(this.config.weights.channelWeights,channel.id,channel.parentId))continue;if(!this.config.includeNsfwChannels&&channel.nsfw)continue;this._repo.addChannel(channel);}return this._repo.channels();}async addMessages(channel,category,messageLimit){const loadStart=this._repo.nthMessageFromTail(channel,RELOAD_DEPTH);// console.log(channel, (loadStart || {}).id);\nconst limit=messageLimit||100;let page=[];let after=loadStart?loadStart.id:\"0\";do{page=await this._api.messages(channel,after,limit);for(const message of page){after=after<message.id?message.id:after;this._repo.addMessage(message);for(const emoji of message.reactionEmoji){const reactions=await this._api.reactions(channel,message.id,emoji);for(const reaction of reactions){this._repo.addReaction(reaction);}}}}while(page.length>=limit);return this._repo.messages(channel);}}\n\n//# sourceURL=webpack:///./src/plugins/discord/mirror.js?");

/***/ }),

/***/ "./src/plugins/discord/mirrorRepository.js":
/*!*************************************************!*\
  !*** ./src/plugins/discord/mirrorRepository.js ***!
  \*************************************************/
/*! exports provided: SqliteMirrorRepository */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SqliteMirrorRepository\", function() { return SqliteMirrorRepository; });\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models */ \"./src/plugins/discord/models.js\");\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/dedent */ \"./src/util/dedent.js\");\nvar _templateObject,_templateObject2,_templateObject3,_templateObject4,_templateObject5,_templateObject6,_templateObject7,_templateObject8,_templateObject9,_templateObject10,_templateObject11,_templateObject12,_templateObject13,_templateObject14,_templateObject15,_templateObject16,_templateObject17,_templateObject18,_templateObject19,_templateObject20,_templateObject21,_templateObject22;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const VERSION=\"discord_mirror_v1\";class SqliteMirrorRepository{constructor(db,guild){_defineProperty(this,\"_db\",void 0);if(db==null)throw new Error(\"db: \"+String(db));this._db=db;this._transaction(()=>{this._initialize(guild);});}_transaction(queries){const db=this._db;if(db.inTransaction){throw new Error(\"already in transaction\");}try{db.prepare(\"BEGIN\").run();queries();if(db.inTransaction){db.prepare(\"COMMIT\").run();}}finally{if(db.inTransaction){db.prepare(\"ROLLBACK\").run();}}}_initialize(guild){const db=this._db;// We store the config in a singleton table `meta`, whose unique row\n// has primary key `0`. Only the first ever insert will succeed; we\n// are locked into the first config.\ndb.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"        CREATE TABLE IF NOT EXISTS meta (\\n            zero INTEGER PRIMARY KEY,\\n            config TEXT NOT NULL\\n        )\\n      \"],[\"\\\\\\n        CREATE TABLE IF NOT EXISTS meta (\\n            zero INTEGER PRIMARY KEY,\\n            config TEXT NOT NULL\\n        )\\n      \"])))).run();const config=json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()({version:VERSION,guild});const existingConfig=db.prepare(\"SELECT config FROM meta\").pluck().get();if(existingConfig===config){// Already set up; nothing to do.\nreturn;}else if(existingConfig!==undefined){throw new Error(\"Database already populated with incompatible server or version\");}db.prepare(\"INSERT INTO meta (zero, config) VALUES (0, ?)\").run(config);const tables=[Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"        CREATE TABLE channels (\\n            id TEXT PRIMARY KEY,\\n            type TEXT NOT NULL,\\n            name TEXT NOT NULL,\\n            parent_id TEXT\\n        )\\n      \"],[\"\\\\\\n        CREATE TABLE channels (\\n            id TEXT PRIMARY KEY,\\n            type TEXT NOT NULL,\\n            name TEXT NOT NULL,\\n            parent_id TEXT\\n        )\\n      \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject3||(_templateObject3=_taggedTemplateLiteral([\"        CREATE TABLE members (\\n            user_id TEXT PRIMARY KEY,\\n            username TEXT NOT NULL,\\n            discriminator TEXT NOT NULL,\\n            bot INTEGER NOT NULL,\\n            nick TEXT\\n        )\\n      \"],[\"\\\\\\n        CREATE TABLE members (\\n            user_id TEXT PRIMARY KEY,\\n            username TEXT NOT NULL,\\n            discriminator TEXT NOT NULL,\\n            bot INTEGER NOT NULL,\\n            nick TEXT\\n        )\\n      \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject4||(_templateObject4=_taggedTemplateLiteral([\"        CREATE TABLE member_roles (\\n            user_id TEXT,\\n            role TEXT NOT NULL,\\n            CONSTRAINT user_role PRIMARY KEY (user_id, role)\\n        )\\n      \"],[\"\\\\\\n        CREATE TABLE member_roles (\\n            user_id TEXT,\\n            role TEXT NOT NULL,\\n            CONSTRAINT user_role PRIMARY KEY (user_id, role)\\n        )\\n      \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject5||(_templateObject5=_taggedTemplateLiteral([\"        CREATE TABLE messages (\\n            id TEXT PRIMARY KEY,\\n            channel_id TEXT NOT NULL,\\n            author_id TEXT NOT NULL,\\n            non_user_author INTEGER NOT NULL,\\n            timestamp_ms INTEGER NOT NULL,\\n            content TEXT NOT NULL\\n        )\\n      \"],[\"\\\\\\n        CREATE TABLE messages (\\n            id TEXT PRIMARY KEY,\\n            channel_id TEXT NOT NULL,\\n            author_id TEXT NOT NULL,\\n            non_user_author INTEGER NOT NULL,\\n            timestamp_ms INTEGER NOT NULL,\\n            content TEXT NOT NULL\\n        )\\n      \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject6||(_templateObject6=_taggedTemplateLiteral([\"        CREATE TABLE message_reactions (\\n            channel_id TEXT NOT NULL,\\n            message_id TEXT NOT NULL,\\n            author_id TEXT NOT NULL,\\n            emoji TEXT NOT NULL,\\n            CONSTRAINT value_object PRIMARY KEY (channel_id, message_id, author_id, emoji)\\n        )\\n      \"],[\"\\\\\\n        CREATE TABLE message_reactions (\\n            channel_id TEXT NOT NULL,\\n            message_id TEXT NOT NULL,\\n            author_id TEXT NOT NULL,\\n            emoji TEXT NOT NULL,\\n            CONSTRAINT value_object PRIMARY KEY (channel_id, message_id, author_id, emoji)\\n        )\\n      \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject7||(_templateObject7=_taggedTemplateLiteral([\"        CREATE TABLE message_mentions (\\n            channel_id TEXT NOT NULL,\\n            message_id TEXT NOT NULL,\\n            user_id TEXT NOT NULL,\\n            count INTEGER NOT NULL,\\n            CONSTRAINT value_object PRIMARY KEY (channel_id, message_id, user_id)\\n        )\\n      \"],[\"\\\\\\n        CREATE TABLE message_mentions (\\n            channel_id TEXT NOT NULL,\\n            message_id TEXT NOT NULL,\\n            user_id TEXT NOT NULL,\\n            count INTEGER NOT NULL,\\n            CONSTRAINT value_object PRIMARY KEY (channel_id, message_id, user_id)\\n        )\\n      \"])))];for(const sql of tables){db.prepare(sql).run();}}members(){return this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject8||(_templateObject8=_taggedTemplateLiteral([\"        SELECT\\n          user_id,\\n          username,\\n          discriminator,\\n          bot,\\n          nick\\n        FROM members\"],[\"\\\\\\n        SELECT\\n          user_id,\\n          username,\\n          discriminator,\\n          bot,\\n          nick\\n        FROM members\"])))).all().map(x=>({user:{id:x.user_id,username:x.username,discriminator:x.discriminator,bot:x.bot===1},nick:x.nick,roles:this.memberRoles(x.user_id)}));}memberRoles(user){return this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject9||(_templateObject9=_taggedTemplateLiteral([\"        SELECT\\n          user_id,\\n          role\\n        FROM member_roles\\n        WHERE user_id = :user_id\"],[\"\\\\\\n        SELECT\\n          user_id,\\n          role\\n        FROM member_roles\\n        WHERE user_id = :user_id\"])))).all({user_id:user}).map(x=>x.role);}channels(){return this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject10||(_templateObject10=_taggedTemplateLiteral([\"        SELECT\\n          id,\\n          type,\\n          name,\\n          parent_id\\n        FROM channels\"],[\"\\\\\\n        SELECT\\n          id,\\n          type,\\n          name,\\n          parent_id\\n        FROM channels\"])))).all().map(res=>({id:res.id,type:res.type,name:res.name,parentId:res.parent_id}));}messages(channel){return this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject11||(_templateObject11=_taggedTemplateLiteral([\"        SELECT\\n          id,\\n          channel_id,\\n          author_id,\\n          non_user_author,\\n          timestamp_ms,\\n          content\\n        FROM messages\\n        WHERE channel_id = :channel_id\"],[\"\\\\\\n        SELECT\\n          id,\\n          channel_id,\\n          author_id,\\n          non_user_author,\\n          timestamp_ms,\\n          content\\n        FROM messages\\n        WHERE channel_id = :channel_id\"])))).all({channel_id:channel}).map(m=>({id:m.id,channelId:m.channel_id,authorId:m.author_id,nonUserAuthor:m.non_user_author===1,timestampMs:m.timestamp_ms,content:m.content,reactionEmoji:this.reactionEmoji(m.channel_id,m.id),mentions:this.mentions(m.channel_id,m.id)}));}nthMessageFromTail(channel,n){const count=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject12||(_templateObject12=_taggedTemplateLiteral([\"        SELECT count(*) as count\\n        FROM messages\\n        WHERE channel_id = :channel_id\"],[\"\\\\\\n        SELECT count(*) as count\\n        FROM messages\\n        WHERE channel_id = :channel_id\"])))).get({channel_id:channel}).count;if(count<n)return null;const offset=count-n;const m=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject13||(_templateObject13=_taggedTemplateLiteral([\"        SELECT\\n          id,\\n          channel_id,\\n          author_id,\\n          non_user_author,\\n          timestamp_ms,\\n          content\\n        FROM messages\\n        WHERE channel_id = :channel_id\\n        ORDER BY timestamp_ms\\n        LIMIT 1\\n        OFFSET :offset\\n        \"],[\"\\\\\\n        SELECT\\n          id,\\n          channel_id,\\n          author_id,\\n          non_user_author,\\n          timestamp_ms,\\n          content\\n        FROM messages\\n        WHERE channel_id = :channel_id\\n        ORDER BY timestamp_ms\\n        LIMIT 1\\n        OFFSET :offset\\n        \"])))).get({channel_id:channel,offset});return{id:m.id,channelId:m.channel_id,authorId:m.author_id,nonUserAuthor:m.non_user_author===1,timestampMs:m.timestamp_ms,content:m.content,reactionEmoji:this.reactionEmoji(m.channel_id,m.id),mentions:this.mentions(m.channel_id,m.id)};}mentions(channel,message){return this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject14||(_templateObject14=_taggedTemplateLiteral([\"        SELECT user_id, count\\n        FROM message_mentions\\n        WHERE channel_id = :channel_id\\n          AND message_id = :message_id\"],[\"\\\\\\n        SELECT user_id, count\\n        FROM message_mentions\\n        WHERE channel_id = :channel_id\\n          AND message_id = :message_id\"])))).all({channel_id:channel,message_id:message}).map(res=>({userId:res.user_id,count:res.count}));}reactionEmoji(channel,message){return this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject15||(_templateObject15=_taggedTemplateLiteral([\"        SELECT DISTINCT\\n          emoji\\n        FROM message_reactions\\n        WHERE channel_id = :channel_id\\n          AND message_id = :message_id\"],[\"\\\\\\n        SELECT DISTINCT\\n          emoji\\n        FROM message_reactions\\n        WHERE channel_id = :channel_id\\n          AND message_id = :message_id\"])))).all({channel_id:channel,message_id:message}).map(e=>_models__WEBPACK_IMPORTED_MODULE_1__[\"refToEmoji\"](e.emoji));}reactions(channel,message){return this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject16||(_templateObject16=_taggedTemplateLiteral([\"        SELECT\\n          channel_id,\\n          message_id,\\n          author_id,\\n          emoji\\n        FROM message_reactions\\n        WHERE channel_id = :channel_id\\n          AND message_id = :message_id\"],[\"\\\\\\n        SELECT\\n          channel_id,\\n          message_id,\\n          author_id,\\n          emoji\\n        FROM message_reactions\\n        WHERE channel_id = :channel_id\\n          AND message_id = :message_id\"])))).all({channel_id:channel,message_id:message}).map(r=>({channelId:r.channel_id,messageId:r.message_id,authorId:r.author_id,emoji:_models__WEBPACK_IMPORTED_MODULE_1__[\"refToEmoji\"](r.emoji)}));}addChannel(channel){this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject17||(_templateObject17=_taggedTemplateLiteral([\"          INSERT OR IGNORE INTO channels (\\n              id,\\n              type,\\n              name,\\n              parent_id\\n          ) VALUES (\\n              :id,\\n              :type,\\n              :name,\\n              :parent_id\\n          )\\n        \"],[\"\\\\\\n          INSERT OR IGNORE INTO channels (\\n              id,\\n              type,\\n              name,\\n              parent_id\\n          ) VALUES (\\n              :id,\\n              :type,\\n              :name,\\n              :parent_id\\n          )\\n        \"])))).run({id:channel.id,type:channel.type,name:channel.name,parent_id:channel.parentId||null});}addMessage(message){this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject18||(_templateObject18=_taggedTemplateLiteral([\"          INSERT OR IGNORE INTO messages (\\n              id,\\n              channel_id,\\n              author_id,\\n              non_user_author,\\n              timestamp_ms,\\n              content\\n          ) VALUES (\\n              :id,\\n              :channel_id,\\n              :author_id,\\n              :non_user_author,\\n              :timestamp_ms,\\n              :content\\n          )\\n        \"],[\"\\\\\\n          INSERT OR IGNORE INTO messages (\\n              id,\\n              channel_id,\\n              author_id,\\n              non_user_author,\\n              timestamp_ms,\\n              content\\n          ) VALUES (\\n              :id,\\n              :channel_id,\\n              :author_id,\\n              :non_user_author,\\n              :timestamp_ms,\\n              :content\\n          )\\n        \"])))).run({id:message.id,channel_id:message.channelId,author_id:message.authorId,non_user_author:Number(message.nonUserAuthor),timestamp_ms:message.timestampMs,content:message.content});for(const mention of message.mentions){this.addMention(message,mention);}}addReaction(reaction){this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject19||(_templateObject19=_taggedTemplateLiteral([\"          INSERT OR IGNORE INTO message_reactions (\\n              channel_id,\\n              message_id,\\n              author_id,\\n              emoji\\n          ) VALUES (\\n              :channel_id,\\n              :message_id,\\n              :author_id,\\n              :emoji\\n          )\\n        \"],[\"\\\\\\n          INSERT OR IGNORE INTO message_reactions (\\n              channel_id,\\n              message_id,\\n              author_id,\\n              emoji\\n          ) VALUES (\\n              :channel_id,\\n              :message_id,\\n              :author_id,\\n              :emoji\\n          )\\n        \"])))).run({channel_id:reaction.channelId,message_id:reaction.messageId,author_id:reaction.authorId,emoji:_models__WEBPACK_IMPORTED_MODULE_1__[\"emojiToRef\"](reaction.emoji)});}addMention(message,mention){this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject20||(_templateObject20=_taggedTemplateLiteral([\"          INSERT OR IGNORE INTO message_mentions (\\n              channel_id,\\n              message_id,\\n              user_id,\\n              count\\n          ) VALUES (\\n              :channel_id,\\n              :message_id,\\n              :user_id,\\n              :count\\n          )\\n        \"],[\"\\\\\\n          INSERT OR IGNORE INTO message_mentions (\\n              channel_id,\\n              message_id,\\n              user_id,\\n              count\\n          ) VALUES (\\n              :channel_id,\\n              :message_id,\\n              :user_id,\\n              :count\\n          )\\n        \"])))).run({channel_id:message.channelId,message_id:message.id,user_id:mention.userId,count:mention.count});}addMember(member){this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject21||(_templateObject21=_taggedTemplateLiteral([\"          INSERT OR IGNORE INTO members (\\n              user_id,\\n              username,\\n              discriminator,\\n              bot,\\n              nick\\n          ) VALUES (\\n              :user_id,\\n              :username,\\n              :discriminator,\\n              :bot,\\n              :nick\\n          )\\n        \"],[\"\\\\\\n          INSERT OR IGNORE INTO members (\\n              user_id,\\n              username,\\n              discriminator,\\n              bot,\\n              nick\\n          ) VALUES (\\n              :user_id,\\n              :username,\\n              :discriminator,\\n              :bot,\\n              :nick\\n          )\\n        \"])))).run({user_id:member.user.id,username:member.user.username,discriminator:member.user.discriminator,bot:Number(member.user.bot),nick:member.nick||null});for(const role of member.roles){this.addMemberRole(member.user.id,role);}}addMemberRole(user,role){this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_templateObject22||(_templateObject22=_taggedTemplateLiteral([\"          INSERT OR IGNORE INTO member_roles (\\n              user_id,\\n              role\\n          ) VALUES (\\n              :user_id,\\n              :role\\n          )\\n        \"],[\"\\\\\\n          INSERT OR IGNORE INTO member_roles (\\n              user_id,\\n              role\\n          ) VALUES (\\n              :user_id,\\n              :role\\n          )\\n        \"])))).run({user_id:user,role});}}\n\n//# sourceURL=webpack:///./src/plugins/discord/mirrorRepository.js?");

/***/ }),

/***/ "./src/plugins/discord/models.js":
/*!***************************************!*\
  !*** ./src/plugins/discord/models.js ***!
  \***************************************/
/*! exports provided: ZeroSnowflake, channelTypeFromId, emojiToRef, refToEmoji */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroSnowflake\", function() { return ZeroSnowflake; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"channelTypeFromId\", function() { return channelTypeFromId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"emojiToRef\", function() { return emojiToRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"refToEmoji\", function() { return refToEmoji; });\n// https://discordapp.com/developers/docs/reference#snowflakes\nconst ZeroSnowflake=\"0\";function channelTypeFromId(id){switch(id){case 0:return\"GUILD_TEXT\";case 1:return\"DM\";case 2:return\"GUILD_VOICE\";case 3:return\"GROUP_DM\";case 4:return\"GUILD_CATEGORY\";case 5:return\"GUILD_NEWS\";case 6:return\"GUILD_STORE\";default:{return\"UNKNOWN\";}}}function emojiToRef(_ref){let{id,name}=_ref;// Built-in emoji, unicode names.\nif(!id)return name;// Custom emoji.\nreturn\"\".concat(name,\":\").concat(id);}function refToEmoji(ref){const[name,id]=ref.split(\":\");if(!id)return{id:null,name};return{id,name};}\n\n//# sourceURL=webpack:///./src/plugins/discord/models.js?");

/***/ }),

/***/ "./src/plugins/discord/plugin.js":
/*!***************************************!*\
  !*** ./src/plugins/discord/plugin.js ***!
  \***************************************/
/*! exports provided: DiscordPlugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiscordPlugin\", function() { return DiscordPlugin; });\n/* harmony import */ var better_sqlite3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! better-sqlite3 */ \"better-sqlite3\");\n/* harmony import */ var better_sqlite3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(better_sqlite3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./src/plugins/discord/config.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/discord/declaration.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _fetcher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fetcher */ \"./src/plugins/discord/fetcher.js\");\n/* harmony import */ var _mirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mirror */ \"./src/plugins/discord/mirror.js\");\n/* harmony import */ var _core_weightedGraph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/weightedGraph */ \"./src/core/weightedGraph.js\");\n/* harmony import */ var _core_weights__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/weights */ \"./src/core/weights.js\");\n/* harmony import */ var _analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../analysis/pluginDeclaration */ \"./src/analysis/pluginDeclaration.js\");\n/* harmony import */ var _createGraph__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createGraph */ \"./src/plugins/discord/createGraph.js\");\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./models */ \"./src/plugins/discord/models.js\");\n/* harmony import */ var _mirrorRepository__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./mirrorRepository */ \"./src/plugins/discord/mirrorRepository.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/storage/disk */ \"./src/core/storage/disk.js\");\n/* harmony import */ var _createIdentities__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./createIdentities */ \"./src/plugins/discord/createIdentities.js\");\nasync function loadConfig(dirContext){const dirname=dirContext.configDirectory();const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_13__[\"DiskStorage\"](dirname);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_12__[\"loadJson\"])(storage,\"config.json\",_config__WEBPACK_IMPORTED_MODULE_1__[\"parser\"]);}const TOKEN_ENV_VAR_NAME=\"SOURCECRED_DISCORD_TOKEN\";function getTokenFromEnv(){const rawToken=process.env[TOKEN_ENV_VAR_NAME];if(rawToken==null){throw new Error(\"No Discord token provided: set \".concat(TOKEN_ENV_VAR_NAME));}return rawToken;}class DiscordPlugin{async declaration(){return _declaration__WEBPACK_IMPORTED_MODULE_2__[\"declaration\"];}async load(ctx,reporter){const configs=await loadConfig(ctx);const token=getTokenFromEnv();const fetcher=new _fetcher__WEBPACK_IMPORTED_MODULE_4__[\"Fetcher\"]({token});for(const config of configs){const repo=await repository(ctx,config.guildId);const mirror=new _mirror__WEBPACK_IMPORTED_MODULE_5__[\"Mirror\"](repo,fetcher,config);await mirror.update(reporter);}}async graph(ctx,rd){const _=rd;// TODO(#1808): not yet used\nconst configs=await loadConfig(ctx);const weightedGraph=Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_6__[\"merge\"])(await Promise.all(configs.map(async config=>{const repo=await repository(ctx,config.guildId);return Object(_createGraph__WEBPACK_IMPORTED_MODULE_9__[\"createGraph\"])(config,repo);})));const declarationWeights=Object(_analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_8__[\"weightsForDeclaration\"])(_declaration__WEBPACK_IMPORTED_MODULE_2__[\"declaration\"]);// Add in the type-level weights from the plugin spec\nconst combinedWeights=Object(_core_weights__WEBPACK_IMPORTED_MODULE_7__[\"merge\"])([weightedGraph.weights,declarationWeights]);return{graph:weightedGraph.graph,weights:combinedWeights};}async referenceDetector(_unused_ctx){// TODO: Implement Discord reference detection\n// (low priority bc ppl rarely hardlink to Discord messages)\nreturn{addressFromUrl:()=>undefined};}async identities(ctx){const configs=await loadConfig(ctx);return(await Promise.all(configs.map(async _ref=>{let{guildId}=_ref;const repo=await repository(ctx,guildId);return Object(_createIdentities__WEBPACK_IMPORTED_MODULE_14__[\"createIdentities\"])(repo);}))).flat(1);}}async function repository(ctx,guild){const path=Object(path__WEBPACK_IMPORTED_MODULE_3__[\"join\"])(ctx.cacheDirectory(),\"discordMirror-\".concat(guild,\".db\"));const db=await new better_sqlite3__WEBPACK_IMPORTED_MODULE_0___default.a(path);return new _mirrorRepository__WEBPACK_IMPORTED_MODULE_11__[\"SqliteMirrorRepository\"](db,guild);}\n\n//# sourceURL=webpack:///./src/plugins/discord/plugin.js?");

/***/ }),

/***/ "./src/plugins/discord/reactionWeights.js":
/*!************************************************!*\
  !*** ./src/plugins/discord/reactionWeights.js ***!
  \************************************************/
/*! exports provided: reactionWeight, _roleWeight, channelWeight, _emojiWeight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reactionWeight\", function() { return reactionWeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_roleWeight\", function() { return _roleWeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"channelWeight\", function() { return channelWeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_emojiWeight\", function() { return _emojiWeight; });\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models */ \"./src/plugins/discord/models.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\nfunction reactionWeight(options){const{weights,message,reaction,reactingMember,propsChannels,reactions,channelParentId}=options;if(message.authorId===reaction.authorId&&!propsChannels.has(message.channelId)){// Self-reactions do not mint Cred\n// on channels that are not props channels\nreturn 0;}const roleMultipliedReactingMembers=weights.emojiWeights.applyAveraging?Array.from(new Set(reactions.filter(_ref=>{let{reaction}=_ref;return reaction.authorId!==message.authorId;}).map(_ref2=>{let{reactingMember}=_ref2;return reactingMember;}))).reduce((total,member)=>total+_roleWeight(weights.roleWeights,member),0)+(weights.emojiWeights.confidenceDampener||0):null;const averagingMultiplier=roleMultipliedReactingMembers?1/roleMultipliedReactingMembers:1;return _roleWeight(weights.roleWeights,reactingMember)*channelWeight(weights.channelWeights,reaction.channelId,channelParentId)*_emojiWeight(weights.emojiWeights,reaction)*averagingMultiplier;}function _roleWeight(config,member){const{defaultWeight,weights}=config;let weight=defaultWeight;for(const role of member.roles){const matchingWeight=weights[role];if(matchingWeight!=null&&matchingWeight>weight){weight=matchingWeight;}}return weight;}function channelWeight(config,channelId,channelParentId){const{defaultWeight,weights}=config;return Object(_util_null__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"])(channelParentId?Object(_util_null__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"])(weights[channelId],weights[channelParentId]):weights[channelId],defaultWeight);}function _emojiWeight(config,reaction){const{defaultWeight,weights}=config;return Object(_util_null__WEBPACK_IMPORTED_MODULE_1__[\"orElse\"])(weights[_models__WEBPACK_IMPORTED_MODULE_0__[\"emojiToRef\"](reaction.emoji)],defaultWeight);}\n\n//# sourceURL=webpack:///./src/plugins/discord/reactionWeights.js?");

/***/ }),

/***/ "./src/plugins/discord/update.js":
/*!***************************************!*\
  !*** ./src/plugins/discord/update.js ***!
  \***************************************/
/*! exports provided: v0_9_0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v0_9_0\", function() { return v0_9_0; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/storage/disk */ \"./src/core/storage/disk.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/storage/textEncoding */ \"./src/core/storage/textEncoding.js\");\nconst v0_8_7_parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({guildId:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],reactionWeights:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"dict\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"])},{roleWeightConfig:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({defaultWeight:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],weights:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"dict\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"])}),channelWeightConfig:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({defaultWeight:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],weights:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"dict\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"])}),propsChannels:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"]),includeNsfwChannels:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"boolean\"],defaultReactionWeight:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],applyAveragingToReactions:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"boolean\"]});const v0_9_0=async()=>{const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_2__[\"DiskStorage\"](process.cwd());const discordConfigPath=Object(path__WEBPACK_IMPORTED_MODULE_4__[\"join\"])(\"config\",\"plugins\",\"sourcecred\",\"discord\",\"config.json\");const oldConfig=await Object(_util_storage__WEBPACK_IMPORTED_MODULE_3__[\"loadJsonWithDefault\"])(storage,discordConfigPath,v0_8_7_parser,()=>\"\");if(oldConfig!==\"\"){const newConfig=json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default()([{guildId:oldConfig.guildId,reactionWeightConfig:{weights:oldConfig.reactionWeights,applyAveraging:oldConfig.applyAveragingToReactions||false,defaultWeight:oldConfig.defaultReactionWeight||1},roleWeightConfig:oldConfig.roleWeightConfig||{defaultWeight:1,weights:{}},channelWeightConfig:oldConfig.channelWeightConfig||{defaultWeight:1,weights:{}},propsChannels:oldConfig.propsChannels||[],includeNsfwChannels:oldConfig.includeNsfwChannels||false}],{space:2});storage.set(discordConfigPath,Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_5__[\"encode\"])(newConfig));}};\n\n//# sourceURL=webpack:///./src/plugins/discord/update.js?");

/***/ }),

/***/ "./src/plugins/discourse/address.js":
/*!******************************************!*\
  !*** ./src/plugins/discourse/address.js ***!
  \******************************************/
/*! exports provided: topicAddress, postAddress, userAddress, likeAddress */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topicAddress\", function() { return topicAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postAddress\", function() { return postAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"userAddress\", function() { return userAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"likeAddress\", function() { return likeAddress; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/discourse/declaration.js\");\nfunction topicAddress(serverUrl,id){return _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"topicNodeType\"].prefix,serverUrl,String(id));}function postAddress(serverUrl,id){return _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"postNodeType\"].prefix,serverUrl,String(id));}function userAddress(serverUrl,username){return _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"userNodeType\"].prefix,serverUrl,username);}function likeAddress(serverUrl,like){return _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"likeNodeType\"].prefix,serverUrl,like.username,String(like.postId));}\n\n//# sourceURL=webpack:///./src/plugins/discourse/address.js?");

/***/ }),

/***/ "./src/plugins/discourse/config.js":
/*!*****************************************!*\
  !*** ./src/plugins/discourse/config.js ***!
  \*****************************************/
/*! exports provided: upgrade, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"upgrade\", function() { return upgrade; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _mirror__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mirror */ \"./src/plugins/discourse/mirror.js\");\n/* harmony import */ var _weights__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./weights */ \"./src/plugins/discourse/weights.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const serializedParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({serverUrl:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],serverUrl=>{const httpRE=new RegExp(/^https?:\\/\\//);if(!httpRE.test(serverUrl)){throw new Error(\"expected server url to start with 'https://' or 'http://'\");}return serverUrl;})},{mirrorOptions:_mirror__WEBPACK_IMPORTED_MODULE_1__[\"optionsShapeParser\"],weights:_weights__WEBPACK_IMPORTED_MODULE_2__[\"serializedWeightsConfigParser\"]});function upgrade(c){return _objectSpread(_objectSpread({},c),{},{weights:_weights__WEBPACK_IMPORTED_MODULE_2__[\"weightsConfigParser\"].parseOrThrow(c.weights||{})});}const parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](serializedParser,upgrade);\n\n//# sourceURL=webpack:///./src/plugins/discourse/config.js?");

/***/ }),

/***/ "./src/plugins/discourse/createGraph.js":
/*!**********************************************!*\
  !*** ./src/plugins/discourse/createGraph.js ***!
  \**********************************************/
/*! exports provided: DEFAULT_TRUST_LEVEL_TO_WEIGHT, _createGraphData, _graphFromData, createGraph, _createReferenceEdges */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_TRUST_LEVEL_TO_WEIGHT\", function() { return DEFAULT_TRUST_LEVEL_TO_WEIGHT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_createGraphData\", function() { return _createGraphData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_graphFromData\", function() { return _graphFromData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGraph\", function() { return createGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_createReferenceEdges\", function() { return _createReferenceEdges; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../analysis/pluginDeclaration */ \"./src/analysis/pluginDeclaration.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/discourse/declaration.js\");\n/* harmony import */ var _references__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./references */ \"./src/plugins/discourse/references.js\");\n/* harmony import */ var _nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nodesAndEdges */ \"./src/plugins/discourse/nodesAndEdges.js\");\n/* harmony import */ var _weights__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./weights */ \"./src/plugins/discourse/weights.js\");\n// TODO: Make this configurable.\n// For details on trust levels:\n// https://blog.discourse.org/2018/06/understanding-discourse-trust-levels/\nconst DEFAULT_TRUST_LEVEL_TO_WEIGHT=Object.freeze({\"0\":0,// Trust level 1 indicates little engagement (doesn't even require any posts)\n// so I gave them a very small weight.\n\"1\":0.1,// Trust level 2 in my mind indicates being a \"full member\" so it feels\n// like a good anchor for a standard weight of 1.\n\"2\":1,// Trust level 3 requires that you are highly active and have earned lots of\n// likes, so feels trusted enough for some bonus minting.\n\"3\":1.25,// Trust level 4 means you've been designated as high trust by the admins, so\n// we give a bigger bonus. Could make this even larger (2?)\n\"4\":1.5});function _createGraphData(config,repo){const{serverUrl}=config;const users=repo.users().map(u=>_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"userNode\"](serverUrl,u.username));const topicIdToCategory=new Map();const topicIdToTags=new Map();const topics=repo.topics().map(topic=>{const node=_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"topicNode\"](serverUrl,topic);topicIdToCategory.set(topic.id,topic.categoryId);topicIdToTags.set(topic.id,topic.tags);const hasAuthor=_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"authorsTopicEdge\"](serverUrl,topic);return{node,hasAuthor};});const findPostInTopic=repo.findPostInTopic.bind(repo);const postIdToDescription=new Map();const posts=repo.posts().map(post=>{const topic=repo.topicById(post.topicId);const topicTitle=topic!=null?topic.title:\"[unknown topic]\";const url=serverUrl+\"/t/\"+post.topicId+\"/\"+post.indexWithinTopic;const description=\"[#\".concat(post.indexWithinTopic,\" on \").concat(topicTitle,\"](\").concat(url,\")\");postIdToDescription.set(post.id,description);const node=_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"postNode\"](serverUrl,post,description);const hasAuthor=_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"authorsPostEdge\"](serverUrl,post);const references=_createReferenceEdges(serverUrl,post,findPostInTopic);let postReplies=null;let replyToPostIndex=post.replyToPostIndex;if(replyToPostIndex==null&&post.indexWithinTopic>1){// The replyToPostIndex gets set to null if it is actually a reply to\n// the topic's own post.\nreplyToPostIndex=1;}if(replyToPostIndex!=null){const parentId=repo.findPostInTopic(post.topicId,replyToPostIndex);if(parentId!=null){postReplies=_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"postRepliesEdge\"](serverUrl,post,parentId);}}const topicContains=_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"topicContainsPostEdge\"](serverUrl,post);return{node,hasAuthor,references,postReplies,topicContains};});const postIdToLikeWeight=new Map();const likes=repo.likes().map(like=>{const postDescription=postIdToDescription.get(like.postId)||\"[unknown post]\";const node=_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"likeNode\"](serverUrl,like,postDescription);const createsLike=_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"createsLikeEdge\"](serverUrl,like);const likes=_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"likesEdge\"](serverUrl,like);const user=repo.findUser(like.username);const post=repo.postById(like.postId);const topicId=post?post.topicId:null;let weight=0;if(topicId){const categoryId=topicIdToCategory.get(topicId);const tags=topicIdToTags.get(topicId);weight=Object(_weights__WEBPACK_IMPORTED_MODULE_5__[\"likeWeight\"])(config.weights,user,categoryId,tags);}else{weight=Object(_weights__WEBPACK_IMPORTED_MODULE_5__[\"likeWeight\"])(config.weights,user);}// Update how much total like weight this post has, so that we can\n// set up a hasLikedPost edge flowing cred from the topic\nconst existingWeight=postIdToLikeWeight.get(like.postId)||0;postIdToLikeWeight.set(like.postId,existingWeight+weight);return{node,createsLike,likes,weight};});const topicHasLikedPosts=[];for(const[postId,weight]of postIdToLikeWeight.entries()){if(weight===0){// This could happen if all of the likes were from untrusted users\ncontinue;}const post=repo.postById(postId);if(post==null){// The like didn't correspond to a valid post--maybe a cache/deletion\n// thing--let's ignore it.\ncontinue;}const edge=_nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"topicHasLikedPostEdge\"](serverUrl,post);topicHasLikedPosts.push({edge,weight});}return{users,topics,posts,likes,topicHasLikedPosts};}function _graphFromData(_ref){let{users,topics,posts,likes,topicHasLikedPosts}=_ref;const g=new _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"Graph\"]();const weights=Object(_analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_1__[\"weightsForDeclaration\"])(_declaration__WEBPACK_IMPORTED_MODULE_2__[\"declaration\"]);for(const user of users){g.addNode(user);}for(const topic of topics){g.addNode(topic.node);g.addEdge(topic.hasAuthor);}for(const post of posts){g.addNode(post.node);g.addEdge(post.topicContains);g.addEdge(post.hasAuthor);if(post.postReplies!=null){g.addEdge(post.postReplies);}for(const reference of post.references){g.addEdge(reference);}}for(const like of likes){g.addNode(like.node);g.addEdge(like.createsLike);g.addEdge(like.likes);weights.nodeWeights.set(like.node.address,like.weight);}for(const{edge,weight}of topicHasLikedPosts){g.addEdge(edge);weights.edgeWeights.set(edge.address,{forwards:weight,backwards:0});}return{graph:g,weights};}function createGraph(config,repo){const data=_createGraphData(config,repo);return _graphFromData(data);}function _createReferenceEdges(serverUrl,post,findPostInTopic,// This is available as a helper for testing, so we don't need to construct posts\n// with fake html containing links.\n_manualLinks){const links=_manualLinks?_manualLinks:Object(_references__WEBPACK_IMPORTED_MODULE_3__[\"parseLinks\"])(post.cooked,serverUrl);const references=Object(_references__WEBPACK_IMPORTED_MODULE_3__[\"linksToReferences\"])(links);const result=[];for(const reference of references){const edge=_referenceEdge(serverUrl,post,reference,findPostInTopic);if(edge!=null){result.push(edge);}}return result;}function _referenceEdge(serverUrl,post,reference,findPostInTopic){if(reference.serverUrl!=null&&reference.serverUrl.toLowerCase()!==serverUrl.toLowerCase()){// Don't attempt to make cross-instance links for now, since we only\n// load one Discourse forum in a given instance.\nreturn null;}switch(reference.type){case\"TOPIC\":{return _nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"referencesTopicEdge\"](serverUrl,post,reference);}case\"POST\":{const referredPostId=findPostInTopic(reference.topicId,reference.postIndex);if(referredPostId==null){// Maybe a bad link, or the post or topic was deleted.\nreturn null;}return _nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"referencesPostEdge\"](serverUrl,post,referredPostId);}case\"USER\":{return _nodesAndEdges__WEBPACK_IMPORTED_MODULE_4__[\"referencesUserEdge\"](serverUrl,post,reference);}default:{throw new Error(\"Unexpected reference type: \".concat(reference.type));}}}\n\n//# sourceURL=webpack:///./src/plugins/discourse/createGraph.js?");

/***/ }),

/***/ "./src/plugins/discourse/createIdentities.js":
/*!***************************************************!*\
  !*** ./src/plugins/discourse/createIdentities.js ***!
  \***************************************************/
/*! exports provided: _createIdentity, createIdentities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_createIdentity\", function() { return _createIdentity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createIdentities\", function() { return createIdentities; });\n/* harmony import */ var _core_identity_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/identity/name */ \"./src/core/identity/name.js\");\n/* harmony import */ var _address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./address */ \"./src/plugins/discourse/address.js\");\nfunction guessUserType(username){if(username===\"system\"||username===\"discobot\"){return\"BOT\";}return\"USER\";}function _createIdentity(serverUrl,user){const{username}=user;const url=\"\".concat(serverUrl,\"/u/\").concat(username,\"/\");const description=\"discourse/[@\".concat(username,\"](\").concat(url,\")\");const address=Object(_address__WEBPACK_IMPORTED_MODULE_1__[\"userAddress\"])(serverUrl,username);const alias={description,address};return{pluginName:Object(_core_identity_name__WEBPACK_IMPORTED_MODULE_0__[\"nameFromString\"])(\"discourse\"),name:Object(_core_identity_name__WEBPACK_IMPORTED_MODULE_0__[\"coerce\"])(username),type:guessUserType(username),alias};}function createIdentities(serverUrl,repo){return repo.users().map(u=>_createIdentity(serverUrl,u));}\n\n//# sourceURL=webpack:///./src/plugins/discourse/createIdentities.js?");

/***/ }),

/***/ "./src/plugins/discourse/declaration.js":
/*!**********************************************!*\
  !*** ./src/plugins/discourse/declaration.js ***!
  \**********************************************/
/*! exports provided: nodePrefix, edgePrefix, topicNodeType, postNodeType, userNodeType, likeNodeType, topicContainsPostEdgeType, topicHasLikedPostEdgeType, postRepliesEdgeType, authorsTopicEdgeType, authorsPostEdgeType, createsLikeEdgeType, likesEdgeType, referencesPostEdgeType, referencesTopicEdgeType, referencesUserEdgeType, declaration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodePrefix\", function() { return nodePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgePrefix\", function() { return edgePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topicNodeType\", function() { return topicNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postNodeType\", function() { return postNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"userNodeType\", function() { return userNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"likeNodeType\", function() { return likeNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topicContainsPostEdgeType\", function() { return topicContainsPostEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topicHasLikedPostEdgeType\", function() { return topicHasLikedPostEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postRepliesEdgeType\", function() { return postRepliesEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authorsTopicEdgeType\", function() { return authorsTopicEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authorsPostEdgeType\", function() { return authorsPostEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createsLikeEdgeType\", function() { return createsLikeEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"likesEdgeType\", function() { return likesEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referencesPostEdgeType\", function() { return referencesPostEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referencesTopicEdgeType\", function() { return referencesTopicEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referencesUserEdgeType\", function() { return referencesUserEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"declaration\", function() { return declaration; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\nconst nodePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts([\"sourcecred\",\"discourse\"]);const edgePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].fromParts([\"sourcecred\",\"discourse\"]);const topicNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Topic\",pluralName:\"Topics\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"topic\"),defaultWeight:0,description:\"A topic (or post-container) in a Discourse instance. Every topic has at least one post.\"});const postNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Post\",pluralName:\"Posts\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"post\"),defaultWeight:0,description:\"A post in some topic in a Discourse instance.\"});const userNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"User\",pluralName:\"Users\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"user\"),defaultWeight:0,description:\"A user account on a particular Discourse instance.\"});const likeNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Like\",pluralName:\"Likes\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"like\"),defaultWeight:4,description:\"A like by some user, directed at some post\"});const topicContainsPostEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"contains post\",backwardName:\"is contained by topic\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"topicContainsPost\"),defaultWeight:{forwards:1/8,backwards:1},description:\"Connects a topic to the posts that it contains.\"});const topicHasLikedPostEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"has post with likes\",backwardName:\"is liked post within topic\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"topicHasLikedPost\"),defaultWeight:{forwards:1,backwards:0},description:\"Connects a topic to posts with likes, with weight proportional to the number of likes\"});const postRepliesEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"post is reply to\",backwardName:\"post replied to by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"replyTo\"),defaultWeight:{forwards:1,backwards:0},description:\"Connects a post to the post that it is a reply to.\"});const authorsTopicEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"authors topic\",backwardName:\"topic is authored by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"authors\",\"topic\"),defaultWeight:{forwards:0,backwards:0},description:\"Connects an author to a topic they created.\"});const authorsPostEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"authors post\",backwardName:\"post is authored by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"authors\",\"post\"),defaultWeight:{forwards:1/4,backwards:1},description:\"Connects an author to a post they've created.\"});const createsLikeEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"creates like\",backwardName:\"like created by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"createsLike\"),defaultWeight:{forwards:1,backwards:0},description:\"Connects a Discourse user to a like that they created.\"});const likesEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"likes\",backwardName:\"is liked by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"likes\"),defaultWeight:{forwards:1,backwards:0},description:\"Connects a Discourse like to a post that was liked.\"});const referencesPostEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"references post\",backwardName:\"post is referenced by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"references\",\"post\"),defaultWeight:{forwards:1/2,backwards:0},description:\"Connects a Discourse post to another post it referenced.\"});const referencesTopicEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"references topic\",backwardName:\"topic is referenced by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"references\",\"topic\"),defaultWeight:{forwards:1/2,backwards:0},description:\"Connects a Discourse post to a topic it referenced.\"});const referencesUserEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"mentions\",backwardName:\"is mentioned by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"references\",\"user\"),defaultWeight:{forwards:1/2,backwards:0},description:\"Connects a Discourse post to a user it mentions\"});const declaration=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Discourse\",nodePrefix,edgePrefix,nodeTypes:[userNodeType,topicNodeType,postNodeType,likeNodeType],edgeTypes:[postRepliesEdgeType,authorsTopicEdgeType,authorsPostEdgeType,topicContainsPostEdgeType,topicHasLikedPostEdgeType,likesEdgeType,createsLikeEdgeType,referencesPostEdgeType,referencesTopicEdgeType,referencesUserEdgeType],userTypes:[userNodeType]});\n\n//# sourceURL=webpack:///./src/plugins/discourse/declaration.js?");

/***/ }),

/***/ "./src/plugins/discourse/fetch.js":
/*!****************************************!*\
  !*** ./src/plugins/discourse/fetch.js ***!
  \****************************************/
/*! exports provided: Fetcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fetcher\", function() { return Fetcher; });\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! isomorphic-fetch */ \"isomorphic-fetch\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var bottleneck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bottleneck */ \"bottleneck\");\n/* harmony import */ var bottleneck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bottleneck__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * Class for retrieving data from the Discourse API.\n *\n * The Discourse API implements the JSON endpoints for all functionality of the actual site.\n * As such, it tends to return a lot of information that we don't care about (in contrast\n * to a GraphQL API which would give us only what we ask for). As such, we implement a simple\n * interface over it, which both abstracts over calling the API, and does some post-processing\n * on the results to simplify it to data that is relevant for us.\n */const MAX_API_REQUESTS_PER_MINUTE=55;class Fetcher{// We limit the rate of API requests, as documented here:\n// https://meta.discourse.org/t/global-rate-limits-and-throttling-in-discourse/78612\n// Note this limit is for admin API keys. If we change to user user API keys\n// (would be convenient as the keys would be less sensitive), we will need to lower\n// this rate limit by a factor of 3\n// TODO: I've set the max requests per minute to 55 (below the stated limit\n// of 60) to be a bit conservative, and avoid getting limited by the server.\n// We could improve our throughput by increasing the requests per minute to the\n// stated limit, and incorporating retry logic to account for the occasional 529.\nconstructor(options,// fetchImplementation shouldn't be provided by clients, but is convenient for testing.\nfetchImplementation,// Used to avoid going over the Discourse API rate limit\nminTimeMs){_defineProperty(this,\"options\",void 0);_defineProperty(this,\"_fetchImplementation\",void 0);this.options=options;const minTime=_util_null__WEBPACK_IMPORTED_MODULE_2__[\"orElse\"](minTimeMs,1000*60/MAX_API_REQUESTS_PER_MINUTE);// n.b. the rate limiting isn't programmatically tested. However, it's easy\n// to tell when it's broken: try to load a nontrivial Discourse server, and see\n// if you get a 429 failure.\nconst limiter=new bottleneck__WEBPACK_IMPORTED_MODULE_1___default.a({minTime});const unlimitedFetch=_util_null__WEBPACK_IMPORTED_MODULE_2__[\"orElse\"](fetchImplementation,isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0___default.a);this._fetchImplementation=limiter.wrap(unlimitedFetch);}async _fetchWithRetryOn520(fullUrl,fetchOptions){// We've started sporadically seeing 520 errors when hitting Discourse API\n// endpoints. It's generally while fetching topics, but is always a\n// different topic, so I think it's a rare/ephemeral bug on the Discourse\n// side.\n// We can just retry a few times if we get a 520 and it's unlikely to fail\n// 3 times in a row.\n// See https://github.com/sourcecred/sourcecred/issues/2491\nlet tries=3;while(tries>0){tries--;const response=await this._fetchImplementation(fullUrl,fetchOptions);if(response.status!==520){return response;}}throw new Error(\"repeated 520 errors on \".concat(fullUrl));}_fetch(endpoint){const{serverUrl}=this.options;if(!endpoint.startsWith(\"/\")){throw new Error(\"invalid endpoint: \".concat(endpoint));}if(!serverUrl.startsWith(\"http\")||serverUrl.endsWith(\"/\")){throw new Error(\"invalid server url: \".concat(serverUrl));}const fetchOptions={method:\"GET\",headers:{Accept:\"application/json\"}};const fullUrl=\"\".concat(serverUrl).concat(endpoint);return this._fetchWithRetryOn520(fullUrl,fetchOptions);}async categoryDefinitionTopicIds(){const topicIdRE=new RegExp(\"/t/[\\\\w-]+/(\\\\d+)$\");const urls=[];const categoriesWithSubcategories=[];// Root categories\nconst response=await this._fetch(\"/categories.json?show_subcategory_list=true\");failIfMissing(response);failForNotOk(response);const{categories:rootCategories}=(await response.json()).category_list;for(const cat of rootCategories){if(cat.topic_url!=null){urls.push(cat.topic_url);}if(cat.subcategory_ids){categoriesWithSubcategories.push(cat.id);}}// Subcategories\nfor(const rootCatId of categoriesWithSubcategories){const subResponse=await this._fetch(\"/categories.json?show_subcategory_list=true&parent_category_id=\".concat(rootCatId));failIfMissing(subResponse);failForNotOk(subResponse);const{categories:subCategories}=(await subResponse.json()).category_list;for(const cat of subCategories){if(cat.topic_url!=null){urls.push(cat.topic_url);}}}const ids=urls.map(url=>{const match=topicIdRE.exec(url);if(match==null){throw new Error(\"Encountered topic URL we failed to parse it's TopicId from: \".concat(url));}return Number(match[1]);});return new Set(ids);}async topicWithPosts(id){const response=await this._fetch(\"/t/\".concat(id,\".json\"));const{status}=response;if(status===403||status===404||status===410){// The topic is hidden, deleted, or otherwise missing.\n// Example of a 404 topic: https://discourse.sourcecred.io/t/116\nreturn null;}failForNotOk(response);const json=await response.json();const{posts_count:postCount}=json;let posts=json.post_stream.posts.map(parsePost);// Tags might be `undefined` if tags were disabled on the server.\n// If so, set tags to an empty array.\nconst tags=json.tags||[];const topic={id:json.id,categoryId:json.category_id.toString(),title:json.title,tags,timestampMs:Date.parse(json.created_at),authorUsername:json.details.created_by.username};// This shouldn't could cause infinite loops when the API is weird.\n// As requesting pages beyond the last page will produce a 404.\n// Pagination here is 1-based, and we already had page 1.\nlet page=2;while(postCount>posts.length){const resNext=await this._fetch(\"/t/\".concat(id,\".json?page=\").concat(page));failForNotOk(resNext);const subPosts=(await resNext.json()).post_stream.posts.map(parsePost);posts=[...posts,...subPosts];page++;}return{topic,posts};}async getUserData(username){const response=await this._fetch(\"/users/\".concat(username,\".json\"));if(response.status===404){// The user probably no longer exists. This is expected, see #1440.\nreturn null;}failIfMissing(response);failForNotOk(response);const json=await response.json();return parseUser(json.user);}async likesByUser(targetUsername,offset){const response=await this._fetch(\"/user_actions.json?username=\".concat(targetUsername,\"&filter=1&offset=\").concat(offset));const{status}=response;if(status===404){// The user probably no longer exists. This is expected, see #1440.\nreturn null;}failIfMissing(response);failForNotOk(response);const json=await response.json();return json.user_actions.map(parseLike);}async topicsBumpedSince(sinceMs){const topics=[];let lastUnpinnedTimestamp=Infinity;let morePages=true;let page=0;// Keep going till we've found timestamps older than sinceMs.\nwhile(lastUnpinnedTimestamp>=sinceMs&&morePages){const response=await this._fetch(\"/latest.json?order=activity&ascending=false&page=\".concat(page));failIfMissing(response);failForNotOk(response);const{topic_list:topicList}=await response.json();// Having the same amount of results as expected by pagination, assume there's another page.\nmorePages=topicList.per_page===topicList.topics.length;for(const jsonTopic of topicList.topics){const topic=parseLatestTopic(jsonTopic);// Due to how pinning works, we may have some topics in here that weren't bumped past `sinceMs`.\n// Filter those out now.\nif(topic.bumpedMs>sinceMs){topics.push(topic);}// Make sure we ignore pinned topics for this value, as pinned topics move to the top,\n// and are unhelpful in knowing whether we should fetch another page.\nif(!jsonTopic.pinned){lastUnpinnedTimestamp=Math.min(lastUnpinnedTimestamp,topic.bumpedMs);}}page++;}return topics;}}function failIfMissing(response){if(response.status===404){throw new Error(\"404 Not Found on: \".concat(response.url,\"; maybe bad serverUrl?\"));}if(response.status===403){throw new Error(\"403 Forbidden: bad API username or key?\");}if(response.status===410){throw new Error(\"410 Gone\");}}function failForNotOk(response){if(!response.ok){throw new Error(\"not OK status \".concat(response.status,\" on \").concat(response.url));}}/**\n * Parses a \"latest\" topic.\n *\n * A \"latest\" topic, is a topic as returned by the /latest.json API call,\n * and has a distinct assumptions:\n * - bumped_at is always present.\n *\n * usernamesById map used to resolve these IDs to usernames.\n */function parseLatestTopic(json){if(json.bumped_at==null){throw new Error(\"Unexpected missing bumped_at field for /latest.json request for topic ID \".concat(json.id,\".\"));}return{id:json.id,categoryId:json.category_id.toString(),tags:json.tags,title:json.title,timestampMs:Date.parse(json.created_at),bumpedMs:Date.parse(json.bumped_at)};}function parsePost(json){return{id:json.id,timestampMs:Date.parse(json.created_at),indexWithinTopic:json.post_number,replyToPostIndex:json.reply_to_post_number,topicId:json.topic_id,trustLevel:json.trust_level,authorUsername:json.username,cooked:json.cooked};}function parseUser(json){return{username:json.username,trustLevel:json.trust_level};}function parseLike(json){return{username:json.target_username,postId:json.post_id,timestampMs:Date.parse(json.created_at)};}\n\n//# sourceURL=webpack:///./src/plugins/discourse/fetch.js?");

/***/ }),

/***/ "./src/plugins/discourse/mirror.js":
/*!*****************************************!*\
  !*** ./src/plugins/discourse/mirror.js ***!
  \*****************************************/
/*! exports provided: optionsParser, optionsShapeParser, Mirror */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"optionsParser\", function() { return optionsParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"optionsShapeParser\", function() { return optionsShapeParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mirror\", function() { return Mirror; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _mirrorRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mirrorRepository */ \"./src/plugins/discourse/mirrorRepository.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const optionsParserFields={recheckCategoryDefinitionsAfterMs:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"]};const optionsParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"](optionsParserFields);const optionsShapeParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"shape\"](optionsParserFields);const defaultOptions={recheckCategoryDefinitionsAfterMs:24*3600*1000// 24h\n};function sortTopicByBumpedMs(a,b){return a.bumpedMs-b.bumpedMs;}/**\n * Mirrors data from the Discourse API into a local sqlite db.\n *\n * This class allows us to persist a local copy of data from a Discourse\n * instance. We have it for reasons similar to why we have a GraphQL mirror for\n * GitHub; it allows us to avoid re-doing expensive IO every time we re-load\n * SourceCred. It also gives us robustness in the face of network failures (we\n * can keep however much we downloaded until the fault).\n *\n * As implemented, the Mirror will never update already-downloaded content,\n * meaning it will not catch edits or deletions. As such, it's advisable to\n * replace the cache periodically (perhaps once a week or month). We may\n * implement automatic cache invalidation in the future.\n *\n * Each Mirror instance is tied to a particular server. Trying to use a mirror\n * for multiple Discourse servers is not permitted; use separate Mirrors.\n */class Mirror{/**\n   * Construct a new Mirror instance.\n   *\n   * Takes a Database, which may be a pre-existing Mirror database. The\n   * provided DiscourseInterface will be used to retrieve new data from Discourse.\n   *\n   * A serverUrl is required so that we can ensure that this Mirror is only storing\n   * data from a particular Discourse server.\n   */constructor(repo,fetcher,serverUrl,options){_defineProperty(this,\"_options\",void 0);_defineProperty(this,\"_repo\",void 0);_defineProperty(this,\"_fetcher\",void 0);_defineProperty(this,\"_serverUrl\",void 0);this._repo=repo;this._fetcher=fetcher;this._serverUrl=serverUrl;this._options=_objectSpread(_objectSpread({},defaultOptions),options||{});}async update(reporter){reporter.start(\"discourse\");await this._updateTopicsV2(reporter);await this._updateLikes(reporter);reporter.finish(\"discourse\");}async _updateTopicsV2(reporter){reporter.start(\"discourse/topics\");const{topicBumpMs:lastLocalTopicBumpMs,definitionCheckMs:lastDefinitionCheckMs}=this._repo.syncHeads();const startTime=Date.now();const shouldCheckDefinitions=startTime-lastDefinitionCheckMs>=this._options.recheckCategoryDefinitionsAfterMs;const bumpedTopics=await this._fetcher.topicsBumpedSince(lastLocalTopicBumpMs);const topicBumpsById=new Map(bumpedTopics.map(t=>[t.id,t.bumpedMs]));// Make sure we have oldest first in our load queue.\nbumpedTopics.sort(sortTopicByBumpedMs);// Create a uniqueness filter.\nconst existingTopics=new Set();const once=tid=>{if(existingTopics.has(tid))return false;existingTopics.add(tid);return true;};// Add definition topics if the flag to do so is set.\nconst definitionTopicIds=shouldCheckDefinitions?await this._fetcher.categoryDefinitionTopicIds():[];// Note: order is important here.\n// Initial load should happen in order of bump date,\n// reloads at the end are ok to be in random order.\nconst topicLoadQueue=[...bumpedTopics.map(t=>t.id),...definitionTopicIds].filter(once);for(const topicId of topicLoadQueue){const topicWithPosts=await this._fetcher.topicWithPosts(topicId);if(topicWithPosts!=null){const{topic,posts}=topicWithPosts;// We find the bump by:\n// 1. What fetcher's topicsBumpedSince tells us.\n// 2. What the local DB contains (probably force updated a topic that wasn't bumped).\n// 3. Fall back on creation date (category definition topics don't normally have bump dates at all).\nconst bumpedMs=topicBumpsById.get(topicId)||this._repo.bumpedMsForTopic(topicId)||topic.timestampMs;if(bumpedMs==null){throw new Error(\"Missing bump date for topic ID: \".concat(topic.id));}const mergedTopic=_objectSpread(_objectSpread({},topic),{},{bumpedMs});this._repo.replaceTopicTransaction(mergedTopic,posts);}}if(shouldCheckDefinitions){// Note: use the start time as to avoid missing any changes\n// between when we queries upstream and when we completed all tasks.\nthis._repo.bumpDefinitionTopicCheck(startTime);}reporter.finish(\"discourse/topics\");}async _updateLikes(reporter){const addLike=like=>{try{const res=this._repo.addLike(like);return{doneWithUser:res.changes===0};}catch(e){console.warn(\"Warning: Encountered error '\".concat(e.message,\"' \")+\"on a like by \".concat(like.username,\" \")+\"on post id \".concat(like.postId,\".\"));return{doneWithUser:false};}};// I don't want to hard code the expected page size, in case it changes upstream.\n// However, it's helpful to have a good guess of what the page size is, because if we\n// get a result which is shorter than the page size, we know we've hit the end of the\n// user's history, so we don't need to query any more.\n// So, we guess that the largest page size we've seen thus far is likely the page size,\n// and if we see any shorter pages, we know we are done for that particular user.\n// If we are wrong about the page size, the worst case is that we do an unnecessary\n// query when we are actually already done with the user.\nlet possiblePageSize=0;// TODO(perf): In the best case (there are no new likes), this requires\n// doing one query for every user who ever commented in the instance. This\n// is a bit excessive. For each user, we could store when we last checked\n// their likes, and when they last posted. Then we could only scan users\n// who we either haven't scanned in the last week, or who have been active\n// since our last scan. This would likely improve the performance of this\n// section of the update significantly.\nreporter.start(\"discourse/likes\");for(const{username}of this._repo.users()){let offset=0;let upToDate=false;while(!upToDate){const likeActions=await this._fetcher.likesByUser(username,offset);if(likeActions==null){break;}possiblePageSize=Math.max(likeActions.length,possiblePageSize);for(const like of likeActions){if(addLike(like).doneWithUser){upToDate=true;break;}}if(likeActions.length===0||likeActions.length<possiblePageSize){upToDate=true;}offset+=likeActions.length;}}reporter.finish(\"discourse/likes\");}}\n\n//# sourceURL=webpack:///./src/plugins/discourse/mirror.js?");

/***/ }),

/***/ "./src/plugins/discourse/mirrorRepository.js":
/*!***************************************************!*\
  !*** ./src/plugins/discourse/mirrorRepository.js ***!
  \***************************************************/
/*! exports provided: SqliteMirrorRepository */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SqliteMirrorRepository\", function() { return SqliteMirrorRepository; });\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/map */ \"./src/util/map.js\");\nvar _templateObject,_templateObject2,_templateObject3,_templateObject4,_templateObject5,_templateObject6,_templateObject7,_templateObject8,_templateObject9,_templateObject10,_templateObject11,_templateObject12,_templateObject13,_templateObject14,_templateObject15,_templateObject16,_templateObject17,_templateObject18,_templateObject19,_templateObject20,_templateObject21,_templateObject22,_templateObject23,_templateObject24;function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}// The version should be bumped any time the database schema is changed,\n// so that the cache will be properly invalidated.\nconst VERSION=\"discourse_mirror_v6\";const DEFINITION_CHECK_KEY=\"definition_check\";/**\n * An interface for reading the local Discourse data.\n */function toAddResult(_ref){let{changes,lastInsertRowid}=_ref;return{changes,lastInsertRowid};}class SqliteMirrorRepository{constructor(db,serverUrl){_defineProperty(this,\"_db\",void 0);if(db==null)throw new Error(\"db: \"+String(db));this._db=db;this._transaction(()=>{this._initialize(serverUrl);});}_transaction(queries){const db=this._db;if(db.inTransaction){throw new Error(\"already in transaction\");}try{db.prepare(\"BEGIN\").run();queries();if(db.inTransaction){db.prepare(\"COMMIT\").run();}}finally{if(db.inTransaction){db.prepare(\"ROLLBACK\").run();}}}_initialize(serverUrl){const db=this._db;// We store the config in a singleton table `meta`, whose unique row\n// has primary key `0`. Only the first ever insert will succeed; we\n// are locked into the first config.\ndb.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"        CREATE TABLE IF NOT EXISTS meta (\\n            zero INTEGER PRIMARY KEY,\\n            config TEXT NOT NULL\\n        )\\n      \"],[\"\\\\\\n        CREATE TABLE IF NOT EXISTS meta (\\n            zero INTEGER PRIMARY KEY,\\n            config TEXT NOT NULL\\n        )\\n      \"])))).run();const config=json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()({version:VERSION,serverUrl:serverUrl});const existingConfig=db.prepare(\"SELECT config FROM meta\").pluck().get();if(existingConfig===config){// Already set up; nothing to do.\nreturn;}else if(existingConfig!==undefined){throw new Error(\"Database already populated with incompatible server or version\");}db.prepare(\"INSERT INTO meta (zero, config) VALUES (0, ?)\").run(config);const tables=[Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"        CREATE TABLE sync_heads (\\n          key TEXT PRIMARY KEY,\\n          timestamp_ms INTEGER NOT NULL\\n        )\"],[\"\\\\\\n        CREATE TABLE sync_heads (\\n          key TEXT PRIMARY KEY,\\n          timestamp_ms INTEGER NOT NULL\\n        )\"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject3||(_templateObject3=_taggedTemplateLiteral([\"        CREATE TABLE users (\\n          username TEXT PRIMARY KEY,\\n          trust_level INTEGER\\n        )\"],[\"\\\\\\n        CREATE TABLE users (\\n          username TEXT PRIMARY KEY,\\n          trust_level INTEGER\\n        )\"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject4||(_templateObject4=_taggedTemplateLiteral([\"        CREATE TABLE topics (\\n            id INTEGER PRIMARY KEY,\\n            category_id TEXT NOT NULL,\\n            title TEXT NOT NULL,\\n            timestamp_ms INTEGER NOT NULL,\\n            bumped_ms INTEGER NOT NULL,\\n            author_username TEXT NOT NULL,\\n            FOREIGN KEY(author_username) REFERENCES users(username)\\n        )\\n      \"],[\"\\\\\\n        CREATE TABLE topics (\\n            id INTEGER PRIMARY KEY,\\n            category_id TEXT NOT NULL,\\n            title TEXT NOT NULL,\\n            timestamp_ms INTEGER NOT NULL,\\n            bumped_ms INTEGER NOT NULL,\\n            author_username TEXT NOT NULL,\\n            FOREIGN KEY(author_username) REFERENCES users(username)\\n        )\\n      \"]))),// TODO: If this bloats, consider making a separate tags table, and\n// referencing topic_tags by integer id rather than full tag name.\nObject(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject5||(_templateObject5=_taggedTemplateLiteral([\"        CREATE TABLE topic_tags (\\n            topic_id INTEGER NOT NULL,\\n            tag_name TEXT NOT NULL,\\n            PRIMARY KEY(topic_id, tag_name),\\n            FOREIGN KEY(topic_id) REFERENCES topics(id)\\n      )\\n      \"],[\"\\\\\\n        CREATE TABLE topic_tags (\\n            topic_id INTEGER NOT NULL,\\n            tag_name TEXT NOT NULL,\\n            PRIMARY KEY(topic_id, tag_name),\\n            FOREIGN KEY(topic_id) REFERENCES topics(id)\\n      )\\n      \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject6||(_templateObject6=_taggedTemplateLiteral([\"        CREATE TABLE posts (\\n            id INTEGER PRIMARY KEY,\\n            timestamp_ms INTEGER NOT NULL,\\n            author_username TEXT NOT NULL,\\n            topic_id INTEGER NOT NULL,\\n            trust_level INTEGER NOT NULL,\\n            index_within_topic INTEGER NOT NULL,\\n            reply_to_post_index INTEGER,\\n            cooked TEXT NOT NULL,\\n            FOREIGN KEY(topic_id) REFERENCES topics(id),\\n            FOREIGN KEY(author_username) REFERENCES users(username)\\n        )\\n      \"],[\"\\\\\\n        CREATE TABLE posts (\\n            id INTEGER PRIMARY KEY,\\n            timestamp_ms INTEGER NOT NULL,\\n            author_username TEXT NOT NULL,\\n            topic_id INTEGER NOT NULL,\\n            trust_level INTEGER NOT NULL,\\n            index_within_topic INTEGER NOT NULL,\\n            reply_to_post_index INTEGER,\\n            cooked TEXT NOT NULL,\\n            FOREIGN KEY(topic_id) REFERENCES topics(id),\\n            FOREIGN KEY(author_username) REFERENCES users(username)\\n        )\\n      \"]))),Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject7||(_templateObject7=_taggedTemplateLiteral([\"        CREATE TABLE likes (\\n          username TEXT NOT NULL,\\n          post_id INTEGER NOT NULL,\\n          timestamp_ms INTEGER NOT NULL,\\n          CONSTRAINT username_post PRIMARY KEY (username, post_id),\\n          FOREIGN KEY(post_id) REFERENCES posts(id),\\n          FOREIGN KEY(username) REFERENCES users(username)\\n        )\"],[\"\\\\\\n        CREATE TABLE likes (\\n          username TEXT NOT NULL,\\n          post_id INTEGER NOT NULL,\\n          timestamp_ms INTEGER NOT NULL,\\n          CONSTRAINT username_post PRIMARY KEY (username, post_id),\\n          FOREIGN KEY(post_id) REFERENCES posts(id),\\n          FOREIGN KEY(username) REFERENCES users(username)\\n        )\"])))];for(const sql of tables){db.prepare(sql).run();}}syncHeads(){const res=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject8||(_templateObject8=_taggedTemplateLiteral([\"          SELECT\\n              (SELECT IFNULL(MAX(bumped_ms), 0) FROM topics) AS max_topic_bump,\\n              (SELECT timestamp_ms FROM sync_heads WHERE key = :DEFINITION_CHECK_KEY) AS definition_check\\n          \"],[\"\\\\\\n          SELECT\\n              (SELECT IFNULL(MAX(bumped_ms), 0) FROM topics) AS max_topic_bump,\\n              (SELECT timestamp_ms FROM sync_heads WHERE key = :DEFINITION_CHECK_KEY) AS definition_check\\n          \"])))).get({DEFINITION_CHECK_KEY});return{definitionCheckMs:res.definition_check||0,topicBumpMs:res.max_topic_bump};}topics(){return this._db.transaction(()=>{const topics=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject9||(_templateObject9=_taggedTemplateLiteral([\"            SELECT\\n              id,\\n              category_id,\\n              title,\\n              timestamp_ms,\\n              bumped_ms,\\n              author_username\\n            FROM topics\\n        \"],[\"\\\\\\n            SELECT\\n              id,\\n              category_id,\\n              title,\\n              timestamp_ms,\\n              bumped_ms,\\n              author_username\\n            FROM topics\\n        \"])))).all().map(x=>({id:x.id,categoryId:x.category_id,title:x.title,timestampMs:x.timestamp_ms,bumpedMs:x.bumped_ms,authorUsername:x.author_username}));const tags=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject10||(_templateObject10=_taggedTemplateLiteral([\"            SELECT\\n              tag_name AS tagName,\\n              topic_id AS topicId\\n            FROM topic_tags\\n            ORDER BY tagName\\n        \"],[\"\\\\\\n            SELECT\\n              tag_name AS tagName,\\n              topic_id AS topicId\\n            FROM topic_tags\\n            ORDER BY tagName\\n        \"])))).all();const idToTags=new Map();for(const{tagName,topicId}of tags){_util_map__WEBPACK_IMPORTED_MODULE_2__[\"pushValue\"](idToTags,topicId,tagName);}return topics.map(t=>{const tags=idToTags.get(t.id)||[];return _objectSpread(_objectSpread({},t),{},{tags});});})();}topicById(id){const res=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject11||(_templateObject11=_taggedTemplateLiteral([\"          SELECT\\n            id,\\n            category_id,\\n            title,\\n            timestamp_ms,\\n            bumped_ms,\\n            author_username,\\n            topic_tags.tag_name AS tagName\\n          FROM topics\\n          LEFT OUTER JOIN topic_tags\\n            ON topics.id = topic_tags.topic_id\\n          WHERE id = :id\\n          ORDER BY tagName\\n        \"],[\"\\\\\\n          SELECT\\n            id,\\n            category_id,\\n            title,\\n            timestamp_ms,\\n            bumped_ms,\\n            author_username,\\n            topic_tags.tag_name AS tagName\\n          FROM topics\\n          LEFT OUTER JOIN topic_tags\\n            ON topics.id = topic_tags.topic_id\\n          WHERE id = :id\\n          ORDER BY tagName\\n        \"])))).all({id});if(res.length===0){return null;}const first=res[0];const tags=first.tagName==null?[]:res.map(x=>x.tagName);return{id:first.id,categoryId:first.category_id,tags,title:first.title,timestampMs:first.timestamp_ms,bumpedMs:first.bumped_ms,authorUsername:first.author_username};}posts(){return this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject12||(_templateObject12=_taggedTemplateLiteral([\"          SELECT\\n            id,\\n            timestamp_ms,\\n            author_username,\\n            topic_id,\\n            trust_level,\\n            index_within_topic,\\n            reply_to_post_index,\\n            cooked\\n          FROM posts\"],[\"\\\\\\n          SELECT\\n            id,\\n            timestamp_ms,\\n            author_username,\\n            topic_id,\\n            trust_level,\\n            index_within_topic,\\n            reply_to_post_index,\\n            cooked\\n          FROM posts\"])))).all().map(x=>({id:x.id,timestampMs:x.timestamp_ms,authorUsername:x.author_username,topicId:x.topic_id,trustLevel:x.trust_level,indexWithinTopic:x.index_within_topic,replyToPostIndex:x.reply_to_post_index,cooked:x.cooked}));}postById(id){const res=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject13||(_templateObject13=_taggedTemplateLiteral([\"          SELECT\\n            id,\\n            timestamp_ms,\\n            author_username,\\n            topic_id,\\n            trust_level,\\n            index_within_topic,\\n            reply_to_post_index,\\n            cooked\\n          FROM posts\\n          WHERE id = :id\"],[\"\\\\\\n          SELECT\\n            id,\\n            timestamp_ms,\\n            author_username,\\n            topic_id,\\n            trust_level,\\n            index_within_topic,\\n            reply_to_post_index,\\n            cooked\\n          FROM posts\\n          WHERE id = :id\"])))).get({id});if(!res){return null;}return{id:res.id,timestampMs:res.timestamp_ms,authorUsername:res.author_username,topicId:res.topic_id,trustLevel:res.trust_level,indexWithinTopic:res.index_within_topic,replyToPostIndex:res.reply_to_post_index,cooked:res.cooked};}users(){return this._db.prepare(\"SELECT username, trust_level FROM users\").all().map(x=>({username:x.username,trustLevel:x.trust_level}));}findUser(username){const user=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject14||(_templateObject14=_taggedTemplateLiteral([\"          SELECT username, trust_level\\n          FROM users\\n          WHERE username = :username COLLATE NOCASE\\n        \"],[\"\\\\\\n          SELECT username, trust_level\\n          FROM users\\n          WHERE username = :username COLLATE NOCASE\\n        \"])))).get({username});if(user==null){return null;}return{username:user.username,trustLevel:user.trust_level};}likes(){return this._db.prepare(\"SELECT post_id, username, timestamp_ms FROM likes\").all().map(x=>({postId:x.post_id,timestampMs:x.timestamp_ms,username:x.username}));}findPostInTopic(topicId,indexWithinTopic){return this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject15||(_templateObject15=_taggedTemplateLiteral([\"          SELECT id\\n          FROM posts\\n          WHERE topic_id = :topic_id AND index_within_topic = :index_within_topic\\n        \"],[\"\\\\\\n          SELECT id\\n          FROM posts\\n          WHERE topic_id = :topic_id AND index_within_topic = :index_within_topic\\n        \"])))).pluck().get({topic_id:topicId,index_within_topic:indexWithinTopic});}bumpDefinitionTopicCheck(timestampMs){this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject16||(_templateObject16=_taggedTemplateLiteral([\"          REPLACE INTO sync_heads (\\n              key,\\n              timestamp_ms\\n          ) VALUES (\\n              :key,\\n              :timestamp_ms\\n          )\\n        \"],[\"\\\\\\n          REPLACE INTO sync_heads (\\n              key,\\n              timestamp_ms\\n          ) VALUES (\\n              :key,\\n              :timestamp_ms\\n          )\\n        \"])))).run({key:DEFINITION_CHECK_KEY,timestamp_ms:timestampMs});}addLike(like){this.addUserIfNotExists({username:like.username,trustLevel:null});const res=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject17||(_templateObject17=_taggedTemplateLiteral([\"          INSERT OR IGNORE INTO likes (\\n              post_id,\\n              timestamp_ms,\\n              username\\n          ) VALUES (\\n              :post_id,\\n              :timestamp_ms,\\n              :username\\n          )\\n        \"],[\"\\\\\\n          INSERT OR IGNORE INTO likes (\\n              post_id,\\n              timestamp_ms,\\n              username\\n          ) VALUES (\\n              :post_id,\\n              :timestamp_ms,\\n              :username\\n          )\\n        \"])))).run({post_id:like.postId,timestamp_ms:like.timestampMs,username:like.username});return toAddResult(res);}replaceTopicTransaction(topic,posts){this._transaction(()=>{this.addTopic(topic);for(const post of posts){this.addPost(post);}this.deleteUnexpectedPosts(topic.id,posts.map(p=>p.id));});}deleteUnexpectedPosts(topicId,expected){const res=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject18||(_templateObject18=_taggedTemplateLiteral([\"          DELETE FROM posts\\n          WHERE topic_id = ?\\n          AND id NOT IN (\",\")\\n        \"],[\"\\\\\\n          DELETE FROM posts\\n          WHERE topic_id = ?\\n          AND id NOT IN (\",\")\\n        \"])),expected.map(_=>\"?\").join(\",\"))).run(topicId,...expected);return res.changes;}bumpedMsForTopic(id){const res=this._db.prepare(\"SELECT bumped_ms FROM topics WHERE id = :id\").get({id});return res!=null?res.bumped_ms:null;}addPost(post){this.addOrReplaceUser({username:post.authorUsername,trustLevel:post.trustLevel});const res=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject19||(_templateObject19=_taggedTemplateLiteral([\"          REPLACE INTO posts (\\n              id,\\n              timestamp_ms,\\n              author_username,\\n              topic_id,\\n              trust_level,\\n              index_within_topic,\\n              reply_to_post_index,\\n              cooked\\n          ) VALUES (\\n              :id,\\n              :timestamp_ms,\\n              :author_username,\\n              :topic_id,\\n              :trust_level,\\n              :index_within_topic,\\n              :reply_to_post_index,\\n              :cooked\\n          )\\n        \"],[\"\\\\\\n          REPLACE INTO posts (\\n              id,\\n              timestamp_ms,\\n              author_username,\\n              topic_id,\\n              trust_level,\\n              index_within_topic,\\n              reply_to_post_index,\\n              cooked\\n          ) VALUES (\\n              :id,\\n              :timestamp_ms,\\n              :author_username,\\n              :topic_id,\\n              :trust_level,\\n              :index_within_topic,\\n              :reply_to_post_index,\\n              :cooked\\n          )\\n        \"])))).run({id:post.id,timestamp_ms:post.timestampMs,reply_to_post_index:post.replyToPostIndex,index_within_topic:post.indexWithinTopic,topic_id:post.topicId,trust_level:post.trustLevel,author_username:post.authorUsername,cooked:post.cooked});return toAddResult(res);}addTopic(topic){this._db.transaction(()=>{this.addUserIfNotExists({username:topic.authorUsername,trustLevel:null});this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject20||(_templateObject20=_taggedTemplateLiteral([\"            REPLACE INTO topics (\\n                id,\\n                category_id,\\n                title,\\n                timestamp_ms,\\n                bumped_ms,\\n                author_username\\n            ) VALUES (\\n                :id,\\n                :category_id,\\n                :title,\\n                :timestamp_ms,\\n                :bumped_ms,\\n                :author_username\\n            )\\n        \"],[\"\\\\\\n            REPLACE INTO topics (\\n                id,\\n                category_id,\\n                title,\\n                timestamp_ms,\\n                bumped_ms,\\n                author_username\\n            ) VALUES (\\n                :id,\\n                :category_id,\\n                :title,\\n                :timestamp_ms,\\n                :bumped_ms,\\n                :author_username\\n            )\\n        \"])))).run({id:topic.id,category_id:topic.categoryId,title:topic.title,timestamp_ms:topic.timestampMs,bumped_ms:topic.bumpedMs,author_username:topic.authorUsername});this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject21||(_templateObject21=_taggedTemplateLiteral([\"\\n            DELETE FROM topic_tags\\n            WHERE topic_id = :id\\n      \"])))).run({id:topic.id});const addTag=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject22||(_templateObject22=_taggedTemplateLiteral([\"\\n          INSERT INTO topic_tags (\\n            tag_name,\\n            topic_id\\n          ) VALUES (\\n            :tagName,\\n            :id\\n          )\\n      \"]))));for(const tagName of topic.tags){addTag.run({id:topic.id,tagName});}})();}addUserIfNotExists(user){const{trustLevel,username}=user;const res=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject23||(_templateObject23=_taggedTemplateLiteral([\"          INSERT OR IGNORE INTO users (\\n            username,\\n            trust_level\\n          ) VALUES (\\n            :username,\\n            :trust_level\\n          )\"],[\"\\\\\\n          INSERT OR IGNORE INTO users (\\n            username,\\n            trust_level\\n          ) VALUES (\\n            :username,\\n            :trust_level\\n          )\"])))).run({username,trust_level:trustLevel});return toAddResult(res);}addOrReplaceUser(user){const{trustLevel,username}=user;const res=this._db.prepare(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_templateObject24||(_templateObject24=_taggedTemplateLiteral([\"          INSERT OR REPLACE INTO users (\\n            username,\\n            trust_level\\n          ) VALUES (\\n            :username,\\n            :trust_level\\n          )\"],[\"\\\\\\n          INSERT OR REPLACE INTO users (\\n            username,\\n            trust_level\\n          ) VALUES (\\n            :username,\\n            :trust_level\\n          )\"])))).run({username,trust_level:trustLevel});return toAddResult(res);}}\n\n//# sourceURL=webpack:///./src/plugins/discourse/mirrorRepository.js?");

/***/ }),

/***/ "./src/plugins/discourse/nodesAndEdges.js":
/*!************************************************!*\
  !*** ./src/plugins/discourse/nodesAndEdges.js ***!
  \************************************************/
/*! exports provided: userNode, topicNode, postNode, likeNode, authorsTopicEdge, authorsPostEdge, topicContainsPostEdge, topicHasLikedPostEdge, postRepliesEdge, createsLikeEdge, likesEdge, referencesTopicEdge, referencesPostEdge, referencesUserEdge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"userNode\", function() { return userNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topicNode\", function() { return topicNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postNode\", function() { return postNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"likeNode\", function() { return likeNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authorsTopicEdge\", function() { return authorsTopicEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authorsPostEdge\", function() { return authorsPostEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topicContainsPostEdge\", function() { return topicContainsPostEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topicHasLikedPostEdge\", function() { return topicHasLikedPostEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postRepliesEdge\", function() { return postRepliesEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createsLikeEdge\", function() { return createsLikeEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"likesEdge\", function() { return likesEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referencesTopicEdge\", function() { return referencesTopicEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referencesPostEdge\", function() { return referencesPostEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referencesUserEdge\", function() { return referencesUserEdge; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/discourse/declaration.js\");\n/* harmony import */ var _address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./address */ \"./src/plugins/discourse/address.js\");\nfunction userNode(serverUrl,username){const url=\"\".concat(serverUrl,\"/u/\").concat(username,\"/\");const description=\"discourse/[@\".concat(username,\"](\").concat(url,\")\");return{address:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"userAddress\"])(serverUrl,username),description,timestampMs:null};}function topicNode(serverUrl,topic){const url=\"\".concat(serverUrl,\"/t/\").concat(String(topic.id));const description=\"[\".concat(topic.title,\"](\").concat(url,\")\");const address=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"topicAddress\"])(serverUrl,topic.id);return{address,description,timestampMs:topic.timestampMs};}function postNode(serverUrl,post,description){const address=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,post.id);return{timestampMs:post.timestampMs,address,description};}function likeNode(serverUrl,like,postDescription){const address=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"likeAddress\"])(serverUrl,like);const description=\"\\u2764\\uFE0F by \".concat(like.username,\" on \").concat(postDescription);return{timestampMs:like.timestampMs,address,description};}function authorsTopicEdge(serverUrl,topic){const address=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"authorsTopicEdgeType\"].prefix,serverUrl,topic.authorUsername,String(topic.id));return{address,timestampMs:topic.timestampMs,src:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"userAddress\"])(serverUrl,topic.authorUsername),dst:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"topicAddress\"])(serverUrl,topic.id)};}function authorsPostEdge(serverUrl,post){const address=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"authorsPostEdgeType\"].prefix,serverUrl,post.authorUsername,String(post.id));return{address,timestampMs:post.timestampMs,src:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"userAddress\"])(serverUrl,post.authorUsername),dst:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,post.id)};}function topicContainsPostEdge(serverUrl,post){const address=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"topicContainsPostEdgeType\"].prefix,serverUrl,String(post.topicId),String(post.id));return{address,timestampMs:post.timestampMs,src:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"topicAddress\"])(serverUrl,post.topicId),dst:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,post.id)};}function topicHasLikedPostEdge(serverUrl,post){const address=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"topicHasLikedPostEdgeType\"].prefix,serverUrl,String(post.topicId),String(post.id));return{address,timestampMs:post.timestampMs,src:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"topicAddress\"])(serverUrl,post.topicId),dst:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,post.id)};}function postRepliesEdge(serverUrl,post,basePostId){const address=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"postRepliesEdgeType\"].prefix,serverUrl,String(post.id),String(basePostId));return{address,timestampMs:post.timestampMs,src:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,post.id),dst:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,basePostId)};}function createsLikeEdge(serverUrl,like){const address=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"createsLikeEdgeType\"].prefix,serverUrl,like.username,String(like.postId));return{address,timestampMs:like.timestampMs,src:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"userAddress\"])(serverUrl,like.username),dst:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"likeAddress\"])(serverUrl,like)};}function likesEdge(serverUrl,like){const address=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"likesEdgeType\"].prefix,serverUrl,like.username,String(like.postId));return{address,timestampMs:like.timestampMs,src:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"likeAddress\"])(serverUrl,like),dst:Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,like.postId)};}function referencesTopicEdge(serverUrl,post,reference){const address=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"referencesTopicEdgeType\"].prefix,serverUrl,String(post.id),String(reference.topicId));const src=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,post.id);const dst=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"topicAddress\"])(serverUrl,reference.topicId);return{src,dst,timestampMs:post.timestampMs,address};}function referencesPostEdge(serverUrl,post,referredPostId){const address=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"referencesPostEdgeType\"].prefix,serverUrl,String(post.id),String(referredPostId));const src=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,post.id);const dst=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,referredPostId);return{src,dst,timestampMs:post.timestampMs,address};}function referencesUserEdge(serverUrl,post,reference){const address=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"referencesUserEdgeType\"].prefix,serverUrl,String(post.id),reference.username);const src=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"postAddress\"])(serverUrl,post.id);const dst=Object(_address__WEBPACK_IMPORTED_MODULE_2__[\"userAddress\"])(serverUrl,reference.username);return{src,dst,timestampMs:post.timestampMs,address};}\n\n//# sourceURL=webpack:///./src/plugins/discourse/nodesAndEdges.js?");

/***/ }),

/***/ "./src/plugins/discourse/plugin.js":
/*!*****************************************!*\
  !*** ./src/plugins/discourse/plugin.js ***!
  \*****************************************/
/*! exports provided: DiscoursePlugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiscoursePlugin\", function() { return DiscoursePlugin; });\n/* harmony import */ var better_sqlite3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! better-sqlite3 */ \"better-sqlite3\");\n/* harmony import */ var better_sqlite3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(better_sqlite3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _createGraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createGraph */ \"./src/plugins/discourse/createGraph.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/discourse/declaration.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ \"./src/plugins/discourse/config.js\");\n/* harmony import */ var _mirrorRepository__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mirrorRepository */ \"./src/plugins/discourse/mirrorRepository.js\");\n/* harmony import */ var _fetch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fetch */ \"./src/plugins/discourse/fetch.js\");\n/* harmony import */ var _mirror__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mirror */ \"./src/plugins/discourse/mirror.js\");\n/* harmony import */ var _referenceDetector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./referenceDetector */ \"./src/plugins/discourse/referenceDetector.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/storage/disk */ \"./src/core/storage/disk.js\");\n/* harmony import */ var _createIdentities__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./createIdentities */ \"./src/plugins/discourse/createIdentities.js\");\nasync function loadConfig(dirContext){const dirname=dirContext.configDirectory();const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_10__[\"DiskStorage\"](dirname);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_9__[\"loadJson\"])(storage,\"config.json\",_config__WEBPACK_IMPORTED_MODULE_4__[\"parser\"]);}async function repository(ctx,serverUrl){const path=Object(path__WEBPACK_IMPORTED_MODULE_1__[\"join\"])(ctx.cacheDirectory(),\"discourseMirror.db\");const db=await new better_sqlite3__WEBPACK_IMPORTED_MODULE_0___default.a(path);return new _mirrorRepository__WEBPACK_IMPORTED_MODULE_5__[\"SqliteMirrorRepository\"](db,serverUrl);}class DiscoursePlugin{async declaration(){return _declaration__WEBPACK_IMPORTED_MODULE_3__[\"declaration\"];}async load(ctx,reporter){const{serverUrl,mirrorOptions}=await loadConfig(ctx);const repo=await repository(ctx,serverUrl);const fetcher=new _fetch__WEBPACK_IMPORTED_MODULE_6__[\"Fetcher\"]({serverUrl});const mirror=new _mirror__WEBPACK_IMPORTED_MODULE_7__[\"Mirror\"](repo,fetcher,serverUrl,mirrorOptions);await mirror.update(reporter);}async graph(ctx,rd){const _=rd;// TODO(#1808): not yet used\nconst config=await loadConfig(ctx);const repo=await repository(ctx,config.serverUrl);return Object(_createGraph__WEBPACK_IMPORTED_MODULE_2__[\"createGraph\"])(config,repo);}async referenceDetector(ctx){const config=await loadConfig(ctx);const repo=await repository(ctx,config.serverUrl);return new _referenceDetector__WEBPACK_IMPORTED_MODULE_8__[\"DiscourseReferenceDetector\"](repo);}async identities(ctx){const config=await loadConfig(ctx);const repo=await repository(ctx,config.serverUrl);return Object(_createIdentities__WEBPACK_IMPORTED_MODULE_11__[\"createIdentities\"])(config.serverUrl,repo);}}\n\n//# sourceURL=webpack:///./src/plugins/discourse/plugin.js?");

/***/ }),

/***/ "./src/plugins/discourse/referenceDetector.js":
/*!****************************************************!*\
  !*** ./src/plugins/discourse/referenceDetector.js ***!
  \****************************************************/
/*! exports provided: DiscourseReferenceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiscourseReferenceDetector\", function() { return DiscourseReferenceDetector; });\n/* harmony import */ var _address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address */ \"./src/plugins/discourse/address.js\");\n/* harmony import */ var _references__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./references */ \"./src/plugins/discourse/references.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * Discourse ReferenceDetector detector that relies on database lookups.\n */class DiscourseReferenceDetector{constructor(data){_defineProperty(this,\"data\",void 0);this.data=data;}addressFromUrl(url){const[reference]=Object(_references__WEBPACK_IMPORTED_MODULE_1__[\"linksToReferences\"])([url]);if(!reference){return null;}switch(reference.type){case\"TOPIC\":{// Just validating the topic exists.\nif(this.data.topicById(reference.topicId)){return Object(_address__WEBPACK_IMPORTED_MODULE_0__[\"topicAddress\"])(reference.serverUrl,reference.topicId);}break;}case\"POST\":{// For posts, we need to convert from topicId + index to a post ID.\n// We're using it to validate the topic and post index exist as well.\nconst postId=this.data.findPostInTopic(reference.topicId,reference.postIndex);if(postId){return Object(_address__WEBPACK_IMPORTED_MODULE_0__[\"postAddress\"])(reference.serverUrl,postId);}break;}case\"USER\":{// Look up the username to validate it exists, and make sure we use\n// the result. As this should correct our capitalization. See #1479.\nconst user=this.data.findUser(reference.username);if(user){return Object(_address__WEBPACK_IMPORTED_MODULE_0__[\"userAddress\"])(reference.serverUrl,user.username);}break;}default:{throw new Error(\"Unexpected reference type: \".concat(reference.type));}}}}\n\n//# sourceURL=webpack:///./src/plugins/discourse/referenceDetector.js?");

/***/ }),

/***/ "./src/plugins/discourse/references.js":
/*!*********************************************!*\
  !*** ./src/plugins/discourse/references.js ***!
  \*********************************************/
/*! exports provided: parseLinks, linksToReferences */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseLinks\", function() { return parseLinks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linksToReferences\", function() { return linksToReferences; });\nconst htmlparser2=__webpack_require__(/*! htmlparser2 */ \"htmlparser2\");/**\n * Parse the links from a Discourse post's cookedHtml, generating\n * an array of UrlStrings. All of the UrlStrings will contain the full\n * server URL (i.e. relative references are made absolute). The serverUrl\n * is required so that we can do this.\n */function parseLinks(cookedHtml,serverUrl){const links=[];const httpRegex=/^https?:\\/\\//;if(serverUrl[serverUrl.length-1]===\"/\"){// Strip trailing slash if it was provided, so we can concatenate\n// strings below.\nserverUrl=serverUrl.slice(0,serverUrl.length-1);}if(!serverUrl.match(httpRegex)){throw new Error(\"Invalid server url \".concat(serverUrl));}const parser=new htmlparser2.Parser({onopentag(name,attribs){if(name===\"a\"){const href=attribs.href;if(href!=null){if(href.match(httpRegex)){links.push(href);}if(href[0]===\"/\"){links.push(serverUrl+href);}}}}});parser.write(cookedHtml);parser.end();return links;}function linksToReferences(links){const server=\"(https?://[\\\\w.-]+)\";const topic=\"(?:\".concat(server,\")/t/[\\\\w-]+/(\\\\d+)\");const post=\"(?:\".concat(topic,\")/(\\\\d+)\");const params=\"(?:\\\\?[\\\\w-=]+)?\";const topicRegex=new RegExp(\"^(?:\".concat(topic,\")(?:\").concat(params,\")/?$\"));const postRegex=new RegExp(\"^(?:\".concat(post,\")(?:\").concat(params,\")/?$\"));const userRegex=new RegExp(\"^(?:\".concat(server,\")/u/([\\\\w-]+)(?:\").concat(params,\")/?$\"));const references=[];for(const link of links){let match=null;let decoded;try{decoded=decodeURI(link);}catch(e){console.error(\"\".concat(e,\"\\nFor URL: \").concat(link));continue;}if(match=decoded.match(postRegex)){references.push({type:\"POST\",topicId:+match[2],serverUrl:match[1],postIndex:+match[3]});}else if(match=decoded.match(topicRegex)){references.push({type:\"TOPIC\",topicId:+match[2],serverUrl:match[1]});}else if(match=decoded.match(userRegex)){references.push({type:\"USER\",username:match[2],serverUrl:match[1]});}}return references;}\n\n//# sourceURL=webpack:///./src/plugins/discourse/references.js?");

/***/ }),

/***/ "./src/plugins/discourse/weights.js":
/*!******************************************!*\
  !*** ./src/plugins/discourse/weights.js ***!
  \******************************************/
/*! exports provided: parseCategoryId, parseTagId, serializedWeightsConfigParser, weightsConfigParser, likeWeight, _trustLevelWeight, _categoryWeight, _weightFromTags */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseCategoryId\", function() { return parseCategoryId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseTagId\", function() { return parseTagId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"serializedWeightsConfigParser\", function() { return serializedWeightsConfigParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"weightsConfigParser\", function() { return weightsConfigParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"likeWeight\", function() { return likeWeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_trustLevelWeight\", function() { return _trustLevelWeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_categoryWeight\", function() { return _categoryWeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_weightFromTags\", function() { return _weightFromTags; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/map */ \"./src/util/map.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _createGraph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createGraph */ \"./src/plugins/discourse/createGraph.js\");\nfunction parseCategoryId(id){const result=parseInt(id,10);if(Number.isNaN(result)||result.toString()!==id){throw new Error(\"CategoryId should be a string integer; got \".concat(id));}return id;}// parse out the opaque type\nfunction parseTagId(id){return id;}function upgrade(s){return{defaultTagWeight:Object(_util_null__WEBPACK_IMPORTED_MODULE_2__[\"orElse\"])(s.defaultTagWeight,1),defaultCategoryWeight:Object(_util_null__WEBPACK_IMPORTED_MODULE_2__[\"orElse\"])(s.defaultCategoryWeight,1),tagWeights:_util_map__WEBPACK_IMPORTED_MODULE_1__[\"fromObject\"](s.tagWeights||{}),categoryWeights:_util_map__WEBPACK_IMPORTED_MODULE_1__[\"fromObject\"](s.categoryWeights||{})};}const serializedWeightsConfigParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({},{defaultCategoryWeight:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],defaultTagWeight:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],categoryWeights:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"dict\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"delimited\"](\"//\"),parseCategoryId)),tagWeights:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"dict\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],parseTagId))});const weightsConfigParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](serializedWeightsConfigParser,upgrade);function likeWeight(weights,user,category,tags){const trustLevel=user==null?0:_trustLevelWeight(user.trustLevel);const categoryWeight=category==null?1:_categoryWeight(category,weights);const tagWeight=tags==null?1:_weightFromTags(tags,weights);return trustLevel*categoryWeight*tagWeight;}function _trustLevelWeight(trustLevel){if(trustLevel==null){// The null trust level shouldn't happen in practice, right now users who\n// only like but never post will have null trust level (will be fixed by #2045).\n// This means they could have trust level 1. But to be conservative, we treat anyone\n// with a null trust level as if they have trust level 0.\n// Possibly this could come up with deleted users too.\nreturn _createGraph__WEBPACK_IMPORTED_MODULE_3__[\"DEFAULT_TRUST_LEVEL_TO_WEIGHT\"][\"0\"];}const key=String(trustLevel);const weight=_createGraph__WEBPACK_IMPORTED_MODULE_3__[\"DEFAULT_TRUST_LEVEL_TO_WEIGHT\"][key];if(weight==null){throw new Error(\"invalid trust level: \".concat(String(key)));}return weight;}function _categoryWeight(category,_ref){let{categoryWeights,defaultCategoryWeight}=_ref;const weight=categoryWeights.get(category);return weight==null?defaultCategoryWeight:weight;}function _weightFromTags(tags,_ref2){let{tagWeights,defaultTagWeight}=_ref2;const weightForTag=tagId=>Object(_util_null__WEBPACK_IMPORTED_MODULE_2__[\"orElse\"])(tagWeights.get(tagId),defaultTagWeight);return tags.reduce((acc,tag)=>acc*weightForTag(tag),1);}\n\n//# sourceURL=webpack:///./src/plugins/discourse/weights.js?");

/***/ }),

/***/ "./src/plugins/ethereum/createIdentities.js":
/*!**************************************************!*\
  !*** ./src/plugins/ethereum/createIdentities.js ***!
  \**************************************************/
/*! exports provided: createIdentity, createIdentities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createIdentity\", function() { return createIdentity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createIdentities\", function() { return createIdentities; });\n/* harmony import */ var _core_identity_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/identity/name */ \"./src/core/identity/name.js\");\n/* harmony import */ var _util_jsonLog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/jsonLog */ \"./src/util/jsonLog.js\");\n/* harmony import */ var _ethAddressNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ethAddressNode */ \"./src/plugins/ethereum/ethAddressNode.js\");\nfunction createIdentity(address){const alias={description:address,address:Object(_ethAddressNode__WEBPACK_IMPORTED_MODULE_2__[\"nodeAddressForEthAddress\"])(address)};return{pluginName:Object(_core_identity_name__WEBPACK_IMPORTED_MODULE_0__[\"nameFromString\"])(\"ethereum\"),name:Object(_core_identity_name__WEBPACK_IMPORTED_MODULE_0__[\"coerce\"])(address),type:\"USER\",alias};}function createIdentities(ethAddresses){return Array.from(ethAddresses.values()).map(createIdentity);}\n\n//# sourceURL=webpack:///./src/plugins/ethereum/createIdentities.js?");

/***/ }),

/***/ "./src/plugins/ethereum/declaration.js":
/*!*********************************************!*\
  !*** ./src/plugins/ethereum/declaration.js ***!
  \*********************************************/
/*! exports provided: nodePrefix, edgePrefix, ethAddressEntryType, declaration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodePrefix\", function() { return nodePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgePrefix\", function() { return edgePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ethAddressEntryType\", function() { return ethAddressEntryType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"declaration\", function() { return declaration; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\nconst nodePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts([\"sourcecred\",\"ethereum\"]);const edgePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].fromParts([\"sourcecred\",\"ethereum\"]);const ethAddressEntryType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Ethereum Address Entry\",pluralName:\"Ethereum Address Entries\",prefix:nodePrefix,defaultWeight:0,description:\"A Ethereum address, that can be utilized by a participant\"+\"to receive grain payouts, and linked to their identity.\"});const declaration=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Ethereum\",nodePrefix,edgePrefix,nodeTypes:[ethAddressEntryType],edgeTypes:[],userTypes:[ethAddressEntryType]});\n\n//# sourceURL=webpack:///./src/plugins/ethereum/declaration.js?");

/***/ }),

/***/ "./src/plugins/ethereum/ethAddress.js":
/*!********************************************!*\
  !*** ./src/plugins/ethereum/ethAddress.js ***!
  \********************************************/
/*! exports provided: ETH_CURRENCY_ADDRESS, parseAddress, truncateEthAddress, ethAddressParser, COMPAT_INFO, parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ETH_CURRENCY_ADDRESS\", function() { return ETH_CURRENCY_ADDRESS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseAddress\", function() { return parseAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"truncateEthAddress\", function() { return truncateEthAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ethAddressParser\", function() { return ethAddressParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMPAT_INFO\", function() { return COMPAT_INFO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web3-utils */ \"web3-utils\");\n/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3_utils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _util_compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/compat */ \"./src/util/compat.js\");\nconst ETH_CURRENCY_ADDRESS=\"0x0000000000000000000000000000000000000000\";/**\n * parseAddress will accept any 20-byte hexadecimal ethereum address encoded as\n * a string, optionally prefixed with `0x`.\n *\n * Per EIP-55 (https://eips.ethereum.org/EIPS/eip-55), parseAddress throws if\n * the provided string is mixed-case but not checksum-encoded. All valid\n * addresses in lower- and upper-case format will not throw.\n *\n * For consistency, all valid addresses are converted and returned in\n * mixed-case form with the `0x` prefix included\n *\n * valid formats:\n * \"2Ccc7cD913677553766873483ed9eEDdB77A0Bb0\"\n * \"0x2Ccc7cD913677553766873483ed9eEDdB77A0Bb0\"\n * \"0X2CCC7CD913677553766873483ED9EEDDB77A0BB0\"\n * \"0x2ccc7cd913677553766873483ed9eeddb77a0bb0\"\n *\n * invalid formats:\n * \"0x2ccc7cD913677553766873483ed9eEDdB77A0Bb0\"\n * \"2ccc7cD913677553766873483ed9eEDdB77A0Bb0\"\n */function parseAddress(s){if(!Object(web3_utils__WEBPACK_IMPORTED_MODULE_0__[\"isAddress\"])(s)){throw new Error(\"not a valid ethereum address: \".concat(s));}return Object(web3_utils__WEBPACK_IMPORTED_MODULE_0__[\"toChecksumAddress\"])(s);}// Utilized for a more readable and recognizable address. This is\n// needed to allow the address to fit within the Identity name requirements\nfunction truncateEthAddress(address){const prefix=address.slice(0,6);const suffix=address.slice(-4);return\"\".concat(prefix,\"...\").concat(suffix);}const ethAddressParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"string\"],parseAddress);const COMPAT_INFO={type:\"sourcecred/ethAddress\",version:\"0.0.1\"};const addressEntriesParser=_util_combo__WEBPACK_IMPORTED_MODULE_1__[\"array\"](ethAddressParser);const parser=Object(_util_compat__WEBPACK_IMPORTED_MODULE_2__[\"compatibleParser\"])(COMPAT_INFO.type,{\"0.0.1\":addressEntriesParser});\n\n//# sourceURL=webpack:///./src/plugins/ethereum/ethAddress.js?");

/***/ }),

/***/ "./src/plugins/ethereum/ethAddressNode.js":
/*!************************************************!*\
  !*** ./src/plugins/ethereum/ethAddressNode.js ***!
  \************************************************/
/*! exports provided: nodeAddressForEthAddress */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodeAddressForEthAddress\", function() { return nodeAddressForEthAddress; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/ethereum/declaration.js\");\nfunction nodeAddressForEthAddress(address){return _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"nodePrefix\"],address);}\n\n//# sourceURL=webpack:///./src/plugins/ethereum/ethAddressNode.js?");

/***/ }),

/***/ "./src/plugins/ethereum/plugin.js":
/*!****************************************!*\
  !*** ./src/plugins/ethereum/plugin.js ***!
  \****************************************/
/*! exports provided: EthereumPlugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EthereumPlugin\", function() { return EthereumPlugin; });\n/* harmony import */ var _core_references__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/references */ \"./src/core/references/index.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/ethereum/declaration.js\");\n/* harmony import */ var _ethAddress__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ethAddress */ \"./src/plugins/ethereum/ethAddress.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/storage/disk */ \"./src/core/storage/disk.js\");\n/* harmony import */ var _core_weightedGraph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/weightedGraph */ \"./src/core/weightedGraph.js\");\n/* harmony import */ var _createIdentities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createIdentities */ \"./src/plugins/ethereum/createIdentities.js\");\nasync function loadEthJson(ctx){const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_4__[\"DiskStorage\"](ctx.configDirectory());return await Object(_util_storage__WEBPACK_IMPORTED_MODULE_3__[\"loadJson\"])(storage,\"ethereumAddresses.json\",_ethAddress__WEBPACK_IMPORTED_MODULE_2__[\"parser\"]);}class EthereumPlugin{async declaration(){return _declaration__WEBPACK_IMPORTED_MODULE_1__[\"declaration\"];}// We dont need to load any data since eth addresses are on disk\nasync load(){}// TODO: Implement weighted graph generation logic\nasync graph(_unused_ctx,_unused_rd){return Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_5__[\"empty\"])();}// TODO: Implement referenceDetector generation logic\nasync referenceDetector(_unused_ctx){const emptyReferenceDetector=new _core_references__WEBPACK_IMPORTED_MODULE_0__[\"MappedReferenceDetector\"](new Map());return emptyReferenceDetector;}async identities(ctx){const ethAddressJson=await loadEthJson(ctx);return Object(_createIdentities__WEBPACK_IMPORTED_MODULE_6__[\"createIdentities\"])(ethAddressJson);}}\n\n//# sourceURL=webpack:///./src/plugins/ethereum/plugin.js?");

/***/ }),

/***/ "./src/plugins/external/defaultDeclaration.js":
/*!****************************************************!*\
  !*** ./src/plugins/external/defaultDeclaration.js ***!
  \****************************************************/
/*! exports provided: contributionNodeType, participantNodeType, declaration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contributionNodeType\", function() { return contributionNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"participantNodeType\", function() { return participantNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"declaration\", function() { return declaration; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _api_pluginId__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../api/pluginId */ \"./src/api/pluginId.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\nfunction contributionNodeType(id){return deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Contribution\",pluralName:\"Contributions\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].fromParts([Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginOwner\"])(id),Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginName\"])(id),\"CONTRIBUTION\"]),defaultWeight:1,description:\"NodeType for a generic contribution\"});}function participantNodeType(id){return deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Participant\",pluralName:\"Participant\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].fromParts([Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginOwner\"])(id),Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginName\"])(id),\"PARTICIPANT\"]),defaultWeight:1,description:\"NodeType for a generic participant\"});}function participatedInEdgeType(id){return deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"participated in\",backwardName:\"had participation from\",defaultWeight:{forwards:1/2,backwards:1},prefix:_core_graph__WEBPACK_IMPORTED_MODULE_2__[\"EdgeAddress\"].fromParts([Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginOwner\"])(id),Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginName\"])(id),\"PARTICIPATES_IN\"]),description:\"NodeType for a generic participant-contribution relationship\"});}function declaration(id){return deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginName\"])(id),nodePrefix:_core_graph__WEBPACK_IMPORTED_MODULE_2__[\"NodeAddress\"].fromParts([Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginOwner\"])(id),Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginName\"])(id)]),edgePrefix:_core_graph__WEBPACK_IMPORTED_MODULE_2__[\"EdgeAddress\"].fromParts([Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginOwner\"])(id),Object(_api_pluginId__WEBPACK_IMPORTED_MODULE_1__[\"getPluginName\"])(id)]),nodeTypes:[participantNodeType(id),contributionNodeType(id)],edgeTypes:[participatedInEdgeType(id)],userTypes:[participantNodeType(id)]});}\n\n//# sourceURL=webpack:///./src/plugins/external/defaultDeclaration.js?");

/***/ }),

/***/ "./src/plugins/external/plugin.js":
/*!****************************************!*\
  !*** ./src/plugins/external/plugin.js ***!
  \****************************************/
/*! exports provided: ExternalPluginIdOwner, ExternalPlugin, ConstructorPlugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExternalPluginIdOwner\", function() { return ExternalPluginIdOwner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExternalPlugin\", function() { return ExternalPlugin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConstructorPlugin\", function() { return ConstructorPlugin; });\n/* harmony import */ var _analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../analysis/pluginDeclaration */ \"./src/analysis/pluginDeclaration.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _core_weightedGraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/weightedGraph */ \"./src/core/weightedGraph.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var _core_weights__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/weights */ \"./src/core/weights.js\");\n/* harmony import */ var _core_storage_zip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/storage/zip */ \"./src/core/storage/zip.js\");\n/* harmony import */ var _core_ledger_identityProposal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/ledger/identityProposal */ \"./src/core/ledger/identityProposal.js\");\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _core_storage_networkStorage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/storage/networkStorage */ \"./src/core/storage/networkStorage.js\");\n/* harmony import */ var _defaultDeclaration__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./defaultDeclaration */ \"./src/plugins/external/defaultDeclaration.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const ExternalPluginIdOwner=\"external\";const FileNames={GRAPH:\"graph.json\",GRAPH_ZIP:\"graph\",DECLARATION:\"declaration.json\",IDENTITIES:\"identityProposals.json\"};const configParser=_util_combo__WEBPACK_IMPORTED_MODULE_7__[\"object\"]({graphUrl:_util_combo__WEBPACK_IMPORTED_MODULE_7__[\"string\"]},{declarationUrl:_util_combo__WEBPACK_IMPORTED_MODULE_7__[\"string\"],identityProposalsUrl:_util_combo__WEBPACK_IMPORTED_MODULE_7__[\"string\"]});/**\nA dynamic plugin that allows 3rd parties to rapidly pipe data into an instance.\n\nThe External plugin can be used multiple times, because it simply uses the \nPluginId pattern \"external/X\" where X can be any name (but preferably an agreed \nupon name between the 3rd-party software and the instance maintainer).\n\nThe External plugin loads its graph and optionally its declaration and \nidentityProposals from either:\n1. the plugin config folder on disk\n    - To use this method, simply place the files into the \n      `config/plugins/external/X` folder.\n2. a base url that statically serves the files\n    - To use this method, simply serve the files statically with cross-origin \n      enabled in the same directory, and add a `config.json` file in the \n      instance's `config/plugins/external/X` folder with form: \n      `{ \"Url\": \"https://www.myhost.com/path/to/directory\" }`\n\nSupported files for either method are:\n1. `graph.json`/`graph.json.gzip` (required) - works whether or not it is \n    compressed using our library\n2. `declaration.json` (optional) - if omitted, a default declaration with\n    minimal node/edge types is used, but also graphs don't have to adhere to the\n    declaration if they don't desire to be configured using our \n    Weight Configuration UI.\n3. `identityProposals.json` (optional) - if omitted, no identities are proposed\n\n*/class ExternalPlugin{constructor(options){_defineProperty(this,\"id\",void 0);_defineProperty(this,\"storage\",void 0);_defineProperty(this,\"defaultConfigDirectory\",void 0);_defineProperty(this,\"config\",void 0);if(!options.storage&&!options.config)throw new Error(\"Must provide either config or storage parameter to construct ExternalPlugin.\");this.id=options.pluginId;this.storage=options.storage;this.defaultConfigDirectory={configDirectory:()=>Object(path__WEBPACK_IMPORTED_MODULE_1__[\"join\"])(\"config/plugins/\",options.pluginId),cacheDirectory:()=>Object(path__WEBPACK_IMPORTED_MODULE_1__[\"join\"])(\"cache/\",options.pluginId)};this.config=options.config;}async getConfig(ctx){if(this.config)return this.config;const path=Object(path__WEBPACK_IMPORTED_MODULE_1__[\"join\"])(ctx.configDirectory(),\"config.json\");if(!this.storage)throw\"Something is wrong. Either storage or config should exist.\";return Object(_util_storage__WEBPACK_IMPORTED_MODULE_3__[\"loadJsonWithDefault\"])(this.storage,path,configParser,()=>undefined);}async getStorage(ctx,file){const config=await this.getConfig(ctx);if(config){switch(file){case\"GRAPH\":case\"GRAPH_ZIP\":return{storage:new _core_storage_networkStorage__WEBPACK_IMPORTED_MODULE_8__[\"NetworkStorage\"](config.graphUrl),path:\"\"};case\"DECLARATION\":return config.declarationUrl?{storage:new _core_storage_networkStorage__WEBPACK_IMPORTED_MODULE_8__[\"NetworkStorage\"](config.declarationUrl),path:\"\"}:undefined;case\"IDENTITIES\":return config.identityProposalsUrl?{storage:new _core_storage_networkStorage__WEBPACK_IMPORTED_MODULE_8__[\"NetworkStorage\"](config.identityProposalsUrl),path:\"\"}:undefined;}}if(!this.storage)throw\"Something is wrong. Either storage or config should exist.\";return{storage:this.storage,path:Object(path__WEBPACK_IMPORTED_MODULE_1__[\"join\"])(ctx.configDirectory(),FileNames[file])};}async declaration(){const result=await this.getStorage(this.defaultConfigDirectory,\"DECLARATION\");const json=result?await Object(_util_storage__WEBPACK_IMPORTED_MODULE_3__[\"loadJsonWithDefault\"])(result.storage,result.path,_analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_0__[\"declarationParser\"],()=>null):null;return json?json:Object(_defaultDeclaration__WEBPACK_IMPORTED_MODULE_9__[\"declaration\"])(this.id);}async load(_unused_ctx,_unused_reporter){return;}async graph(ctx,_unused_rd){const result=await this.getStorage(ctx,\"GRAPH\");const zipResult=await this.getStorage(ctx,\"GRAPH_ZIP\");if(!result||!zipResult)throw\"Something is wrong. Graph must have storage or config.\";const graphJSON=await Object(_util_storage__WEBPACK_IMPORTED_MODULE_3__[\"loadJson\"])(result.storage,result.path,_util_combo__WEBPACK_IMPORTED_MODULE_7__[\"raw\"]).catch(()=>{return Object(_util_storage__WEBPACK_IMPORTED_MODULE_3__[\"loadJson\"])(new _core_storage_zip__WEBPACK_IMPORTED_MODULE_5__[\"ZipStorage\"](zipResult.storage),zipResult.path,_util_combo__WEBPACK_IMPORTED_MODULE_7__[\"raw\"]);});const wg=Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_2__[\"fromJSON\"])(graphJSON);const declarationWeights=Object(_analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_0__[\"weightsForDeclaration\"])(await this.declaration());return{graph:wg.graph,weights:Object(_core_weights__WEBPACK_IMPORTED_MODULE_4__[\"merge\"])([wg.weights,declarationWeights])};}async referenceDetector(_unused_ctx){return{addressFromUrl:()=>undefined};}async identities(ctx){const result=await this.getStorage(ctx,\"IDENTITIES\");return result?await Object(_util_storage__WEBPACK_IMPORTED_MODULE_3__[\"loadJsonWithDefault\"])(result.storage,result.path,_core_ledger_identityProposal__WEBPACK_IMPORTED_MODULE_6__[\"identityProposalsParser\"],()=>[]):[];}}/**\nA way for 3rd-party developers to easily test their External Plugin.\nAfter generating a WeightedGraph, a Declaration, and IdentityProposals,\na developer could instantiate a ConstructorPlugin and pass it into our\n`graph` API using our library in environments such as Observable.\nThis is a prerequisite for testing using `credrank` because of the \nIdentityProposals. Once satisfied with the result, they can serve their files\nfor consumption by an ExternalPlugin configuration.\n */class ConstructorPlugin{constructor(options){_defineProperty(this,\"_weightedGraph\",void 0);_defineProperty(this,\"_identityProposals\",void 0);_defineProperty(this,\"_declaration\",void 0);this._weightedGraph=options.weightedGraph||Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_2__[\"empty\"])();this._identityProposals=options.identityProposals||[];if(options.declaration)this._declaration=options.declaration;else if(options.pluginId)this._declaration=Object(_defaultDeclaration__WEBPACK_IMPORTED_MODULE_9__[\"declaration\"])(options.pluginId);else throw new Error(\"Must provide either a declaration or a pluginId\");}async declaration(){return this._declaration;}async load(_unused_ctx,_unused_reporter){}async graph(_unused_ctx,_unused_rd){return this._weightedGraph;}async referenceDetector(_unused_ctx){return{addressFromUrl:()=>undefined};}async identities(_unused_ctx){return this._identityProposals;}}\n\n//# sourceURL=webpack:///./src/plugins/external/plugin.js?");

/***/ }),

/***/ "./src/plugins/git/nodes.js":
/*!**********************************!*\
  !*** ./src/plugins/git/nodes.js ***!
  \**********************************/
/*! exports provided: _gitAddress, COMMIT_TYPE, Prefix, fromRaw, toRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_gitAddress\", function() { return _gitAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMMIT_TYPE\", function() { return COMMIT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Prefix\", function() { return Prefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRaw\", function() { return fromRaw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRaw\", function() { return toRaw; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\nconst GIT_PREFIX=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts([\"sourcecred\",\"git\"]);function _gitAddress(){for(var _len=arguments.length,parts=new Array(_len),_key=0;_key<_len;_key++){parts[_key]=arguments[_key];}return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(GIT_PREFIX,...parts);}const COMMIT_TYPE=\"COMMIT\";const Prefix=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({base:GIT_PREFIX,commit:_gitAddress(COMMIT_TYPE)});function fromRaw(x){function fail(){return new Error(\"Bad address: \".concat(_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toString(x)));}if(!_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].hasPrefix(x,GIT_PREFIX)){throw fail();}const[_unused_sc,_unused_git,_type,...rest]=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(x);const type=_type;switch(type){case\"COMMIT\":{if(rest.length!==1)throw fail();const[hash]=rest;return{type:COMMIT_TYPE,hash};}default:// eslint-disable-next-line no-unused-expressions\ntype;throw fail();}}function toRaw(x){switch(x.type){case COMMIT_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.commit,x.hash);default:throw new Error(\"Unexpected type \".concat(x.type));}}\n\n//# sourceURL=webpack:///./src/plugins/git/nodes.js?");

/***/ }),

/***/ "./src/plugins/github/bots.js":
/*!************************************!*\
  !*** ./src/plugins/github/bots.js ***!
  \************************************/
/*! exports provided: botSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"botSet\", function() { return botSet; });\n// TODO(#638): Allow projects to specify bots via configuration,\n// rather than depending on this single souce of truth\nfunction botSet(){return new Set([\"codecov\",\"codecov-io\",\"credbot\",\"facebook-github-bot\",\"gitcoinbot\",\"gitter-badger\",\"googlebot\",\"greenkeeper\",\"greenkeeperio-bot\",\"metamaskbot\",\"nodejs-github-bot\",\"stickler-ci\",\"tensorflow-gardener\",\"tensorflow-jenkins\",\"tensorflowbutler\",\"github-actions\",\"vercel\",\"codecov-commenter\",\"transifex-integration\",\"dependabot\"]);}\n\n//# sourceURL=webpack:///./src/plugins/github/bots.js?");

/***/ }),

/***/ "./src/plugins/github/cacheId.js":
/*!***************************************!*\
  !*** ./src/plugins/github/cacheId.js ***!
  \***************************************/
/*! exports provided: cacheIdForRepoId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheIdForRepoId\", function() { return cacheIdForRepoId; });\n/* harmony import */ var _repoId__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./repoId */ \"./src/plugins/github/repoId.js\");\n/**\n * A derived ID to reference a cache layer.\n */ /**\n * Derives the CacheId for a RepoId.\n *\n * Returned `CacheId`s will be:\n * - Deterministic\n * - Unique for this plugin\n * - Lowercase\n * - Safe to use for filenames\n * - Distinct for semantically distinct inputs (input IDs that differ\n *   only in case may map to the same output, because GitHub does not\n *   permit collisions-modulo-case)\n */function cacheIdForRepoId(repoId){// GitHub owner (user/organization) and repository names may be in\n// mixed case, but GitHub prevents mixed-case collisions: e.g., if\n// `foo` is a user then `Foo` cannot also be a user, and likewise for\n// repositories. GitHub login names are DNS-safe (`[0-9A-Za-z-]` only)\n// and so are filename-safe. Repository names have a slightly larger\n// character set, including underscore, but are also filename-safe.\n// Because login may not contain an underscore, it thus suffices to\n// use an underscore as the delimiter. The resulting filename uses\n// only `[0-9A-Za-z_.-]` and so is valid on all major filesystems.\nconst owner=repoId.owner.toLowerCase();const name=repoId.name.toLowerCase();if(owner.includes(\"_\")){throw new Error(\"unexpected underscore in GitHub owner name would be ambiguous: \"+Object(_repoId__WEBPACK_IMPORTED_MODULE_0__[\"repoIdToString\"])(repoId));}return\"github_\".concat(owner,\"_\").concat(name);}\n\n//# sourceURL=webpack:///./src/plugins/github/cacheId.js?");

/***/ }),

/***/ "./src/plugins/github/config.js":
/*!**************************************!*\
  !*** ./src/plugins/github/config.js ***!
  \**************************************/
/*! exports provided: parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _repoId__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./repoId */ \"./src/plugins/github/repoId.js\");\nconst parser=(()=>{const C=_util_combo__WEBPACK_IMPORTED_MODULE_0__;return C.object({repoIds:C.rename(\"repositories\",C.array(C.fmap(C.string,_repoId__WEBPACK_IMPORTED_MODULE_1__[\"stringToRepoId\"])))});})();\n\n//# sourceURL=webpack:///./src/plugins/github/config.js?");

/***/ }),

/***/ "./src/plugins/github/createGraph.js":
/*!*******************************************!*\
  !*** ./src/plugins/github/createGraph.js ***!
  \*******************************************/
/*! exports provided: createGraph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGraph\", function() { return createGraph; });\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _core_weights__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/weights */ \"./src/core/weights.js\");\n/* harmony import */ var _git_nodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../git/nodes */ \"./src/plugins/git/nodes.js\");\n/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nodes */ \"./src/plugins/github/nodes.js\");\n/* harmony import */ var _relationalView__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./relationalView */ \"./src/plugins/github/relationalView.js\");\n/* harmony import */ var _edges__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./edges */ \"./src/plugins/github/edges.js\");\n/* harmony import */ var _graphqlTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./graphqlTypes */ \"./src/plugins/github/graphqlTypes.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function createGraph(view){const creator=new GraphCreator();creator.addData(view);return{graph:creator.graph,weights:creator.weights};}class GraphCreator{constructor(){_defineProperty(this,\"graph\",void 0);_defineProperty(this,\"weights\",void 0);this.graph=new _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"Graph\"]();this.weights=Object(_core_weights__WEBPACK_IMPORTED_MODULE_2__[\"empty\"])();}addData(view){for(const entity of view.entities()){const address=_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](entity.address());this.graph.addNode({address,description:entity.description(),timestampMs:entity.timestampMs()});}for(const child of view.childEntities()){this.addHasParent(child);}for(const authored of view.authoredEntities()){this.addAuthors(authored);}for(const pull of view.pulls()){const commit=pull.mergedAs();if(commit!=null){const commitTimestamp=_util_null__WEBPACK_IMPORTED_MODULE_0__[\"get\"](view.commit(commit)).timestampMs();this.graph.addEdge(_edges__WEBPACK_IMPORTED_MODULE_6__[\"createEdge\"].mergedAs(pull.address(),commit,commitTimestamp));}else{const addr=_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](pull.address());// Un-merged PRs do not mint cred.\nthis.weights.nodeWeights.set(addr,0);}}for(const commit of view.commits()){const gitCommitAddress={type:_git_nodes__WEBPACK_IMPORTED_MODULE_3__[\"COMMIT_TYPE\"],hash:commit.hash()};this.graph.addEdge(_edges__WEBPACK_IMPORTED_MODULE_6__[\"createEdge\"].correspondsToCommit(commit.address(),gitCommitAddress,commit.timestampMs()));}for(const referrer of view.textContentEntities()){for(const referent of referrer.references()){this.graph.addEdge(_edges__WEBPACK_IMPORTED_MODULE_6__[\"createEdge\"].references(referrer.address(),referent.address(),referrer.timestampMs()));}}for(const reactable of view.reactableEntities()){for(const{content,user,timestampMs}of reactable.reactions()){// We only support unambiguously positive reactions for now\nif(content===_graphqlTypes__WEBPACK_IMPORTED_MODULE_7__[\"ReactionContent$Values\"].THUMBS_UP||content===_graphqlTypes__WEBPACK_IMPORTED_MODULE_7__[\"ReactionContent$Values\"].HEART||content===_graphqlTypes__WEBPACK_IMPORTED_MODULE_7__[\"ReactionContent$Values\"].HOORAY||content===_graphqlTypes__WEBPACK_IMPORTED_MODULE_7__[\"ReactionContent$Values\"].ROCKET){this.graph.addEdge(_edges__WEBPACK_IMPORTED_MODULE_6__[\"createEdge\"].reacts(content,user,reactable.address(),timestampMs));}}}}addAuthors(entity){for(const author of entity.authors()){this.graph.addEdge(_edges__WEBPACK_IMPORTED_MODULE_6__[\"createEdge\"].authors(author.address(),entity.address(),entity.timestampMs()));}}addHasParent(child){this.graph.addEdge(_edges__WEBPACK_IMPORTED_MODULE_6__[\"createEdge\"].hasParent(child.address(),child.parent().address(),child.timestampMs()));}}\n\n//# sourceURL=webpack:///./src/plugins/github/createGraph.js?");

/***/ }),

/***/ "./src/plugins/github/createIdentities.js":
/*!************************************************!*\
  !*** ./src/plugins/github/createIdentities.js ***!
  \************************************************/
/*! exports provided: _createIdentity, createIdentities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_createIdentity\", function() { return _createIdentity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createIdentities\", function() { return createIdentities; });\n/* harmony import */ var _core_identity_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/identity/name */ \"./src/core/identity/name.js\");\n/* harmony import */ var _relationalView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./relationalView */ \"./src/plugins/github/relationalView.js\");\n/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodes */ \"./src/plugins/github/nodes.js\");\nfunction _createIdentity(u){const alias={description:u.description(),address:Object(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"])(u.address())};function chooseType(u){const subtype=u.address().subtype;// TODO: We should let it infer ORGANIZATION or PROJECT types too,\n// but at present we'll let the maintainer set this directly in the UI.\nswitch(subtype){case\"USER\":{return\"USER\";}case\"BOT\":{return\"BOT\";}default:throw new Error(\"unknown userlike subtype: \".concat(subtype));}}return{pluginName:Object(_core_identity_name__WEBPACK_IMPORTED_MODULE_0__[\"nameFromString\"])(\"github\"),name:Object(_core_identity_name__WEBPACK_IMPORTED_MODULE_0__[\"coerce\"])(u.login()),type:chooseType(u),alias};}function createIdentities(rv){return Array.from(rv.userlikes()).map(_createIdentity);}\n\n//# sourceURL=webpack:///./src/plugins/github/createIdentities.js?");

/***/ }),

/***/ "./src/plugins/github/declaration.js":
/*!*******************************************!*\
  !*** ./src/plugins/github/declaration.js ***!
  \*******************************************/
/*! exports provided: repoNodeType, userNodeType, declaration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"repoNodeType\", function() { return repoNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"userNodeType\", function() { return userNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"declaration\", function() { return declaration; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodes */ \"./src/plugins/github/nodes.js\");\n/* harmony import */ var _edges__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edges */ \"./src/plugins/github/edges.js\");\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/dedent */ \"./src/util/dedent.js\");\nvar _templateObject,_templateObject2,_templateObject3,_templateObject4,_templateObject5,_templateObject6,_templateObject7,_templateObject8,_templateObject9;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}const repoNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Repository\",pluralName:\"Repositories\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].repo,defaultWeight:0,description:\"NodeType for a GitHub repository\"});const issueNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Issue\",pluralName:\"Issues\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].issue,defaultWeight:0,description:\"NodeType for a GitHub issue\"});const pullNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Pull request\",pluralName:\"Pull requests\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].pull,defaultWeight:4,description:\"NodeType for a GitHub pull request\"});const reviewNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Pull request review\",pluralName:\"Pull request reviews\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].review,defaultWeight:1,description:\"NodeType for a GitHub code review\"});const commentNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Comment\",pluralName:\"Comments\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].comment,defaultWeight:0,description:\"NodeType for a GitHub comment\"});const commitNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Commit\",pluralName:\"Commits\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].commit,defaultWeight:0,description:\"Represents a particular Git commit on GitHub, i.e. scoped to a particular repository\"});const userNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"User\",pluralName:\"Users\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].user,defaultWeight:0,description:\"NodeType for a GitHub user\"});const botNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Bot\",pluralName:\"Bots\",prefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].bot,defaultWeight:0,description:\"NodeType for a GitHub bot account\"});const nodeTypes=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()([repoNodeType,issueNodeType,pullNodeType,reviewNodeType,commentNodeType,commitNodeType,userNodeType,botNodeType]);const authorsEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"authors\",backwardName:\"is authored by\",defaultWeight:{forwards:1/2,backwards:1},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].authors,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"    Connects a GitHub account to a post that they authored.\\n\\n    Examples of posts include issues, pull requests, and comments.\\n  \"],[\"\\\\\\n    Connects a GitHub account to a post that they authored.\\n\\n    Examples of posts include issues, pull requests, and comments.\\n  \"])))});const hasParentEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"has parent\",backwardName:\"has child\",defaultWeight:{forwards:1,backwards:1/4},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].hasParent,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"    Connects a GitHub entity to its child entities.\\n\\n    For example, a Repository has Issues and Pull Requests as children, and a\\n    Pull Request has comments and reviews as children.\\n  \"],[\"\\\\\\n    Connects a GitHub entity to its child entities.\\n\\n    For example, a Repository has Issues and Pull Requests as children, and a\\n    Pull Request has comments and reviews as children.\\n  \"])))});const mergedAsEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"merges\",backwardName:\"is merged by\",defaultWeight:{forwards:1/2,backwards:1},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].mergedAs,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject3||(_templateObject3=_taggedTemplateLiteral([\"    Connects a GitHub pull request to the Git commit that it merges.\\n  \"],[\"\\\\\\n    Connects a GitHub pull request to the Git commit that it merges.\\n  \"])))});const referencesEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"references\",backwardName:\"is referenced by\",defaultWeight:{forwards:1,backwards:0},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].references,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject4||(_templateObject4=_taggedTemplateLiteral([\"    Connects a GitHub post to an entity that it references.\\n\\n    For example, if you write a GitHub issue comment that says \\\"thanks\\n    @username for pull #1337\\\", it will create references edges to both the user\\n    @username, and to pull #1337 in the same repository.\\n  \"],[\"\\\\\\n    Connects a GitHub post to an entity that it references.\\n\\n    For example, if you write a GitHub issue comment that says \\\"thanks\\n    @username for pull #1337\\\", it will create references edges to both the user\\n    @username, and to pull #1337 in the same repository.\\n  \"])))});const reactsHeartEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"reacted  to\",backwardName:\"got  from\",defaultWeight:{forwards:2,backwards:0},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].reactsHeart,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject5||(_templateObject5=_taggedTemplateLiteral([\"    Connects users to posts to which they gave a \\u2764\\uFE0F reaction.\\n  \"],[\"\\\\\\n    Connects users to posts to which they gave a \\u2764\\uFE0F reaction.\\n  \"])))});const reactsThumbsUpEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"reacted  to\",backwardName:\"got  from\",defaultWeight:{forwards:1,backwards:0},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].reactsThumbsUp,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject6||(_templateObject6=_taggedTemplateLiteral([\"    Connects users to posts to which they gave a \\uD83D\\uDC4D reaction.\\n  \"],[\"\\\\\\n    Connects users to posts to which they gave a \\uD83D\\uDC4D reaction.\\n  \"])))});const reactsHoorayEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"reacted  to\",backwardName:\"got  from\",defaultWeight:{forwards:4,backwards:0},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].reactsHooray,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject7||(_templateObject7=_taggedTemplateLiteral([\"    Connects users to posts to which they gave a \\uD83C\\uDF89 reaction.\\n  \"],[\"\\\\\\n    Connects users to posts to which they gave a \\uD83C\\uDF89 reaction.\\n  \"])))});const reactsRocketEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"reacted  to\",backwardName:\"got  from\",defaultWeight:{forwards:1,backwards:0},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].reactsRocket,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject8||(_templateObject8=_taggedTemplateLiteral([\"    Connects users to posts to which they gave a \\uD83D\\uDE80 reaction.\\n  \"],[\"\\\\\\n    Connects users to posts to which they gave a \\uD83D\\uDE80 reaction.\\n  \"])))});const correspondsToCommitEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"corresponds to Git commit\",backwardName:\"merged on GitHub as\",defaultWeight:{forwards:1,backwards:1},prefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].correspondsToCommit,description:Object(_util_dedent__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_templateObject9||(_templateObject9=_taggedTemplateLiteral([\"    Connects a commit on GitHub to the corresponding raw Git commit.\\n  \"],[\"\\\\\\n    Connects a commit on GitHub to the corresponding raw Git commit.\\n  \"])))});const edgeTypes=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()([authorsEdgeType,hasParentEdgeType,mergedAsEdgeType,referencesEdgeType,reactsThumbsUpEdgeType,reactsHeartEdgeType,reactsHoorayEdgeType,reactsRocketEdgeType,correspondsToCommitEdgeType]);const declaration=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"GitHub\",nodePrefix:_nodes__WEBPACK_IMPORTED_MODULE_1__[\"Prefix\"].base,edgePrefix:_edges__WEBPACK_IMPORTED_MODULE_2__[\"Prefix\"].base,nodeTypes:nodeTypes,edgeTypes:edgeTypes,userTypes:[userNodeType]});\n\n//# sourceURL=webpack:///./src/plugins/github/declaration.js?");

/***/ }),

/***/ "./src/plugins/github/edges.js":
/*!*************************************!*\
  !*** ./src/plugins/github/edges.js ***!
  \*************************************/
/*! exports provided: AUTHORS_TYPE, MERGED_AS_TYPE, HAS_PARENT_TYPE, REFERENCES_TYPE, REACTS_TYPE, CORRESPONDS_TO_COMMIT_TYPE, Prefix, createEdge, fromRaw, toRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AUTHORS_TYPE\", function() { return AUTHORS_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MERGED_AS_TYPE\", function() { return MERGED_AS_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HAS_PARENT_TYPE\", function() { return HAS_PARENT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REFERENCES_TYPE\", function() { return REFERENCES_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REACTS_TYPE\", function() { return REACTS_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CORRESPONDS_TO_COMMIT_TYPE\", function() { return CORRESPONDS_TO_COMMIT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Prefix\", function() { return Prefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createEdge\", function() { return createEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRaw\", function() { return fromRaw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRaw\", function() { return toRaw; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodes */ \"./src/plugins/github/nodes.js\");\n/* harmony import */ var _git_nodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../git/nodes */ \"./src/plugins/git/nodes.js\");\n/* harmony import */ var _graphqlTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./graphqlTypes */ \"./src/plugins/github/graphqlTypes.js\");\nconst AUTHORS_TYPE=\"AUTHORS\";const MERGED_AS_TYPE=\"MERGED_AS\";const HAS_PARENT_TYPE=\"HAS_PARENT\";const REFERENCES_TYPE=\"REFERENCES\";const REACTS_TYPE=\"REACTS\";// GitHub tracks its own notion of a commit, which has a particular\n// database id, is scoped to a particular repository, and has a canonical url\n// on GitHub. The CORRESPONDS_TO_COMMIT_TYPE edges connect the GitHub commits\n// to the corresponding Git commit.\nconst CORRESPONDS_TO_COMMIT_TYPE=\"CORRESPONDS_TO_COMMIT_TYPE\";const GITHUB_PREFIX=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].fromParts([\"sourcecred\",\"github\"]);function githubEdgeAddress(){for(var _len=arguments.length,parts=new Array(_len),_key=0;_key<_len;_key++){parts[_key]=arguments[_key];}return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(GITHUB_PREFIX,...parts);}const Prefix=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({base:GITHUB_PREFIX,authors:githubEdgeAddress(AUTHORS_TYPE),mergedAs:githubEdgeAddress(MERGED_AS_TYPE),references:githubEdgeAddress(REFERENCES_TYPE),hasParent:githubEdgeAddress(HAS_PARENT_TYPE),reacts:githubEdgeAddress(REACTS_TYPE),reactsThumbsUp:githubEdgeAddress(REACTS_TYPE,_graphqlTypes__WEBPACK_IMPORTED_MODULE_4__[\"ReactionContent$Values\"].THUMBS_UP),reactsHeart:githubEdgeAddress(REACTS_TYPE,_graphqlTypes__WEBPACK_IMPORTED_MODULE_4__[\"ReactionContent$Values\"].HEART),reactsHooray:githubEdgeAddress(REACTS_TYPE,_graphqlTypes__WEBPACK_IMPORTED_MODULE_4__[\"ReactionContent$Values\"].HOORAY),reactsRocket:githubEdgeAddress(REACTS_TYPE,_graphqlTypes__WEBPACK_IMPORTED_MODULE_4__[\"ReactionContent$Values\"].ROCKET),correspondsToCommit:githubEdgeAddress(CORRESPONDS_TO_COMMIT_TYPE)});const createEdge=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({authors:(author,content,timestampMs)=>({address:toRaw({type:AUTHORS_TYPE,author,content}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](author),dst:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](content),timestampMs}),mergedAs:(pull,commit,timestampMs)=>({address:toRaw({type:MERGED_AS_TYPE,pull}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](pull),dst:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](commit),timestampMs}),correspondsToCommit:(githubCommit,gitCommit,timestampMs)=>({address:toRaw({type:CORRESPONDS_TO_COMMIT_TYPE,githubCommit}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](githubCommit),dst:_git_nodes__WEBPACK_IMPORTED_MODULE_3__[\"toRaw\"](gitCommit),timestampMs}),hasParent:(child,parent,timestampMs)=>({address:toRaw({type:HAS_PARENT_TYPE,child}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](child),dst:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](parent),timestampMs}),references:(referrer,referent,timestampMs)=>({address:toRaw({type:REFERENCES_TYPE,referrer,referent}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](referrer),dst:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](referent),timestampMs}),reacts:(reactionType,user,reactable,timestampMs)=>({address:toRaw({type:REACTS_TYPE,user,reactionType,reactable}),src:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](user),dst:_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](reactable),timestampMs})});function lengthEncode(x){const parts=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(x);return[String(parts.length),...parts];}function lengthDecode(x,fail){if(x.length===0){// Not length-encoded.\nthrow fail();}const[lengthString,...allParts]=x;const length=parseInt(lengthString,10);if(isNaN(length)){throw fail();}if(length>allParts.length){// Not enough elements.\nthrow fail();}return{parts:allParts.slice(0,length),rest:allParts.slice(length)};}function multiLengthDecode(x,fail){let remaining=x;const partses=[];while(remaining.length>0){const{parts,rest}=lengthDecode(remaining,fail);partses.push(parts);remaining=rest;}return partses;}function fromRaw(x){function fail(){return new Error(\"Bad address: \".concat(_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].toString(x)));}if(!_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].hasPrefix(x,GITHUB_PREFIX)){throw fail();}const[_unused_sc,_unused_gh,kind,...rest]=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].toParts(x);switch(kind){case AUTHORS_TYPE:{const parts=multiLengthDecode(rest,fail);if(parts.length!==2){throw fail();}const[authorParts,contentParts]=parts;const author=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(authorParts));const content=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(contentParts));return{type:AUTHORS_TYPE,author,content};}case MERGED_AS_TYPE:{const parts=multiLengthDecode(rest,fail);if(parts.length!==1){throw fail();}const[pullParts]=parts;const pull=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(pullParts));return{type:MERGED_AS_TYPE,pull};}case HAS_PARENT_TYPE:{const parts=multiLengthDecode(rest,fail);if(parts.length!==1){throw fail();}const[childParts]=parts;const child=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(childParts));return{type:HAS_PARENT_TYPE,child};}case REFERENCES_TYPE:{const parts=multiLengthDecode(rest,fail);if(parts.length!==2){throw fail();}const[referrerParts,referentParts]=parts;const referrer=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(referrerParts));const referent=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(referentParts));return{type:REFERENCES_TYPE,referrer,referent};}case REACTS_TYPE:{const[rawReactionType,...rest2]=rest;const reactionType=_graphqlTypes__WEBPACK_IMPORTED_MODULE_4__[\"ReactionContent$Values\"][rawReactionType];if(reactionType==null){throw fail();}const parts=multiLengthDecode(rest2,fail);if(parts.length!==2){throw fail();}const[userParts,reactableParts]=parts;const user=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(userParts));const reactable=_nodes__WEBPACK_IMPORTED_MODULE_2__[\"fromRaw\"](_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts(reactableParts));return{type:REACTS_TYPE,reactionType,user,reactable};}default:throw fail();}}function toRaw(x){switch(x.type){case AUTHORS_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.authors,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.author)),...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.content)));case MERGED_AS_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.mergedAs,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.pull)));case HAS_PARENT_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.hasParent,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.child)));case REFERENCES_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.references,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.referrer)),...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.referent)));case REACTS_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.reacts,x.reactionType,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.user)),...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.reactable)));case CORRESPONDS_TO_COMMIT_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(Prefix.correspondsToCommit,...lengthEncode(_nodes__WEBPACK_IMPORTED_MODULE_2__[\"toRaw\"](x.githubCommit)));default:throw new Error(x.type);}}\n\n//# sourceURL=webpack:///./src/plugins/github/edges.js?");

/***/ }),

/***/ "./src/plugins/github/fetchGithubRepo.js":
/*!***********************************************!*\
  !*** ./src/plugins/github/fetchGithubRepo.js ***!
  \***********************************************/
/*! exports provided: fetchGithubRepoFromCache, default, _guessTypename, _resolveRefreshTime, postQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetchGithubRepoFromCache\", function() { return fetchGithubRepoFromCache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return fetchGithubRepo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_guessTypename\", function() { return _guessTypename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_resolveRefreshTime\", function() { return _resolveRefreshTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postQuery\", function() { return postQuery; });\n/* harmony import */ var better_sqlite3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! better-sqlite3 */ \"better-sqlite3\");\n/* harmony import */ var better_sqlite3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(better_sqlite3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! isomorphic-fetch */ \"isomorphic-fetch\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(isomorphic_fetch__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _repoId__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./repoId */ \"./src/plugins/github/repoId.js\");\n/* harmony import */ var _graphql_mirror__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../graphql/mirror */ \"./src/graphql/mirror.js\");\n/* harmony import */ var _graphql_queries__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../graphql/queries */ \"./src/graphql/queries.js\");\n/* harmony import */ var _graphql_schema__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../graphql/schema */ \"./src/graphql/schema.js\");\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./schema */ \"./src/plugins/github/schema.js\");\n/* harmony import */ var _cacheId__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cacheId */ \"./src/plugins/github/cacheId.js\");\n/* harmony import */ var _util_retry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/retry */ \"./src/util/retry.js\");\n/*\n * API to scrape data from a GitHub repo using the GitHub API. See the\n * docstring of the default export for more details.\n *//**\n * Retrieve previously scraped data for a GitHub repo from cache.\n *\n * Note: the GithubToken requirement is planned to be removed.\n * See https://github.com/sourcecred/sourcecred/issues/1580\n *\n * @param {RepoId} repoId\n *    the GitHub repository to retrieve from cache\n * @param {GithubToken} token\n *    authentication token to be used for the GitHub API; generate a\n *    token at: https://github.com/settings/tokens\n * @return {Promise<Repository>}\n *    a promise that resolves to a JSON object containing the data\n *    scraped from the repository, with data format to be specified\n *    later\n */async function fetchGithubRepoFromCache(repoId,_ref){let{token,cache}=_ref;// TODO: remove the need for a GithubToken to resolve the ID.\n// See https://github.com/sourcecred/sourcecred/issues/1580\nconst postQueryWithToken=payload=>postQuery(payload,token);const resolvedId=await resolveRepositoryGraphqlId(postQueryWithToken,repoId);const db=await cache.database(Object(_cacheId__WEBPACK_IMPORTED_MODULE_7__[\"cacheIdForRepoId\"])(repoId));const mirror=new _graphql_mirror__WEBPACK_IMPORTED_MODULE_3__[\"Mirror\"](db,Object(_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(),{guessTypename:_guessTypename});return mirror.extract(resolvedId);}/**\n * Scrape data from a GitHub repo using the GitHub API.\n *\n * @param {RepoId} repoId\n *    the GitHub repository to be scraped\n * @param {GithubToken} token\n *    authentication token to be used for the GitHub API; generate a\n *    token at: https://github.com/settings/tokens\n * @return {Promise<object>}\n *    a promise that resolves to a JSON object containing the data\n *    scraped from the repository, with data format to be specified\n *    later\n */async function fetchGithubRepo(repoId,_ref2){let{token,cache}=_ref2;const postQueryWithToken=payload=>postQuery(payload,token);const resolvedId=await resolveRepositoryGraphqlId(postQueryWithToken,repoId);// Key the cache file against the RepoId, but make sure that the\n// name is valid and uniquely identifying even on case-insensitive\n// filesystems (HFS, HFS+, APFS, NTFS) or filesystems preventing\n// equals signs in file names.\nconst db=await cache.database(Object(_cacheId__WEBPACK_IMPORTED_MODULE_7__[\"cacheIdForRepoId\"])(repoId));const mirror=new _graphql_mirror__WEBPACK_IMPORTED_MODULE_3__[\"Mirror\"](db,Object(_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(),{guessTypename:_guessTypename});mirror.registerObject({typename:\"Repository\",id:resolvedId});// These are arbitrary tuning parameters.\n// TODO(#638): Design a configuration system for plugins.\nconst ttlSeconds=60*60*12;const nodesLimit=100;const connectionLimit=100;await mirror.update(postQueryWithToken,{since:new Date(Date.now()-ttlSeconds*1000),now:()=>new Date(),// These properties are arbitrary tuning parameters.\nnodesLimit,connectionLimit,// These values are the maxima allowed by GitHub.\nnodesOfTypeLimit:100,connectionPageSize:100});return mirror.extract(resolvedId);}// GitHub object IDs are urlsafe-base64-encoded strings that decode to\n// ASCII strings of the form \"123:Typename4567[...]\", where the \"123\"\n// numbers are a function only of the typename and the \"4567\" numbers\n// are the object's database ID, and the \"[...]\" is either empty or a\n// further section like \":commithash\" for commits.\n//\n// See tests for `_guessTypename` for some example object IDs.\nconst GITHUB_ID_TYPENAME_PATTERN=/^[0-9]*:([a-z0-9_-]*[a-z_-])[0-9]+(?:[^a-z0-9_-].*)?$/i;function _guessTypename(objectId){const decodedId=Buffer.from(objectId,\"base64\").toString(\"utf-8\");const match=decodedId.match(GITHUB_ID_TYPENAME_PATTERN);return match?match[1]:null;}const GITHUB_GRAPHQL_SERVER=\"https://api.github.com/graphql\";// Fetch against the GitHub API with the provided options, returning a\n// promise that either resolves to the GraphQL result data or rejects\n// to a `GithubResponseError`.\nfunction tryGithubFetch(postBody,token){const fetchOptions={method:\"POST\",body:postBody,headers:{Authorization:\"bearer \".concat(token)}};return isomorphic_fetch__WEBPACK_IMPORTED_MODULE_1___default()(GITHUB_GRAPHQL_SERVER,fetchOptions).then(x=>x.json().then(x=>{if(x.errors){if(x.errors.length===1&&x.errors[0].message.includes(\"it could be a GitHub bug\")){return Promise.reject({type:\"GITHUB_INTERNAL_EXECUTION_ERROR\",error:x});}else if(x.errors.length===1&&x.errors[0].type===\"RATE_LIMITED\"){return Promise.reject({type:\"RATE_LIMIT_EXCEEDED\",error:x});}else{return Promise.reject({type:\"GRAPHQL_ERROR\",error:x});}}if(x.data===undefined){if(x.message&&x.message.includes(\"Bad credentials\")){return Promise.reject({type:\"BAD_CREDENTIALS\",error:x});}else{// See https://github.com/sourcecred/sourcecred/issues/350\nreturn Promise.reject({type:\"NO_DATA\",error:x});}}return Promise.resolve(x.data);}),e=>Promise.reject({type:\"FETCH_ERROR\",error:e}));}async function errorDisposition(e,token){if(e.type===\"FETCH_ERROR\"||e.type===\"GRAPHQL_ERROR\"||e.type===\"BAD_CREDENTIALS\"){return{type:\"FATAL\",err:e};}if(e.type===\"GITHUB_INTERNAL_EXECUTION_ERROR\"||e.type===\"NO_DATA\"){return{type:\"RETRY\",err:e};}if(e.type===\"RATE_LIMIT_EXCEEDED\"){try{const nominalRefreshTime=await quotaRefreshAt(token);const refreshTime=_resolveRefreshTime(new Date(),nominalRefreshTime);console.warn(\"GitHub rate limit exceeded; waiting for refresh at \"+refreshTime.toISOString());return{type:\"WAIT\",until:refreshTime,err:e};}catch(refreshError){// Fall back to waiting in 15-minute increments.\nconsole.warn(\"GitHub rate limit exceeded; waiting 15 minutes\");const delayMs=15*60*1000;return{type:\"WAIT\",until:new Date(Date.now()+delayMs),err:e};}}throw new Error(e.type);}/**\n * Determine the instant at which our GitHub quota will refresh.\n *\n * The returned promise may reject with a `GithubResponseError` or\n * string error message.\n */async function quotaRefreshAt(token){const b=_graphql_queries__WEBPACK_IMPORTED_MODULE_4__[\"build\"];const query=b.query(\"RateLimitReset\",[],[b.field(\"rateLimit\",{},[b.field(\"resetAt\")])]);const postBody=JSON.stringify({query:_graphql_queries__WEBPACK_IMPORTED_MODULE_4__[\"stringify\"].body([query],Object(_graphql_queries__WEBPACK_IMPORTED_MODULE_4__[\"inlineLayout\"])()),variables:{}});const data=await tryGithubFetch(postBody,token);const dateString=data.rateLimit.resetAt;const result=new Date(dateString);if(isNaN(result)){throw\"got NaN quota reset time: \"+JSON.stringify(data);}return result;}/**\n * Given a `resetAt` date response from GitHub, determine the actual\n * date until which we want to wait. We clamp to a reasonable range and\n * apply some padding.\n */function _resolveRefreshTime(now,nominalRefreshTime){let delayMs=+nominalRefreshTime-+now;const[minDelayMs,maxDelayMs]=[0,60*60*1000];if(delayMs<minDelayMs||delayMs>maxDelayMs){const newDelayMs=Math.max(minDelayMs,Math.min(delayMs,maxDelayMs));console.warn(\"clamping refresh delay from \".concat(delayMs,\" ms to \").concat(newDelayMs,\" ms\"));delayMs=newDelayMs;}delayMs+=60*1000;// add 1 minute for padding around clock skew\nreturn new Date(+now+delayMs);}async function retryGithubFetch(postBody,token){const policy={maxRetries:5,jitterRatio:1.2,// We wait in 15-minute intervals, and quotas reset every hour, so\n// we shouldn't give up before waiting 4 times.\nmaxWaits:4};const retryResult=await Object(_util_retry__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(async()=>{try{return{type:\"DONE\",value:await tryGithubFetch(postBody,token)};}catch(errAny){const err=errAny;return await errorDisposition(err,token);}},policy);switch(retryResult.type){case\"DONE\":return retryResult.value;case\"FAILED\":throw retryResult.err;default:throw new Error(retryResult.type);}}async function postQuery(_ref3,token){let{body,variables}=_ref3;const postBody=JSON.stringify({query:_graphql_queries__WEBPACK_IMPORTED_MODULE_4__[\"stringify\"].body(body,Object(_graphql_queries__WEBPACK_IMPORTED_MODULE_4__[\"inlineLayout\"])()),variables:variables});return retryGithubFetch(postBody,token).catch(error=>{switch(error.type){case\"GITHUB_INTERNAL_EXECUTION_ERROR\":case\"NO_DATA\":console.error(\"GitHub query failed! We're tracking these issues at \"+\"https://github.com/sourcecred/sourcecred/issues/350.\\n\"+\"If the error is a timeout or abuse rate limit, you can \"+\"try loading a smaller repo, or trying again in a few minutes.\\n\"+\"The actual failed response can be found below:\\n\"+\"=================================================\");console.error(error.error);break;case\"GRAPHQL_ERROR\":error.error.errors.forEach(error=>{if(error.type===\"NOT_FOUND\"){console.error(\"Unable to find the specified repository. Please check for typos \"+\"in the repository owner and name and confirm that you are using the correct token in \"+\"$SOURCECRED_GITHUB_TOKEN\");}else{console.error(\"Unexpected GraphQL error: \"+JSON.stringify({postBody:postBody,error:error}));}});break;case\"RATE_LIMIT_EXCEEDED\":console.error(\"You've exceeded your hourly GitHub rate limit.\\n\"+\"You'll need to wait until it resets.\");break;case\"FETCH_ERROR\":// Network error; no need for additional commentary.\nbreak;case\"BAD_CREDENTIALS\":console.error(\"An invalid token was supplied ($SOURCECRED_GITHUB_TOKEN). This is mostly likely caused by supplying a revoked token.\");break;default:console.error(\"Unexpected GitHub Error: \"+JSON.stringify({postBody:postBody,error:error}));}return Promise.reject(error);});}async function resolveRepositoryGraphqlId(postQuery,repoId){const b=_graphql_queries__WEBPACK_IMPORTED_MODULE_4__[\"build\"];const payload={body:[b.query(\"ResolveRepositoryId\",[b.param(\"owner\",\"String!\"),b.param(\"name\",\"String!\")],[b.field(\"repository\",{owner:b.variable(\"owner\"),name:b.variable(\"name\")},[b.field(\"id\")])])],variables:{owner:repoId.owner,name:repoId.name}};const data=await postQuery(payload);if(data.repository==null){throw new Error(\"No such repository: \".concat(Object(_repoId__WEBPACK_IMPORTED_MODULE_2__[\"repoIdToString\"])(repoId),\" \")+\"(response data: \".concat(JSON.stringify(data),\")\"));}return data.repository.id;}\n\n//# sourceURL=webpack:///./src/plugins/github/fetchGithubRepo.js?");

/***/ }),

/***/ "./src/plugins/github/graphqlTypes.js":
/*!********************************************!*\
  !*** ./src/plugins/github/graphqlTypes.js ***!
  \********************************************/
/*! exports provided: PullRequestReviewState$Values, ReactionContent$Values */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PullRequestReviewState$Values\", function() { return PullRequestReviewState$Values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReactionContent$Values\", function() { return ReactionContent$Values; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n// Autogenerated file. Do not edit.\nconst PullRequestReviewState$Values=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({\"APPROVED\":\"APPROVED\",\"CHANGES_REQUESTED\":\"CHANGES_REQUESTED\",\"COMMENTED\":\"COMMENTED\",\"DISMISSED\":\"DISMISSED\",\"PENDING\":\"PENDING\"});const ReactionContent$Values=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({\"CONFUSED\":\"CONFUSED\",\"EYES\":\"EYES\",\"HEART\":\"HEART\",\"HOORAY\":\"HOORAY\",\"LAUGH\":\"LAUGH\",\"ROCKET\":\"ROCKET\",\"THUMBS_DOWN\":\"THUMBS_DOWN\",\"THUMBS_UP\":\"THUMBS_UP\"});\n\n//# sourceURL=webpack:///./src/plugins/github/graphqlTypes.js?");

/***/ }),

/***/ "./src/plugins/github/nodes.js":
/*!*************************************!*\
  !*** ./src/plugins/github/nodes.js ***!
  \*************************************/
/*! exports provided: _githubAddress, REPO_TYPE, ISSUE_TYPE, PULL_TYPE, REVIEW_TYPE, COMMENT_TYPE, COMMIT_TYPE, USERLIKE_TYPE, USER_SUBTYPE, BOT_SUBTYPE, Prefix, loginAddress, fromRaw, toRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_githubAddress\", function() { return _githubAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REPO_TYPE\", function() { return REPO_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ISSUE_TYPE\", function() { return ISSUE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PULL_TYPE\", function() { return PULL_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REVIEW_TYPE\", function() { return REVIEW_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMMENT_TYPE\", function() { return COMMENT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMMIT_TYPE\", function() { return COMMIT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"USERLIKE_TYPE\", function() { return USERLIKE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"USER_SUBTYPE\", function() { return USER_SUBTYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BOT_SUBTYPE\", function() { return BOT_SUBTYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Prefix\", function() { return Prefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loginAddress\", function() { return loginAddress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRaw\", function() { return fromRaw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRaw\", function() { return toRaw; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _bots__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bots */ \"./src/plugins/github/bots.js\");\nconst GITHUB_PREFIX=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts([\"sourcecred\",\"github\"]);function _githubAddress(){for(var _len=arguments.length,parts=new Array(_len),_key=0;_key<_len;_key++){parts[_key]=arguments[_key];}return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(GITHUB_PREFIX,...parts);}const REPO_TYPE=\"REPO\";const ISSUE_TYPE=\"ISSUE\";const PULL_TYPE=\"PULL\";const REVIEW_TYPE=\"REVIEW\";const COMMENT_TYPE=\"COMMENT\";const COMMIT_TYPE=\"COMMIT\";const USERLIKE_TYPE=\"USERLIKE\";const USER_SUBTYPE=\"USER\";const BOT_SUBTYPE=\"BOT\";const Prefix=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({base:GITHUB_PREFIX,repo:_githubAddress(REPO_TYPE),issue:_githubAddress(ISSUE_TYPE),pull:_githubAddress(PULL_TYPE),review:_githubAddress(REVIEW_TYPE),comment:_githubAddress(COMMENT_TYPE),commit:_githubAddress(COMMIT_TYPE),userlike:_githubAddress(USERLIKE_TYPE),user:_githubAddress(USERLIKE_TYPE,USER_SUBTYPE),bot:_githubAddress(USERLIKE_TYPE,BOT_SUBTYPE),reviewComment:_githubAddress(COMMENT_TYPE,REVIEW_TYPE),issueComment:_githubAddress(COMMENT_TYPE,ISSUE_TYPE),pullComment:_githubAddress(COMMENT_TYPE,PULL_TYPE)});/**\n * Return the address corresponding to a GitHub login.\n *\n * If the login is considered a bot, then a bot address is returned. Otherwise,\n * a regular user address is returned. The method does not attempt to find out\n * whether the address should actually be an organization address, as we don't\n * yet handle organization addresses.\n *\n * Note: The signature will need to be refactored when we make the list of bots\n * a configuration option rather than a hardcoded constant.\n */function loginAddress(username){const bots=Object(_bots__WEBPACK_IMPORTED_MODULE_2__[\"botSet\"])();if(bots.has(username)){return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.bot,username);}else{return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.user,username);}}// Verify that Commentable is a subtype of Parent\nconst _unused_static=_=>_;function fromRaw(x){function fail(){return new Error(\"Bad address: \".concat(_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toString(x)));}if(!_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].hasPrefix(x,GITHUB_PREFIX)){throw fail();}const[_unused_sc,_unused_gh,kind,...rest]=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toParts(x);switch(kind){case REPO_TYPE:{if(rest.length!==2){throw fail();}const[owner,name]=rest;return{type:REPO_TYPE,owner,name};}case ISSUE_TYPE:{if(rest.length!==3){throw fail();}const[owner,name,number]=rest;const repo={type:REPO_TYPE,owner,name};return{type:ISSUE_TYPE,repo,number};}case PULL_TYPE:{if(rest.length!==3){throw fail();}const[owner,name,number]=rest;const repo={type:REPO_TYPE,owner,name};return{type:PULL_TYPE,repo,number};}case REVIEW_TYPE:{if(rest.length!==4){throw fail();}const[owner,name,pullNumber,id]=rest;const repo={type:REPO_TYPE,owner,name};const pull={type:PULL_TYPE,repo,number:pullNumber};return{type:REVIEW_TYPE,pull,id};}case COMMENT_TYPE:{if(rest.length<1){throw fail();}const[subkind,...subrest]=rest;switch(subkind){case ISSUE_TYPE:{if(subrest.length!==4){throw fail();}const[owner,name,issueNumber,id]=subrest;const repo={type:REPO_TYPE,owner,name};const issue={type:ISSUE_TYPE,repo,number:issueNumber};return{type:COMMENT_TYPE,parent:issue,id};}case PULL_TYPE:{if(subrest.length!==4){throw fail();}const[owner,name,pullNumber,id]=subrest;const repo={type:REPO_TYPE,owner,name};const pull={type:PULL_TYPE,repo,number:pullNumber};return{type:COMMENT_TYPE,parent:pull,id};}case REVIEW_TYPE:{if(subrest.length!==5){throw fail();}const[owner,name,pullNumber,reviewFragment,id]=subrest;const repo={type:REPO_TYPE,owner,name};const pull={type:PULL_TYPE,repo,number:pullNumber};const review={type:REVIEW_TYPE,pull,id:reviewFragment};return{type:COMMENT_TYPE,parent:review,id};}default:throw fail();}}case COMMIT_TYPE:{if(rest.length!==1){throw fail();}const[id]=rest;return{type:COMMIT_TYPE,id};}case USERLIKE_TYPE:{if(rest.length!==2){throw fail();}const[subtype,login]=rest;if(subtype!==\"USER\"&&subtype!==\"BOT\"){throw fail();}return{type:USERLIKE_TYPE,subtype,login};}default:throw fail();}}function toRaw(x){switch(x.type){case REPO_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.repo,x.owner,x.name);case ISSUE_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.issue,x.repo.owner,x.repo.name,x.number);case PULL_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.pull,x.repo.owner,x.repo.name,x.number);case REVIEW_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.review,x.pull.repo.owner,x.pull.repo.name,x.pull.number,x.id);case COMMENT_TYPE:switch(x.parent.type){case ISSUE_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.issueComment,x.parent.repo.owner,x.parent.repo.name,x.parent.number,x.id);case PULL_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.pullComment,x.parent.repo.owner,x.parent.repo.name,x.parent.number,x.id);case REVIEW_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.reviewComment,x.parent.pull.repo.owner,x.parent.pull.repo.name,x.parent.pull.number,x.parent.id,x.id);default:throw new Error(\"Bad comment parent type: \".concat(x.parent.type));}case USERLIKE_TYPE:switch(x.subtype){case\"BOT\":return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.bot,x.login);case\"USER\":return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.user,x.login);default:throw new Error(x.subtype);}case COMMIT_TYPE:return _core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(Prefix.commit,x.id);default:throw new Error(\"Unexpected type \".concat(x.type));}}\n\n//# sourceURL=webpack:///./src/plugins/github/nodes.js?");

/***/ }),

/***/ "./src/plugins/github/parseMarkdown.js":
/*!*********************************************!*\
  !*** ./src/plugins/github/parseMarkdown.js ***!
  \*********************************************/
/*! exports provided: textBlocks, deformat, coalesceText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"textBlocks\", function() { return textBlocks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deformat\", function() { return deformat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"coalesceText\", function() { return coalesceText; });\n/* harmony import */ var commonmark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! commonmark */ \"commonmark\");\n/* harmony import */ var commonmark__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(commonmark__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var commonmark_lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! commonmark/lib/common */ \"commonmark/lib/common\");\n/* harmony import */ var commonmark_lib_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(commonmark_lib_common__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * Extract maximal contiguous blocks of text from a Markdown string, in\n * source-appearance order.\n *\n * For the purposes of this method, code (of both the inline and block\n * varieties) is not considered text, and will not be included in the\n * output at all. HTML contents are similarly excluded.\n *\n * Normal text, emphasized/strong text, link text, and image alt text\n * all count as text and will be included. A block of text is not\n * required to have the same formatting: e.g., the Markdown document\n * given by `hello *there* [you](https://example.com)` without the\n * backticks has one contiguous block of text: `\"hello there you\"`.\n *\n * Softbreaks count as normal text, and render as a single space.\n * Hardbreaks break a contiguous block of text.\n *\n * Block-level elements, such as paragraphs, lists, and block quotes,\n * break contiguous blocks of text.\n *\n * See test cases for examples.\n */function textBlocks(string){const ast=new commonmark__WEBPACK_IMPORTED_MODULE_0__[\"Parser\"]().parse(string);deformat(ast);coalesceText(ast);const walker=ast.walker();const results=[];for(let step;step=walker.next();){// $FlowIgnore[value-as-type]\nconst node=step.node;const type=node.type;if(type===\"text\"){results.push(node.literal);}}return results;}// Copied from:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/bd35c127a6fd869ab2844082ae41047668178b7f/types/commonmark/index.d.ts#L14-L15\n// $FlowIgnore[value-as-type]\nfunction deformat(ast){const walker=ast.walker();// We ignore the contents of HTML \"code\" elements and their subtrees.\n// This variable tracks how deep we are in such a tree. It is 0 if we\n// are not in such a tree, 1 if we are in a \"code\" element, 2 if we\n// are in an element inside a \"code\" element, etc.\nlet htmlDepth=0;const reOpenCodeTag=/^<code(?:$|[ >])/i;const reOpenTag=new RegExp(\"^(?:\".concat(commonmark_lib_common__WEBPACK_IMPORTED_MODULE_1__[\"OPENTAG\"],\")\"));const reCloseTag=new RegExp(\"^(?:\".concat(commonmark_lib_common__WEBPACK_IMPORTED_MODULE_1__[\"CLOSETAG\"],\")\"));for(let step;step=walker.next();){// $FlowIgnore[value-as-type]\nconst node=step.node;const type=node.type;if(htmlDepth>0){if(type===\"html_inline\"){if(reOpenTag.test(node.literal)){htmlDepth++;}else if(reCloseTag.test(node.literal)){htmlDepth--;}}// The AST walker gets into a broken state if you unlink a node\n// that has children before those children have been visited. We\n// only unlink when leaving a node, or when entering a node that\n// has no children.\nif(!step.entering||node.firstChild==null){node.unlink();continue;}}switch(type){case\"text\":break;case\"softbreak\":{const space=new commonmark__WEBPACK_IMPORTED_MODULE_0__[\"Node\"](\"text\",node.sourcepos);space.literal=\" \";node.insertBefore(space);node.unlink();break;}case\"linebreak\":break;case\"emph\":case\"strong\":case\"link\":case\"image\":if(!step.entering){// Splice out the node.\nwhile(node.firstChild){node.insertBefore(node.firstChild);}node.unlink();}break;case\"html_inline\":if(reOpenCodeTag.test(node.literal)){htmlDepth++;// should have been 0 previously\n}node.unlink();break;case\"code\":case\"document\":case\"paragraph\":case\"block_quote\":case\"item\":case\"list\":case\"heading\":case\"code_block\":case\"html_block\":case\"thematic_break\":case\"custom_inline\":case\"custom_block\":break;default:throw new Error(\"unexpected type: \"+type);}}}// $FlowIgnore[value-as-type]\nfunction coalesceText(ast){const walker=ast.walker();let acc=[];let firstTextNode=null;for(let step;step=walker.next();){// $FlowIgnore[value-as-type]\nconst node=step.node;const type=node.type;if(type===\"text\"){acc.push(node.literal);if(firstTextNode==null){firstTextNode=node;}else{node.unlink();}}else if(firstTextNode!=null){firstTextNode.literal=acc.join(\"\");acc=[];firstTextNode=null;}}}\n\n//# sourceURL=webpack:///./src/plugins/github/parseMarkdown.js?");

/***/ }),

/***/ "./src/plugins/github/parseReferences.js":
/*!***********************************************!*\
  !*** ./src/plugins/github/parseReferences.js ***!
  \***********************************************/
/*! exports provided: parseReferences */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseReferences\", function() { return parseReferences; });\n/* harmony import */ var _parseMarkdown__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseMarkdown */ \"./src/plugins/github/parseMarkdown.js\");\n/* harmony import */ var _repoId__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./repoId */ \"./src/plugins/github/repoId.js\");\n/**\n * Parse GitHub references from a Markdown document, such as an issue or\n * comment body. This will include references that span multiple lines\n * (across softbreaks), and exclude references that occur within code\n * blocks.\n */function parseReferences(body){// Note to maintainer: If it becomes necessary to encode references in a\n// richer format, consider implementing the type signature described in\n// https://github.com/sourcecred/sourcecred/pull/130#pullrequestreview-113849998\nconst blocks=Object(_parseMarkdown__WEBPACK_IMPORTED_MODULE_0__[\"textBlocks\"])(body);return[].concat.apply([],blocks.map(parseReferencesFromRawString));}function parseReferencesFromRawString(textBlock){return[...findNumericReferences(textBlock),...findRepoNumericReferences(textBlock),...findGithubUrlReferences(textBlock),...findUsernameReferences(textBlock),...findCommitReferences(textBlock)];}function findRepoNumericReferences(textBlock){const re=new RegExp(\"(?:\\\\W|^)((?:\".concat(_repoId__WEBPACK_IMPORTED_MODULE_1__[\"githubOwnerPattern\"],\")/(?:\").concat(_repoId__WEBPACK_IMPORTED_MODULE_1__[\"githubRepoPattern\"],\")#\\\\d+)(?=\\\\W|$)\"),\"gm\");return findAllMatches(re,textBlock).map(x=>({refType:\"BASIC\",ref:x[1]}));}function findNumericReferences(textBlock){return findAllMatches(/(?:\\W|^)(#\\d+)(?=\\W|$)/gm,textBlock).map(x=>({refType:\"BASIC\",ref:x[1]}));}function findUsernameReferences(textBlock){const pairedWithPattern=\"(?:\\\\W|^)(?:P|p)aired(?:-| )(?:w|W)ith:? \"+\"(@(?:\".concat(_repoId__WEBPACK_IMPORTED_MODULE_1__[\"githubOwnerPattern\"],\"))(?=\\\\W|$)\");const basicPattern=\"(?:\\\\W|^)(@(?:\".concat(_repoId__WEBPACK_IMPORTED_MODULE_1__[\"githubOwnerPattern\"],\"))(?=\\\\W|$)\");const pairedWithRefs=findAllMatches(new RegExp(pairedWithPattern,\"gm\"),textBlock).map(x=>({ref:x[1],refType:\"PAIRED_WITH\"}));const basicRefs=findAllMatches(new RegExp(basicPattern,\"gm\"),textBlock).map(x=>({ref:x[1],refType:\"BASIC\"}));for(const{ref}of pairedWithRefs){const basicRefIndexToRemove=basicRefs.findIndex(x=>x.ref===ref);if(basicRefIndexToRemove===-1){throw new Error(\"Couldn't find BASIC ref for paired with ref: \".concat(ref));}basicRefs.splice(basicRefIndexToRemove,1);}return[...pairedWithRefs,...basicRefs];}function findGithubUrlReferences(textBlock){const urlRegex=new RegExp(\"\"+/(?:\\W|^)/.source+\"(\"+/http(?:s)?:\\/\\/github.com\\//.source+\"(?:\".concat(_repoId__WEBPACK_IMPORTED_MODULE_1__[\"githubOwnerPattern\"],\")\")+\"(?:\"+/\\//.source+\"(?:\".concat(_repoId__WEBPACK_IMPORTED_MODULE_1__[\"githubRepoPattern\"],\")\")+/\\/(?:issues|pull)\\//.source+/(?:\\d+)/.source+/(?:#(?:issue|issuecomment|pullrequestreview|discussion_r)-?(?:\\d+))?/.source+\")?\"+\")\"+/(?=[^\\w/-]|$)/.source,\"gm\");return findAllMatches(urlRegex,textBlock).map(match=>({refType:\"BASIC\",ref:match[1]}));}function findCommitReferences(textBlock){const hashReferences=findAllMatches(/(?:\\W|^)([a-fA-F0-9]{40,})(?=\\W|$)/gm,textBlock).map(x=>({refType:\"BASIC\",ref:x[1].toLowerCase()}));const commitUrlRegex=new RegExp(\"\"+/(?:\\W|^)/.source+\"(\"+/https?:\\/\\/github.com\\//.source+\"(?:\".concat(_repoId__WEBPACK_IMPORTED_MODULE_1__[\"githubOwnerPattern\"],\")\")+/\\//.source+\"(?:\".concat(_repoId__WEBPACK_IMPORTED_MODULE_1__[\"githubRepoPattern\"],\")\")+/\\/commit\\/([a-fA-F0-9]{40,})/.source+\")\"+/(?=[^\\w/]|$)/.source,\"gm\");const urlsAndHashes=findAllMatches(commitUrlRegex,textBlock).map(x=>({url:x[1].toLowerCase(),hash:x[2].toLowerCase()}));// Every urlReference will also generate a hash reference (because the\n// url contains the hash).  So we manually remove the duplicates.\nfor(const{url,hash}of urlsAndHashes){const idxToRemove=hashReferences.findIndex(_ref=>{let{ref}=_ref;return ref===hash;});if(idxToRemove===-1){throw new Error(\"No matching hash for url reference: \".concat(url));}hashReferences.splice(idxToRemove,1);}const urlReferences=urlsAndHashes.map(x=>({refType:\"BASIC\",ref:x.url}));return[...hashReferences,...urlReferences];}function findAllMatches(re,s){// modified from: https://stackoverflow.com/a/6323598\nlet m;const matches=[];do{m=re.exec(s);if(m){matches.push(m);}}while(m);return matches;}\n\n//# sourceURL=webpack:///./src/plugins/github/parseReferences.js?");

/***/ }),

/***/ "./src/plugins/github/plugin.js":
/*!**************************************!*\
  !*** ./src/plugins/github/plugin.js ***!
  \**************************************/
/*! exports provided: GithubPlugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GithubPlugin\", function() { return GithubPlugin; });\n/* harmony import */ var better_sqlite3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! better-sqlite3 */ \"better-sqlite3\");\n/* harmony import */ var better_sqlite3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(better_sqlite3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fetchGithubRepo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetchGithubRepo */ \"./src/plugins/github/fetchGithubRepo.js\");\n/* harmony import */ var _core_weightedGraph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/weightedGraph */ \"./src/core/weightedGraph.js\");\n/* harmony import */ var _core_weights__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/weights */ \"./src/core/weights.js\");\n/* harmony import */ var _relationalView__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./relationalView */ \"./src/plugins/github/relationalView.js\");\n/* harmony import */ var _createGraph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createGraph */ \"./src/plugins/github/createGraph.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/github/declaration.js\");\n/* harmony import */ var _referenceDetector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./referenceDetector */ \"./src/plugins/github/referenceDetector.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./config */ \"./src/plugins/github/config.js\");\n/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./token */ \"./src/plugins/github/token.js\");\n/* harmony import */ var _analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../analysis/pluginDeclaration */ \"./src/analysis/pluginDeclaration.js\");\n/* harmony import */ var _repoId__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./repoId */ \"./src/plugins/github/repoId.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var _createIdentities__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./createIdentities */ \"./src/plugins/github/createIdentities.js\");\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../core/storage/disk */ \"./src/core/storage/disk.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const TOKEN_ENV_VAR_NAME=\"SOURCECRED_GITHUB_TOKEN\";async function loadConfig(dirContext){const dirname=dirContext.configDirectory();const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_15__[\"DiskStorage\"](dirname);return Object(_util_storage__WEBPACK_IMPORTED_MODULE_13__[\"loadJson\"])(storage,\"config.json\",_config__WEBPACK_IMPORTED_MODULE_9__[\"parser\"]);}// Shim to interface with `fetchGithubRepo`; TODO: refactor that to just\n// take a directory.\nclass CacheProviderImpl{constructor(dirContext){_defineProperty(this,\"_dirContext\",void 0);this._dirContext=dirContext;}database(id){const path=Object(path__WEBPACK_IMPORTED_MODULE_1__[\"join\"])(this._dirContext.cacheDirectory(),\"\".concat(id,\".db\"));return Promise.resolve(new better_sqlite3__WEBPACK_IMPORTED_MODULE_0___default.a(path));}}function getTokenFromEnv(){const rawToken=process.env[TOKEN_ENV_VAR_NAME];if(rawToken==null){throw new Error(\"No GitHub token provided: set \".concat(TOKEN_ENV_VAR_NAME));}return Object(_token__WEBPACK_IMPORTED_MODULE_10__[\"validateToken\"])(rawToken);}class GithubPlugin{async declaration(){return _declaration__WEBPACK_IMPORTED_MODULE_7__[\"declaration\"];}async load(ctx,reporter){const cache=new CacheProviderImpl(ctx);const token=getTokenFromEnv();const config=await loadConfig(ctx);for(const repoId of config.repoIds){const repoString=Object(_repoId__WEBPACK_IMPORTED_MODULE_12__[\"repoIdToString\"])(repoId);const task=\"github: loading \".concat(repoString);reporter.start(task);await Object(_fetchGithubRepo__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(repoId,{token,cache});reporter.finish(task);}}async graph(ctx,rd){const _=rd;// TODO(#1808): not yet used\nconst cache=new CacheProviderImpl(ctx);const token=getTokenFromEnv();const config=await loadConfig(ctx);const repositories=[];for(const repoId of config.repoIds){repositories.push(await Object(_fetchGithubRepo__WEBPACK_IMPORTED_MODULE_2__[\"fetchGithubRepoFromCache\"])(repoId,{token,cache}));}const wg=Object(_core_weightedGraph__WEBPACK_IMPORTED_MODULE_3__[\"merge\"])(repositories.map(r=>{const rv=new _relationalView__WEBPACK_IMPORTED_MODULE_5__[\"RelationalView\"]();rv.addRepository(r);return Object(_createGraph__WEBPACK_IMPORTED_MODULE_6__[\"createGraph\"])(rv);}));const pluginDefaultWeights=Object(_analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_11__[\"weightsForDeclaration\"])(_declaration__WEBPACK_IMPORTED_MODULE_7__[\"declaration\"]);const weights=Object(_core_weights__WEBPACK_IMPORTED_MODULE_4__[\"merge\"])([wg.weights,pluginDefaultWeights]);return{graph:wg.graph,weights};}async referenceDetector(ctx){const cache=new CacheProviderImpl(ctx);const token=getTokenFromEnv();const config=await loadConfig(ctx);const rvs=[];for(const repoId of config.repoIds){const repo=await Object(_fetchGithubRepo__WEBPACK_IMPORTED_MODULE_2__[\"fetchGithubRepoFromCache\"])(repoId,{token,cache});const rv=new _relationalView__WEBPACK_IMPORTED_MODULE_5__[\"RelationalView\"]();rv.addRepository(repo);rvs.push(rv);}return Object(_referenceDetector__WEBPACK_IMPORTED_MODULE_8__[\"fromRelationalViews\"])(rvs);}async identities(ctx){const cache=new CacheProviderImpl(ctx);const token=getTokenFromEnv();const config=await loadConfig(ctx);let identities=[];for(const repoId of config.repoIds){const repo=await Object(_fetchGithubRepo__WEBPACK_IMPORTED_MODULE_2__[\"fetchGithubRepoFromCache\"])(repoId,{token,cache});const rv=new _relationalView__WEBPACK_IMPORTED_MODULE_5__[\"RelationalView\"]();rv.addRepository(repo);identities=[...identities,...Object(_createIdentities__WEBPACK_IMPORTED_MODULE_14__[\"createIdentities\"])(rv)];}return identities;}}\n\n//# sourceURL=webpack:///./src/plugins/github/plugin.js?");

/***/ }),

/***/ "./src/plugins/github/referenceDetector.js":
/*!*************************************************!*\
  !*** ./src/plugins/github/referenceDetector.js ***!
  \*************************************************/
/*! exports provided: fromRelationalViews, GithubReferenceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRelationalViews\", function() { return fromRelationalViews; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GithubReferenceDetector\", function() { return GithubReferenceDetector; });\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _core_references__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/references */ \"./src/core/references/index.js\");\n/* harmony import */ var _relationalView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./relationalView */ \"./src/plugins/github/relationalView.js\");\nvar _templateObject;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}/**\n * Builds a GithubReferenceDetector using multiple RelationalView.\n * As RelationalView should only be used for one repository at a time, you will\n * commonly want to compose several of them into one GithubReferenceDetector.\n *\n * Note: duplicates are normally expected. However for any URL, the corresponding\n * NodeAddressT should be the same, or we'll throw an error.\n */function fromRelationalViews(views){const map=new Map();for(const view of views){for(const[url,addr]of view.urlReferenceMap().entries()){const existing=map.get(url);if(existing&&existing!==addr){throw new Error(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"          An entry for \",\" already existed, but with a different NodeAddressT.\\n          This is probably a bug with SourceCred. Please report it on GitHub.\\n          Old: \",\"\\n          New: \",\"\\n        \"],[\"\\\\\\n          An entry for \",\" already existed, but with a different NodeAddressT.\\n          This is probably a bug with SourceCred. Please report it on GitHub.\\n          Old: \",\"\\n          New: \",\"\\n        \"])),url,_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toString(existing),_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].toString(addr)));}map.set(url,addr);}}return new GithubReferenceDetector(map);}const GithubReferenceDetector=_core_references__WEBPACK_IMPORTED_MODULE_2__[\"MappedReferenceDetector\"];\n\n//# sourceURL=webpack:///./src/plugins/github/referenceDetector.js?");

/***/ }),

/***/ "./src/plugins/github/relationalView.js":
/*!**********************************************!*\
  !*** ./src/plugins/github/relationalView.js ***!
  \**********************************************/
/*! exports provided: RelationalView, _Entity, Repo, Issue, Pull, Review, Comment, Commit, Userlike, match, expectAllNonNull */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RelationalView\", function() { return RelationalView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_Entity\", function() { return _Entity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Repo\", function() { return Repo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Issue\", function() { return Issue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pull\", function() { return Pull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Review\", function() { return Review; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Comment\", function() { return Comment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Commit\", function() { return Commit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Userlike\", function() { return Userlike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"match\", function() { return match; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"expectAllNonNull\", function() { return expectAllNonNull; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _util_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/compat */ \"./src/util/compat.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _parseReferences__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parseReferences */ \"./src/plugins/github/parseReferences.js\");\n/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nodes */ \"./src/plugins/github/nodes.js\");\n/* harmony import */ var _util_dedent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/dedent */ \"./src/util/dedent.js\");\n/* harmony import */ var _graphqlTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./graphqlTypes */ \"./src/plugins/github/graphqlTypes.js\");\n/* harmony import */ var _util_map__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/map */ \"./src/util/map.js\");\n/* harmony import */ var _util_null__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/null */ \"./src/util/null.js\");\n/* harmony import */ var _bots__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bots */ \"./src/plugins/github/bots.js\");\n/* harmony import */ var _urlIdParse__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./urlIdParse */ \"./src/plugins/github/urlIdParse.js\");\nvar _templateObject,_templateObject2;function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const COMPAT_INFO={type:\"sourcecred/github/relationalView\",version:\"0.3.0\"};class RelationalView{constructor(){_defineProperty(this,\"_repos\",void 0);_defineProperty(this,\"_issues\",void 0);_defineProperty(this,\"_pulls\",void 0);_defineProperty(this,\"_comments\",void 0);_defineProperty(this,\"_commits\",void 0);_defineProperty(this,\"_reviews\",void 0);_defineProperty(this,\"_userlikes\",void 0);_defineProperty(this,\"_mapReferences\",void 0);_defineProperty(this,\"_mapReferencedBy\",void 0);this._repos=new Map();this._issues=new Map();this._pulls=new Map();this._comments=new Map();this._commits=new Map();this._reviews=new Map();this._userlikes=new Map();this._mapReferences=new Map();this._mapReferencedBy=new Map();}addRepository(repository){// Warning: calling `addRepository` can put the RelationalView in an\n// inconsistent state. for example, if called with a repo with\n// issues [#1, #2, #3] and then with a repo with issues [#4, #5],\n// then calls to `repo.issues()` will only give back issues 4 and 5\n// (although issues 1, 2, and 3 will still be in the view).\nthis._addRepo(repository);this._addReferences();}/**\n   * Mutate the RelationalView, by replacing all of the post bodies with\n   * empty strings. Usage of this method is a convenient hack to save space,\n   * as we don't currently use the bodies after the _addReferences step.\n   * Also removes commit messages.\n   */compressByRemovingBody(){for(const[address,post]of this._issues.entries()){const compressedPost=_objectSpread(_objectSpread({},post),{},{body:\"\"});this._issues.set(address,compressedPost);}for(const[address,post]of this._pulls.entries()){const compressedPost=_objectSpread(_objectSpread({},post),{},{body:\"\"});this._pulls.set(address,compressedPost);}for(const[address,post]of this._comments.entries()){const compressedPost=_objectSpread(_objectSpread({},post),{},{body:\"\"});this._comments.set(address,compressedPost);}for(const[address,post]of this._reviews.entries()){const compressedPost=_objectSpread(_objectSpread({},post),{},{body:\"\"});this._reviews.set(address,compressedPost);}for(const[address,post]of this._commits.entries()){const compressedPost=_objectSpread(_objectSpread({},post),{},{message:\"\"});this._commits.set(address,compressedPost);}}*repos(){for(const entry of this._repos.values()){yield new Repo(this,entry);}}repo(address){const entry=this._repos.get(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address));return entry==null?entry:new Repo(this,entry);}*issues(){for(const entry of this._issues.values()){yield new Issue(this,entry);}}issue(address){const entry=this._issues.get(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address));return entry==null?entry:new Issue(this,entry);}*pulls(){for(const entry of this._pulls.values()){yield new Pull(this,entry);}}pull(address){const entry=this._pulls.get(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address));return entry==null?entry:new Pull(this,entry);}*comments(){for(const entry of this._comments.values()){yield new Comment(this,entry);}}comment(address){const entry=this._comments.get(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address));return entry==null?entry:new Comment(this,entry);}*commits(){for(const entry of this._commits.values()){yield new Commit(this,entry);}}commit(address){const entry=this._commits.get(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address));return entry==null?entry:new Commit(this,entry);}*reviews(){for(const entry of this._reviews.values()){yield new Review(this,entry);}}review(address){const entry=this._reviews.get(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address));return entry==null?entry:new Review(this,entry);}*userlikes(){for(const entry of this._userlikes.values()){yield new Userlike(this,entry);}}userlike(address){const entry=this._userlikes.get(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address));return entry==null?entry:new Userlike(this,entry);}entity(address){switch(address.type){case\"REPO\":return this.repo(address);case\"ISSUE\":return this.issue(address);case\"PULL\":return this.pull(address);case\"REVIEW\":return this.review(address);case\"COMMENT\":return this.comment(address);case\"USERLIKE\":return this.userlike(address);case\"COMMIT\":return this.commit(address);default:throw new Error(\"Unexpected address type: \".concat(address.type));}}*referentEntities(){yield*this.repos();yield*this.issues();yield*this.pulls();yield*this.reviews();yield*this.comments();yield*this.commits();yield*this.userlikes();}*textContentEntities(){yield*this.issues();yield*this.pulls();yield*this.reviews();yield*this.comments();yield*this.commits();}*parentEntities(){yield*this.repos();yield*this.issues();yield*this.pulls();yield*this.reviews();}*childEntities(){yield*this.issues();yield*this.pulls();yield*this.reviews();yield*this.comments();}*authoredEntities(){yield*this.issues();yield*this.pulls();yield*this.reviews();yield*this.comments();yield*this.commits();}*entities(){yield*this.repos();yield*this.issues();yield*this.pulls();yield*this.reviews();yield*this.comments();yield*this.commits();yield*this.userlikes();}*reactableEntities(){yield*this.issues();yield*this.pulls();yield*this.comments();}toJSON(){const rawJSON={repos:_util_map__WEBPACK_IMPORTED_MODULE_7__[\"toObject\"](this._repos),issues:_util_map__WEBPACK_IMPORTED_MODULE_7__[\"toObject\"](this._issues),pulls:_util_map__WEBPACK_IMPORTED_MODULE_7__[\"toObject\"](this._pulls),reviews:_util_map__WEBPACK_IMPORTED_MODULE_7__[\"toObject\"](this._reviews),comments:_util_map__WEBPACK_IMPORTED_MODULE_7__[\"toObject\"](this._comments),commits:_util_map__WEBPACK_IMPORTED_MODULE_7__[\"toObject\"](this._commits),userlikes:_util_map__WEBPACK_IMPORTED_MODULE_7__[\"toObject\"](this._userlikes),references:_util_map__WEBPACK_IMPORTED_MODULE_7__[\"toObject\"](this._mapReferences),referencedBy:_util_map__WEBPACK_IMPORTED_MODULE_7__[\"toObject\"](this._mapReferencedBy)};return Object(_util_compat__WEBPACK_IMPORTED_MODULE_1__[\"toCompat\"])(COMPAT_INFO,rawJSON);}static fromJSON(compatJson){const json=Object(_util_compat__WEBPACK_IMPORTED_MODULE_1__[\"fromCompat\"])(COMPAT_INFO,compatJson);const rv=new RelationalView();rv._repos=_util_map__WEBPACK_IMPORTED_MODULE_7__[\"fromObject\"](json.repos);rv._issues=_util_map__WEBPACK_IMPORTED_MODULE_7__[\"fromObject\"](json.issues);rv._pulls=_util_map__WEBPACK_IMPORTED_MODULE_7__[\"fromObject\"](json.pulls);rv._reviews=_util_map__WEBPACK_IMPORTED_MODULE_7__[\"fromObject\"](json.reviews);rv._comments=_util_map__WEBPACK_IMPORTED_MODULE_7__[\"fromObject\"](json.comments);rv._commits=_util_map__WEBPACK_IMPORTED_MODULE_7__[\"fromObject\"](json.commits);rv._userlikes=_util_map__WEBPACK_IMPORTED_MODULE_7__[\"fromObject\"](json.userlikes);rv._mapReferences=_util_map__WEBPACK_IMPORTED_MODULE_7__[\"fromObject\"](json.references);rv._mapReferencedBy=_util_map__WEBPACK_IMPORTED_MODULE_7__[\"fromObject\"](json.referencedBy);return rv;}_addRepo(json){const address={type:_nodes__WEBPACK_IMPORTED_MODULE_4__[\"REPO_TYPE\"],owner:_util_null__WEBPACK_IMPORTED_MODULE_8__[\"get\"](json.owner).login,name:json.name};const entry={address,url:json.url,issues:expectAllNonNull(json,\"issues\",json.issues).map(x=>this._addIssue(address,x)),pulls:expectAllNonNull(json,\"pullRequests\",json.pullRequests).map(x=>this._addPull(address,x)),timestampMs:+new Date(json.createdAt)};const raw=_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address);this._repos.set(raw,entry);this._addCommitHistory(json);}_addCommitHistory(json){if(json.defaultBranchRef!=null){const target=json.defaultBranchRef.target;if(target!=null&&target.__typename===\"Commit\"){this._addCommit(target);}else if(target!=null){throw new Error(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_templateObject||(_templateObject=_taggedTemplateLiteral([\"            Your repo doesn't have a commit as its defaultBranchRef's target.             Please file a bug reproducing this error.             https://github.com/sourcecred/sourcecred/issues          \"],[\"\\\\\\n            Your repo doesn't have a commit as its defaultBranchRef's target. \\\\\\n            Please file a bug reproducing this error. \\\\\\n            https://github.com/sourcecred/sourcecred/issues\\\\\\n          \"]))));}}}_addIssue(repo,json){const address={type:_nodes__WEBPACK_IMPORTED_MODULE_4__[\"ISSUE_TYPE\"],number:String(json.number),repo};const entry={address,url:json.url,comments:expectAllNonNull(json,\"comments\",json.comments).map(x=>this._addComment(address,x)),authors:this._addNullableAuthor(json.author),body:json.body,title:json.title,reactions:expectAllNonNull(json,\"reactions\",json.reactions).map(x=>this._addReaction(x)),timestampMs:+new Date(json.createdAt)};this._issues.set(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address),entry);return address;}_addCommit(json){const commitStack=[json];// reified recursion to avoid stack overflow\nlet originalAddress=null;while(true){const json=commitStack.pop();if(json==null){// End of stack.\nbreak;}const address={type:_nodes__WEBPACK_IMPORTED_MODULE_4__[\"COMMIT_TYPE\"],id:json.id};const rawAddress=_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address);if(originalAddress==null){originalAddress=address;}// This fast-return is critical, because a single commit may appear\n// many times in the repository.\n//\n// For example, a repository with 1000 commits, each of which was\n// created by merging a pull request, will include 1001 structural\n// references to the root commit (one via the HEAD ref, and one\n// along a parent-chain from each pull request), so the number of\n// occurrences of commits can easily be quadratic in the number of\n// actual commits.\n//\n// Furthermore, it can be exponential: consider merge commits like\n//\n//     HEAD\n//     / \\\n//    1A 1B\n//    | X |\n//    2A 2B\n//    | X |\n//    3A 3B\n//     \\ /\n//     root\n//\n// where each merge commit has two parents. The root commit is\n// reachable along about 2^(n/2) paths.\n//\n// This check ensures that we process each commit edge only once.\nif(this._commits.has(rawAddress)){continue;}const authors=json.author==null?[]:this._addNullableAuthor(json.author.user);const entry={address,url:json.url,authors,message:json.message,hash:json.oid,timestampMs:+new Date(json.authoredDate)};this._commits.set(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address),entry);for(const parent of json.parents){if(parent!=null){commitStack.push(parent);}}}// must have gone through at least one loop iteration\nreturn _util_null__WEBPACK_IMPORTED_MODULE_8__[\"get\"](originalAddress);}_addPull(repo,json){const address={type:_nodes__WEBPACK_IMPORTED_MODULE_4__[\"PULL_TYPE\"],number:String(json.number),repo};const mergedAs=json.mergeCommit==null?null:this._addCommit(json.mergeCommit);const entry={address,url:json.url,comments:expectAllNonNull(json,\"comments\",json.comments).map(x=>this._addComment(address,x)),reviews:expectAllNonNull(json,\"reviews\",json.reviews).map(x=>this._addReview(address,x)),authors:this._addNullableAuthor(json.author),body:json.body,title:json.title,mergedAs,additions:json.additions,deletions:json.deletions,reactions:expectAllNonNull(json,\"reactions\",json.reactions).map(x=>this._addReaction(x)),timestampMs:+new Date(json.createdAt)};this._pulls.set(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address),entry);return address;}_addReview(pull,json){const address={type:_nodes__WEBPACK_IMPORTED_MODULE_4__[\"REVIEW_TYPE\"],id:Object(_urlIdParse__WEBPACK_IMPORTED_MODULE_10__[\"reviewUrlToId\"])(json.url),pull};const entry={address,url:json.url,state:json.state,comments:expectAllNonNull(json,\"comments\",json.comments).map(x=>this._addComment(address,x)),body:json.body,authors:this._addNullableAuthor(json.author),timestampMs:+new Date(json.createdAt)};this._reviews.set(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address),entry);return address;}_addComment(parent,json){const id=function(){switch(parent.type){case _nodes__WEBPACK_IMPORTED_MODULE_4__[\"ISSUE_TYPE\"]:return Object(_urlIdParse__WEBPACK_IMPORTED_MODULE_10__[\"issueCommentUrlToId\"])(json.url);case _nodes__WEBPACK_IMPORTED_MODULE_4__[\"PULL_TYPE\"]:return Object(_urlIdParse__WEBPACK_IMPORTED_MODULE_10__[\"pullCommentUrlToId\"])(json.url);case _nodes__WEBPACK_IMPORTED_MODULE_4__[\"REVIEW_TYPE\"]:return Object(_urlIdParse__WEBPACK_IMPORTED_MODULE_10__[\"reviewCommentUrlToId\"])(json.url);default:throw new Error(\"Unexpected comment parent type: \".concat(parent.type));}}();const address={type:_nodes__WEBPACK_IMPORTED_MODULE_4__[\"COMMENT_TYPE\"],id,parent};const entry={address,url:json.url,authors:this._addNullableAuthor(json.author),body:json.body,reactions:expectAllNonNull(json,\"reactions\",json.reactions).map(x=>this._addReaction(x)),timestampMs:+new Date(json.createdAt)};this._comments.set(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address),entry);return address;}_addReaction(json){const authorAddresses=this._addNullableAuthor(json.user);if(authorAddresses.length!==1){throw new Error(\"Invariant violation: Reaction with id \".concat(json.id,\" did not have 1 author\"));}const timestampMs=+new Date(json.createdAt);return{content:json.content,user:authorAddresses[0],timestampMs};}_addNullableAuthor(json){if(json==null){return[];}else{const login=json.login;const subtype=Object(_bots__WEBPACK_IMPORTED_MODULE_9__[\"botSet\"])().has(login)?_nodes__WEBPACK_IMPORTED_MODULE_4__[\"BOT_SUBTYPE\"]:_nodes__WEBPACK_IMPORTED_MODULE_4__[\"USER_SUBTYPE\"];const address={type:_nodes__WEBPACK_IMPORTED_MODULE_4__[\"USERLIKE_TYPE\"],subtype,login};const entry={address,url:json.url};this._userlikes.set(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](address),entry);return[address];}}/**\n   * Creates a Map<URL, NodeAddressT> for each ReferentEntity in this view.\n   * Note: duplicates are accepted within one view. However for any URL, the\n   * corresponding N.RawAddress should be the same, or we'll throw an error.\n   */urlReferenceMap(){const refToAddress=new Map();for(const e of this.referentEntities()){const addr=_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](e.address());const url=e.url();const existing=refToAddress.get(url);if(existing&&existing!==addr){throw new Error(Object(_util_dedent__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"          An entry for \",\" already existed, but with a different NodeAddressT.\\n          This is probably a bug with SourceCred. Please report it on GitHub.\\n          Old: \",\"\\n          New: \",\"\\n        \"],[\"\\\\\\n          An entry for \",\" already existed, but with a different NodeAddressT.\\n          This is probably a bug with SourceCred. Please report it on GitHub.\\n          Old: \",\"\\n          New: \",\"\\n        \"])),url,_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toString(existing),_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toString(addr)));}refToAddress.set(url,addr);}return refToAddress;}_addReferences(){// TODO(perf): _addReferences regenerates all refs from scratch\nthis._mapReferences=new Map();this._mapReferencedBy=new Map();// refToAddress maps a \"referencing string\" to the address that string refers to.\n// There are 3 kinds of valid referencing strings:\n// - A canonical URL pointing to a GitHub entity, e.g.\n//   https://github.com/sourcecred/sourcecred/pull/416\n// - A # followed by a number, such as #416\n// - An @ followed by a login name, such as @decentralion\nconst refToAddress=new Map();for(const e of this.referentEntities()){const a=e.address();refToAddress.set(e.url(),a);if(e instanceof Userlike){refToAddress.set(\"@\".concat(e.login()),a);}if(e instanceof Issue||e instanceof Pull){refToAddress.set(\"#\".concat(e.number()),a);refToAddress.set(\"\".concat(e.parent().owner(),\"/\").concat(e.parent().name(),\"#\").concat(e.number()),a);}if(e instanceof Commit){refToAddress.set(e.hash(),a);}}for(const e of this.textContentEntities()){const srcAddress=e.address();const body=e instanceof Commit?e.message():e.body();for(const{ref,refType}of Object(_parseReferences__WEBPACK_IMPORTED_MODULE_3__[\"parseReferences\"])(body)){const refAddress=refToAddress.get(ref);if(refAddress!=null){switch(refType){case\"BASIC\":this._addReference(srcAddress,refAddress);break;case\"PAIRED_WITH\":if(refAddress.type!==_nodes__WEBPACK_IMPORTED_MODULE_4__[\"USERLIKE_TYPE\"]){throw new Error(\"Invariant error: @-ref did not refer to userlike: \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_2___default()(refAddress)));}const userlike=this.userlike(refAddress);if(userlike==null){throw new Error(\"Invariant error: nonexistent reference: \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_2___default()(refAddress)));}this._addExtraAuthor(e,userlike);break;default:throw new Error(\"Unexpected refType: \".concat(refType));}}}}}_addReference(src,dst){const srcRaw=_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](src);const referencesForSrc=this._mapReferences.get(srcRaw);if(referencesForSrc==null){this._mapReferences.set(srcRaw,[dst]);}else{referencesForSrc.push(dst);}const dstRaw=_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](dst);const referencedByForDst=this._mapReferencedBy.get(dstRaw);if(referencedByForDst==null){this._mapReferencedBy.set(dstRaw,[src]);}else{referencedByForDst.push(src);}}_addExtraAuthor(e,extraAuthor){for(const existingAuthor of e.authors()){if(existingAuthor.login()===extraAuthor.login()){return;// user can't author the same thing twice\n}}e._entry.authors.push(extraAuthor.address());}*_referencedBy(e){const refs=this._mapReferencedBy.get(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](e.address()));if(refs==null){return;}else{for(const address of refs){let entity;switch(address.type){case\"ISSUE\":entity=this.issue(address);break;case\"PULL\":entity=this.pull(address);break;case\"REVIEW\":entity=this.review(address);break;case\"COMMENT\":entity=this.comment(address);break;case\"COMMIT\":entity=this.commit(address);break;default:throw new Error(\"Unexpected referrer address type: \".concat(address.type));}if(entity==null){throw new Error(\"Invariant error: Reference from non-existent entity: \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_2___default()(address)));}yield entity;}}}*_references(e){const refs=this._mapReferences.get(_nodes__WEBPACK_IMPORTED_MODULE_4__[\"toRaw\"](e.address()));if(refs==null){return;}else{for(const address of refs){let entity;switch(address.type){case\"REPO\":entity=this.repo(address);break;case\"ISSUE\":entity=this.issue(address);break;case\"PULL\":entity=this.pull(address);break;case\"REVIEW\":entity=this.review(address);break;case\"COMMENT\":entity=this.comment(address);break;case\"COMMIT\":entity=this.commit(address);break;case\"USERLIKE\":entity=this.userlike(address);break;default:throw new Error(\"Unexpected referent address type: \".concat(address.type));}if(entity==null){throw new Error(\"Invariant error: Reference to non-existent entity: \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_2___default()(address)));}yield entity;}}}}class _Entity{constructor(view,entry){_defineProperty(this,\"_view\",void 0);_defineProperty(this,\"_entry\",void 0);this._view=view;this._entry=entry;}address(){// Relevant Flow bugs:\n//   - https://github.com/facebook/flow/issues/6648\n//   - https://github.com/facebook/flow/issues/6649\nreturn this._entry.address;}url(){return this._entry.url;}timestampMs(){throw new Error(\"Not implemented.\");}description(){throw new Error(\"Not implemented.\");}}class Repo extends _Entity{constructor(view,entry){super(view,entry);}name(){return this._entry.address.name;}owner(){return this._entry.address.owner;}*issues(){for(const address of this._entry.issues){const issue=this._view.issue(address);yield assertExists(issue,address);}}*pulls(){for(const address of this._entry.pulls){const pull=this._view.pull(address);yield assertExists(pull,address);}}referencedBy(){return this._view._referencedBy(this);}timestampMs(){return this._entry.timestampMs;}description(){return\"[\".concat(this.owner(),\"/\").concat(this.name(),\"](\").concat(this.url(),\")\");}}class Issue extends _Entity{constructor(view,entry){super(view,entry);}parent(){const address=this.address().repo;const repo=this._view.repo(address);return assertExists(repo,address);}number(){return this._entry.address.number;}title(){return this._entry.title;}body(){return this._entry.body;}timestampMs(){return this._entry.timestampMs;}description(){return\"[#\".concat(this.number(),\"](\").concat(this.url(),\"): \").concat(this.title());}*comments(){for(const address of this._entry.comments){const comment=this._view.comment(address);yield assertExists(comment,address);}}authors(){return getAuthors(this._view,this._entry);}references(){return this._view._references(this);}referencedBy(){return this._view._referencedBy(this);}reactions(){return this._entry.reactions;}}class Pull extends _Entity{constructor(view,entry){super(view,entry);}parent(){const address=this.address().repo;const repo=this._view.repo(address);return assertExists(repo,address);}number(){return this._entry.address.number;}title(){return this._entry.title;}body(){return this._entry.body;}additions(){return this._entry.additions;}deletions(){return this._entry.deletions;}mergedAs(){return this._entry.mergedAs;}timestampMs(){return this._entry.timestampMs;}description(){return\"[#\".concat(this.number(),\"](\").concat(this.url(),\"): \").concat(this.title());}*reviews(){for(const address of this._entry.reviews){const review=this._view.review(address);yield assertExists(review,address);}}*comments(){for(const address of this._entry.comments){const comment=this._view.comment(address);yield assertExists(comment,address);}}authors(){return getAuthors(this._view,this._entry);}references(){return this._view._references(this);}referencedBy(){return this._view._referencedBy(this);}reactions(){return this._entry.reactions;}}class Review extends _Entity{constructor(view,entry){super(view,entry);}parent(){const address=this.address().pull;const pull=this._view.pull(address);return assertExists(pull,address);}body(){return this._entry.body;}state(){return this._entry.state;}*comments(){for(const address of this._entry.comments){const comment=this._view.comment(address);yield assertExists(comment,address);}}authors(){return getAuthors(this._view,this._entry);}timestampMs(){return this._entry.timestampMs;}description(){return\"[review](\".concat(this.url(),\") on \").concat(this.parent().description());}references(){return this._view._references(this);}referencedBy(){return this._view._referencedBy(this);}}class Comment extends _Entity{constructor(view,entry){super(view,entry);}parent(){const address=this.address().parent;let parent;switch(address.type){case\"PULL\":parent=this._view.pull(address);break;case\"ISSUE\":parent=this._view.issue(address);break;case\"REVIEW\":parent=this._view.review(address);break;default:throw new Error(\"Bad parent address type: \".concat(address.type));}return assertExists(parent,address);}body(){return this._entry.body;}timestampMs(){return this._entry.timestampMs;}description(){return\"[comment](\".concat(this.url(),\") on \").concat(this.parent().description());}authors(){return getAuthors(this._view,this._entry);}references(){return this._view._references(this);}referencedBy(){return this._view._referencedBy(this);}reactions(){return this._entry.reactions;}}class Commit extends _Entity{constructor(view,entry){super(view,entry);}authors(){return getAuthors(this._view,this._entry);}message(){return this._entry.message;}references(){return this._view._references(this);}referencedBy(){return this._view._referencedBy(this);}hash(){return this._entry.hash;}timestampMs(){return this._entry.timestampMs;}description(){const shortHash=this.hash().slice(0,7);const headline=this.message().split(\"\\n\")[0];return\"[\".concat(shortHash,\"](\").concat(this.url(),\"): \").concat(headline);}}class Userlike extends _Entity{constructor(view,entry){super(view,entry);}login(){return this.address().login;}referencedBy(){return this._view._referencedBy(this);}timestampMs(){return null;}description(){return\"github/[@\".concat(this.login(),\"](\").concat(this.url(),\")\");}}function assertExists(item,address){if(item==null){throw new Error(\"Invariant violation: Expected entity for \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_2___default()(address)));}return item;}function*getAuthors(view,entry){for(const address of entry.authors){const author=view.userlike(address);yield assertExists(author,address);}}function match(handlers,x){if(x instanceof Repo){return handlers.repo(x);}if(x instanceof Issue){return handlers.issue(x);}if(x instanceof Pull){return handlers.pull(x);}if(x instanceof Review){return handlers.review(x);}if(x instanceof Comment){return handlers.comment(x);}if(x instanceof Commit){return handlers.commit(x);}if(x instanceof Userlike){return handlers.userlike(x);}throw new Error(\"Unexpected entity \".concat(x));}/**\n * Invoke this function when the GitHub GraphQL schema docs indicate\n * that a connection provides a list of _nullable_ nodes, but we expect\n * them all to always be non-null.\n *\n * This will drop any `null` elements from the provided list, issuing a\n * warning to stderr if `null`s are found.\n */function expectAllNonNull(context,fieldname,xs){const result=[];for(const x of xs){if(x!==null){result.push(x);}else{console.warn(\"\".concat(context.__typename,\"[\").concat(context.id,\"].\").concat(fieldname,\": \")+\"unexpected null value\");}}return result;}\n\n//# sourceURL=webpack:///./src/plugins/github/relationalView.js?");

/***/ }),

/***/ "./src/plugins/github/repoId.js":
/*!**************************************!*\
  !*** ./src/plugins/github/repoId.js ***!
  \**************************************/
/*! exports provided: githubOwnerPattern, githubRepoPattern, makeRepoId, stringToRepoId, repoIdToString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"githubOwnerPattern\", function() { return githubOwnerPattern; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"githubRepoPattern\", function() { return githubRepoPattern; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeRepoId\", function() { return makeRepoId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringToRepoId\", function() { return stringToRepoId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"repoIdToString\", function() { return repoIdToString; });\n// Right now all RepoIds are assumed to refer to GitHub repos.\n// In the future, we may support other identifiers.\nconst githubOwnerPattern=\"[A-Za-z0-9-]+\";const githubRepoPattern=\"[A-Za-z0-9-._]+\";function makeRepoId(owner,name){const validOwner=new RegExp(\"^\".concat(githubOwnerPattern,\"$\"));const validRepo=new RegExp(\"^\".concat(githubRepoPattern,\"$\"));if(!owner.match(validOwner)){throw new Error(\"Invalid repository owner: \".concat(JSON.stringify(owner)));}if(!name.match(validRepo)){throw new Error(\"Invalid repository name: \".concat(JSON.stringify(name)));}return{owner,name};}function stringToRepoId(x){const pieces=x.split(\"/\");if(pieces.length!==2){throw new Error(\"Invalid repo string: \".concat(x));}return makeRepoId(pieces[0],pieces[1]);}function repoIdToString(x){return\"\".concat(x.owner,\"/\").concat(x.name);}\n\n//# sourceURL=webpack:///./src/plugins/github/repoId.js?");

/***/ }),

/***/ "./src/plugins/github/schema.js":
/*!**************************************!*\
  !*** ./src/plugins/github/schema.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return schema; });\n/* harmony import */ var _graphql_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../graphql/schema */ \"./src/graphql/schema.js\");\nfunction schema(){const s=_graphql_schema__WEBPACK_IMPORTED_MODULE_0__;const types={DateTime:s.scalar(\"string\"),GitObjectID:s.scalar(\"string\"),GitTimestamp:s.scalar(\"string\"),Int:s.scalar(\"number\"),String:s.scalar(\"string\"),URI:s.scalar(\"string\"),PullRequestReviewState:s.enum([\"PENDING\",\"COMMENTED\",\"APPROVED\",\"CHANGES_REQUESTED\",\"DISMISSED\"]),ReactionContent:s.enum([\"THUMBS_UP\",\"THUMBS_DOWN\",\"LAUGH\",\"HOORAY\",\"CONFUSED\",\"HEART\",\"ROCKET\",\"EYES\"]),Repository:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),name:s.primitive(s.nonNull(\"String\")),owner:s.node(\"RepositoryOwner\"),issues:s.connection(\"Issue\"),pullRequests:s.connection(\"PullRequest\"),defaultBranchRef:s.node(\"Ref\"),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),Issue:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),title:s.primitive(s.nonNull(\"String\")),body:s.primitive(s.nonNull(\"String\")),number:s.primitive(s.nonNull(\"Int\")),author:s.node(\"Actor\"),comments:s.connection(\"IssueComment\"),reactions:s.connection(\"Reaction\"),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),PullRequest:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),title:s.primitive(s.nonNull(\"String\")),body:s.primitive(s.nonNull(\"String\")),number:s.primitive(s.nonNull(\"Int\")),mergeCommit:s.node(\"Commit\"),additions:s.primitive(s.nonNull(\"Int\")),deletions:s.primitive(s.nonNull(\"Int\")),author:s.node(\"Actor\"),comments:s.connection(\"IssueComment\"),// yes, PRs have IssueComments\nreviews:s.connection(\"PullRequestReview\"),reactions:s.connection(\"Reaction\"),createdAt:s.primitive(s.nonNull(\"DateTime\")),baseRefName:s.primitive(s.nonNull(\"String\"))}),IssueComment:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),body:s.primitive(s.nonNull(\"String\")),author:s.node(\"Actor\"),reactions:s.connection(\"Reaction\"),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),PullRequestReview:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),body:s.primitive(s.nonNull(\"String\")),author:s.node(\"Actor\"),state:s.primitive(s.nonNull(\"PullRequestReviewState\")),comments:s.connection(\"PullRequestReviewComment\"),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),PullRequestReviewComment:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),body:s.primitive(s.nonNull(\"String\")),author:s.node(\"Actor\"),reactions:s.connection(\"Reaction\"),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),Reaction:s.object({id:s.id(),content:s.primitive(s.nonNull(\"ReactionContent\")),user:s.node(\"User\",s.unfaithful([\"User\",\"Organization\"])),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),Ref:s.object({id:s.id(),// Unlike most node references, this is guaranteed non-null (but\n// we have no way to express that).\ntarget:s.node(\"GitObject\")}),GitObject:s.union([\"Blob\",\"Commit\",\"Tag\",\"Tree\"]),Blob:s.object({id:s.id(),oid:s.primitive(s.nonNull(\"GitObjectID\"))}),Commit:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),oid:s.primitive(s.nonNull(\"GitObjectID\")),message:s.primitive(s.nonNull(\"String\")),author:/* GitActor */s.nested({// The GitHub schema indicates that `date` can be null, but does\n// not indicate when this might be the case.\ndate:s.primitive(s.nullable(\"GitTimestamp\")),user:s.node(\"User\",s.unfaithful([\"User\",\"Bot\"]))}),parents:s.connection(\"Commit\"),// In contrast to the author.date, this is both nonNull and is\n// specifically the authoredDate. Docs for author.date suggest that\n// field might be the commiter date instead.\nauthoredDate:s.primitive(s.nonNull(\"GitTimestamp\"))}),Tag:s.object({id:s.id(),oid:s.primitive(s.nonNull(\"GitObjectID\"))}),Tree:s.object({id:s.id(),oid:s.primitive(s.nonNull(\"GitObjectID\"))}),Actor:s.union([\"User\",\"Bot\",\"Organization\"]),// actually an interface\nRepositoryOwner:s.union([\"User\",\"Organization\"]),// actually an interface\nUser:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),login:s.primitive(s.nonNull(\"String\"))}),Bot:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),login:s.primitive(s.nonNull(\"String\"))}),Organization:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),login:s.primitive(s.nonNull(\"String\"))})};return s.schema(types);}\n\n//# sourceURL=webpack:///./src/plugins/github/schema.js?");

/***/ }),

/***/ "./src/plugins/github/token.js":
/*!*************************************!*\
  !*** ./src/plugins/github/token.js ***!
  \*************************************/
/*! exports provided: validateToken */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateToken\", function() { return validateToken; });\n/**\n * Validates a token against know formatting.\n * Throws an error if it appears invalid.\n *\n * Personal access token\n * https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line\n *\n * Installation access token\n * https://developer.github.com/v3/apps/#create-a-new-installation-token\n */function validateToken(token){const accessTokenRE=/^gh[pousr]_[A-Za-z0-9_]*$/;const oldAccessTokenRE=/^[A-Fa-f0-9]{40}$/;if(accessTokenRE.test(token)||oldAccessTokenRE.test(token)){return token;}// We're currently being lenient with installation tokens, since we're not completely\n// sure on the exact format. We're only warning on unexpected values but leave it up\n// to the GitHub API to reject the token if it's actually invalid.\nconst installationAccessTokenRE=/^(v\\d+)\\.([A-Za-z0-9_]+)$/;const matches=installationAccessTokenRE.exec(token);if(matches!=null){const[_,version,hexCode]=matches;if(version!==\"v1\"){console.warn(\"Warning: GitHub installation access token has an unexpected version \\\"\".concat(version,\"\\\".\"));}if(hexCode.length!==40){console.warn(\"Warning: GitHub installation access token has an unexpected hexadecimal component \"+\"length of \".concat(hexCode.length,\".\"));}return token;}throw new Error(\"The token supplied to $SOURCECRED_GITHUB_TOKEN doesn't match any format known to work.\\n\"+\"Please verify the token \\\"\".concat(token,\"\\\" is correct, or report a bug if you think it should work.\"));}\n\n//# sourceURL=webpack:///./src/plugins/github/token.js?");

/***/ }),

/***/ "./src/plugins/github/urlIdParse.js":
/*!******************************************!*\
  !*** ./src/plugins/github/urlIdParse.js ***!
  \******************************************/
/*! exports provided: reviewUrlToId, issueCommentUrlToId, pullCommentUrlToId, reviewCommentUrlToId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reviewUrlToId\", function() { return reviewUrlToId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"issueCommentUrlToId\", function() { return issueCommentUrlToId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pullCommentUrlToId\", function() { return pullCommentUrlToId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reviewCommentUrlToId\", function() { return reviewCommentUrlToId; });\n/* harmony import */ var _repoId__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./repoId */ \"./src/plugins/github/repoId.js\");\nconst urlBase=\"^https?://github\\\\.com\";const repoUrl=\"\".concat(urlBase,\"/(?:\").concat(_repoId__WEBPACK_IMPORTED_MODULE_0__[\"githubOwnerPattern\"],\")/(?:\").concat(_repoId__WEBPACK_IMPORTED_MODULE_0__[\"githubRepoPattern\"],\")/\");function reviewUrlToId(url){const suffix=/pull\\/\\d+#pullrequestreview-(\\d+)$/;const regex=new RegExp(repoUrl+suffix.source);const result=regex.exec(url);if(result==null){throw new Error(\"Error parsing review url \".concat(url));}return result[1];}function issueCommentUrlToId(url){const suffix=/issues\\/\\d+#issuecomment-(\\d+)$/;const regex=new RegExp(repoUrl+suffix.source);const result=regex.exec(url);if(result==null){throw new Error(\"Error parsing issue comment url \".concat(url));}return result[1];}function pullCommentUrlToId(url){const suffix=/pull\\/\\d+#issuecomment-(\\d+)$/;const regex=new RegExp(repoUrl+suffix.source);const result=regex.exec(url);if(result==null){throw new Error(\"Error parsing pull comment url \".concat(url));}return result[1];}function reviewCommentUrlToId(url){const suffix=/pull\\/\\d+#discussion_r(\\d+)/;const regex=new RegExp(repoUrl+suffix.source);const result=regex.exec(url);if(result==null){throw new Error(\"Error parsing review comment url \".concat(url));}return result[1];}\n\n//# sourceURL=webpack:///./src/plugins/github/urlIdParse.js?");

/***/ }),

/***/ "./src/plugins/initiatives/config.js":
/*!*******************************************!*\
  !*** ./src/plugins/initiatives/config.js ***!
  \*******************************************/
/*! exports provided: parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _initiativesDirectory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./initiativesDirectory */ \"./src/plugins/initiatives/initiativesDirectory.js\");\nconst parser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({remoteUrl:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],_initiativesDirectory__WEBPACK_IMPORTED_MODULE_1__[\"_validateUrl\"])});\n\n//# sourceURL=webpack:///./src/plugins/initiatives/config.js?");

/***/ }),

/***/ "./src/plugins/initiatives/createGraph.js":
/*!************************************************!*\
  !*** ./src/plugins/initiatives/createGraph.js ***!
  \************************************************/
/*! exports provided: initiativeWeight, createWeightedGraph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initiativeWeight\", function() { return initiativeWeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createWeightedGraph\", function() { return createWeightedGraph; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _core_weightedGraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/weightedGraph */ \"./src/core/weightedGraph.js\");\n/* harmony import */ var _initiative__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initiative */ \"./src/plugins/initiatives/initiative.js\");\n/* harmony import */ var _nodeEntry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nodeEntry */ \"./src/plugins/initiatives/nodeEntry.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/initiatives/declaration.js\");\n/* harmony import */ var _initiativeFile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./initiativeFile */ \"./src/plugins/initiatives/initiativeFile.js\");\nfunction initiativeAddress(initiative){return Object(_initiative__WEBPACK_IMPORTED_MODULE_2__[\"addressFromId\"])(initiative.id);}function initiativeNode(initiative){const address=initiativeAddress(initiative);const url=Object(_initiativeFile__WEBPACK_IMPORTED_MODULE_5__[\"initiativeFileURL\"])(address);return{address,timestampMs:initiative.timestampMs,description:url==null?initiative.title:\"[\".concat(initiative.title,\"](\").concat(url,\")\")};}function nodeFromEntry(entry,parentId,field){const address=Object(_nodeEntry__WEBPACK_IMPORTED_MODULE_3__[\"addressForNodeEntry\"])(field,parentId,entry.key);return{address,timestampMs:entry.timestampMs,description:entry.title};}function initiativeWeight(initiative){if(!initiative.weight)return;return initiative.completed?initiative.weight.complete:initiative.weight.incomplete;}function edgeFactory(prefix,fromInitiative){return(initiative,other)=>{const iAddr=initiativeAddress(initiative);const src=fromInitiative?iAddr:other;const dst=fromInitiative?other:iAddr;return{address:_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(prefix,..._core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toParts(initiativeAddress(initiative)),..._core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toParts(other)),timestampMs:initiative.timestampMs,src,dst};};}const depedencyEdge=edgeFactory(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"dependsOnEdgeType\"].prefix,true);const referenceEdge=edgeFactory(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"referencesEdgeType\"].prefix,true);const contributionEdge=edgeFactory(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"contributesToEdgeType\"].prefix,false);const championEdge=edgeFactory(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"championsEdgeType\"].prefix,false);function createWeightedGraph(repo,refs){const wg=_core_weightedGraph__WEBPACK_IMPORTED_MODULE_1__[\"empty\"]();const{graph,weights}=wg;for(const initiative of repo.initiatives()){// Adds the Initiative node.\nconst node=initiativeNode(initiative);const weight=initiativeWeight(initiative);graph.addNode(node);if(weight){weights.nodeWeights.set(node.address,weight);}// Generic approach to adding edges when the reference detector has a hit.\nconst urlHandler=(urls,createEdge)=>{for(const url of urls){const addr=refs.addressFromUrl(url);if(!addr){console.warn(\"initiative \".concat(initiative.title,\": no address for \").concat(url));continue;}graph.addEdge(createEdge(initiative,addr));}};// Generic approach to handling EdgeSpecs.\nconst edgeSpecHandler=(_ref,createEdge,field)=>{let{urls,entries}=_ref;// Delegate handling the URLs.\nurlHandler(urls,createEdge);for(const entry of entries){// Add the NodeEntry contribution itself to the graph.\nconst entryNode=nodeFromEntry(entry,initiative.id,field);graph.addNode(entryNode);graph.addEdge(createEdge(initiative,entryNode.address));if(entry.weight!=null){weights.nodeWeights.set(entryNode.address,entry.weight);}// Add edges to the contributors.\nfor(const contributor of entry.contributors){const addr=refs.addressFromUrl(contributor);if(!addr){console.warn(\"entry \".concat(entry.title,\": no address for contributor \").concat(contributor));continue;}graph.addEdge({address:_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"EdgeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_4__[\"contributesToEntryEdgeType\"].prefix,..._core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toParts(entryNode.address),..._core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toParts(addr)),timestampMs:entry.timestampMs,src:addr,dst:entryNode.address});}}};// Maps the edge types to it's fields.\nedgeSpecHandler(initiative.dependencies,depedencyEdge,\"DEPENDENCY\");edgeSpecHandler(initiative.references,referenceEdge,\"REFERENCE\");edgeSpecHandler(initiative.contributions,contributionEdge,\"CONTRIBUTION\");urlHandler(initiative.champions,championEdge);}return wg;}\n\n//# sourceURL=webpack:///./src/plugins/initiatives/createGraph.js?");

/***/ }),

/***/ "./src/plugins/initiatives/declaration.js":
/*!************************************************!*\
  !*** ./src/plugins/initiatives/declaration.js ***!
  \************************************************/
/*! exports provided: nodePrefix, edgePrefix, initiativeNodeType, _formatNodeEntryField, nodeEntryTypes, contributionEntryType, dependencyEntryType, referenceEntryType, dependsOnEdgeType, referencesEdgeType, contributesToEdgeType, contributesToEntryEdgeType, championsEdgeType, declaration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodePrefix\", function() { return nodePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgePrefix\", function() { return edgePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initiativeNodeType\", function() { return initiativeNodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_formatNodeEntryField\", function() { return _formatNodeEntryField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodeEntryTypes\", function() { return nodeEntryTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contributionEntryType\", function() { return contributionEntryType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dependencyEntryType\", function() { return dependencyEntryType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referenceEntryType\", function() { return referenceEntryType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dependsOnEdgeType\", function() { return dependsOnEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"referencesEdgeType\", function() { return referencesEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contributesToEdgeType\", function() { return contributesToEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contributesToEntryEdgeType\", function() { return contributesToEntryEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"championsEdgeType\", function() { return championsEdgeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"declaration\", function() { return declaration; });\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze */ \"deep-freeze\");\n/* harmony import */ var deep_freeze__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\nconst nodePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].fromParts([\"sourcecred\",\"initiatives\"]);const edgePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].fromParts([\"sourcecred\",\"initiatives\"]);const initiativeNodeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Initiative\",pluralName:\"Initiatives\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,\"initiative\"),defaultWeight:1,description:\"An initiative supernode, describing a scoped improvement to a project from proposal to completion.\"});// Changes capitalization for the field for display purposes.\nfunction _formatNodeEntryField(field){return field[0].toUpperCase()+field.substring(1).toLowerCase();}function nodeEntryType(field){const displayField=_formatNodeEntryField(field);return deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"\".concat(displayField,\" Entry\"),pluralName:\"\".concat(displayField,\" Entries\"),prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"NodeAddress\"].append(nodePrefix,String(field)),defaultWeight:1,description:\"A \".concat(displayField.toLowerCase(),\" entry node, to easily include\")+\"contributions when other plugins don't add it to the graph.\"});}// Note: we're exporting an object map with `NodeEntryField` as the key type.\n// This allows a generalized lookup of the NodeType in graphing logic.\nconst nodeEntryTypes=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({CONTRIBUTION:nodeEntryType(\"CONTRIBUTION\"),DEPENDENCY:nodeEntryType(\"DEPENDENCY\"),REFERENCE:nodeEntryType(\"REFERENCE\")});// Keeping with convention of other declarations, also name each type.\nconst contributionEntryType=nodeEntryTypes.CONTRIBUTION;const dependencyEntryType=nodeEntryTypes.DEPENDENCY;const referenceEntryType=nodeEntryTypes.REFERENCE;/*\n  Note on the forward and backward naming convention.\n  It follows the core/graph.js documentation to use\n  a <subject> <verb> <object> format to figure out\n  the directionality.\n*/ /**\n * An initiative (src) DEPENDS ON (verb) a dependency (dst).\n * Forward: depending on something shows the value of the dependency.\n * Backward: having a dependency does not endorse the iniative, but does flow\n * some cred to incentivize reuse and attribution.\n */const dependsOnEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"depends on\",backwardName:\"is a dependency for\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"dependsOn\"),defaultWeight:{forwards:1,backwards:1/16},description:\"Connects an initiative to it's dependencies.\"});/**\n * An initiative (src) REFERENCES (verb) a reference (dst).\n * Forward: referencing from an initiative shows the value of the reference.\n * But we assume a reference likely needs some refinement to be used by the initiative,\n * so it flows less cred than to a dependency.\n * Backward: having reference material does not endorse the iniative, but does flow\n * some cred to incentivize using existing research and attribution.\n */const referencesEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"references\",backwardName:\"is referenced for\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"references\"),defaultWeight:{forwards:1/2,backwards:1/16},description:\"Connects an initiative to it's references.\"});/**\n * A contribution (src) CONTRIBUTES TO (verb) an initiative (dst).\n * Forward: a contribution towards the initiative is also an endorsement of the\n * value of that initiative.\n * Backward: an initiative in large part consists of it's contributions, so the\n * value of an initiative caries over to it's contributions.\n */const contributesToEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"contributes to\",backwardName:\"is contributed to by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"contributesTo\"),defaultWeight:{forwards:1,backwards:1},description:\"Connects an initiative to it's contributions.\"});/**\n * A contributor (src) CONTRIBUTES TO (verb) an entry node (dst).\n * Forward: a contributor towards the entry node has a small endorsement of that\n * contribution. Though a high weight would risk contributors' own cred gets\n * \"lost to alpha\".\n * Backward: flows the value of the contribution to the contributors.\n */const contributesToEntryEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"contributes to entry\",backwardName:\"entry is contributed to by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"contributesToEntry\"),defaultWeight:{forwards:1/16,backwards:1},description:\"Connects a contributor to an entry node.\"});/**\n * A user (src) CHAMPIONS (verb) an initiative (dst).\n * Meaning forward is the user claiming and committing they will champion an\n * initiative. And backward is the return of cred based on the completion and\n * succesful championing of the ininiative.\n *\n * Forward: a user championing an iniative is also an endorsement of the value\n * of that initiative.\n * Backward: an initiative likely received a lot of ongoing support from it's\n * champion. We're assuming this is more support than individual contributions.\n */const championsEdgeType=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({forwardName:\"champions\",backwardName:\"is championed by\",prefix:_core_graph__WEBPACK_IMPORTED_MODULE_1__[\"EdgeAddress\"].append(edgePrefix,\"champions\"),defaultWeight:{forwards:1,backwards:4},description:\"Connects an initiative to users who champion it.\"});const declaration=deep_freeze__WEBPACK_IMPORTED_MODULE_0___default()({name:\"Initiatives\",nodePrefix,edgePrefix,nodeTypes:[initiativeNodeType,contributionEntryType,dependencyEntryType,referenceEntryType],edgeTypes:[dependsOnEdgeType,referencesEdgeType,contributesToEdgeType,championsEdgeType,contributesToEntryEdgeType],userTypes:[]});\n\n//# sourceURL=webpack:///./src/plugins/initiatives/declaration.js?");

/***/ }),

/***/ "./src/plugins/initiatives/edgeSpec.js":
/*!*********************************************!*\
  !*** ./src/plugins/initiatives/edgeSpec.js ***!
  \*********************************************/
/*! exports provided: normalizeEdgeSpec, _validateEdgeSpec, _findDuplicatesByKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeEdgeSpec\", function() { return normalizeEdgeSpec; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_validateEdgeSpec\", function() { return _validateEdgeSpec; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_findDuplicatesByKey\", function() { return _findDuplicatesByKey; });\n/* harmony import */ var _util_findDuplicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/findDuplicates */ \"./src/util/findDuplicates.js\");\n/* harmony import */ var _nodeEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodeEntry */ \"./src/plugins/initiatives/nodeEntry.js\");\n/**\n * A type which supports multiple ways of defining what edges an Initiative has.\n * Currently includes reference detected URLs and NodeEntries.\n * This is the normalized variant of EdgeSpecJson.\n */ /**\n * Takes an EdgeSpecJson and normalizes it to an EdgeSpec.\n *\n * Will throw when required fields are missing or duplicate keys are found.\n * Otherwise handles default values and converting ISO timestamps.\n * Note: we allow the EdgeSpecJson to be undefined to easily support omitting\n * edges entirely, while still normalizing to an EdgeSpec.\n */function normalizeEdgeSpec(spec,defaultTimestampMs){const{urls,entries}=spec||{};return _validateEdgeSpec({urls:urls||[],entries:(entries||[]).map(x=>Object(_nodeEntry__WEBPACK_IMPORTED_MODULE_1__[\"normalizeNodeEntry\"])(x,defaultTimestampMs))});}/**\n * A separate function to validate an EdgeSpec after it's normalized.\n * Normally you don't need to invoke this directly.\n */function _validateEdgeSpec(spec){const duplicates=_findDuplicatesByKey(spec.entries);if(duplicates.size){// The keys are duplicate and often generated by the normalize functions.\n// So we need to offer more details to identify the duplicate entries.\nconst dupeList=Array.from(duplicates).map(e=>JSON.stringify(e)).join(\"\\n  \");throw new Error(\"Duplicate entry keys are not allowed, you may need to \"+\"set keys manually for:\\n  \".concat(dupeList));}return spec;}/**\n * Find the NodeEntries which have a duplicate key.\n */function _findDuplicatesByKey(entries){const duplicateKeys=Object(_util_findDuplicates__WEBPACK_IMPORTED_MODULE_0__[\"findDuplicates\"])(entries.map(e=>e.key));// Having a set of keys is useful, but we want to know where these keys came from.\n// Include all entries with a key that produces duplicates, even the first one.\nreturn new Set(entries.filter(e=>duplicateKeys.has(e.key)));}\n\n//# sourceURL=webpack:///./src/plugins/initiatives/edgeSpec.js?");

/***/ }),

/***/ "./src/plugins/initiatives/initiative.js":
/*!***********************************************!*\
  !*** ./src/plugins/initiatives/initiative.js ***!
  \***********************************************/
/*! exports provided: createId, addressFromId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createId\", function() { return createId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addressFromId\", function() { return addressFromId; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/initiatives/declaration.js\");\n// Composite ID, used as input for NodeAddressT.\n// Enforce that each ID has at least a sub-type and 1..n components.\nfunction createId(subType,requiredId){for(var _len=arguments.length,rest=new Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){rest[_key-2]=arguments[_key];}return[subType,requiredId,...rest];}function addressFromId(id){return _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"initiativeNodeType\"].prefix,...id);}// A before completion and after completion weight for Initiatives.\n\n//# sourceURL=webpack:///./src/plugins/initiatives/initiative.js?");

/***/ }),

/***/ "./src/plugins/initiatives/initiativeFile.js":
/*!***************************************************!*\
  !*** ./src/plugins/initiatives/initiativeFile.js ***!
  \***************************************************/
/*! exports provided: INITIATIVE_FILE_SUBTYPE, upgradeFrom010, COMPAT_INFO, fromJSON, toJSON, initiativeFileURL, initiativeFileId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INITIATIVE_FILE_SUBTYPE\", function() { return INITIATIVE_FILE_SUBTYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"upgradeFrom010\", function() { return upgradeFrom010; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMPAT_INFO\", function() { return COMPAT_INFO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromJSON\", function() { return fromJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toJSON\", function() { return toJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initiativeFileURL\", function() { return initiativeFileURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initiativeFileId\", function() { return initiativeFileId; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _util_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/compat */ \"./src/util/compat.js\");\n/* harmony import */ var _initiative__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initiative */ \"./src/plugins/initiatives/initiative.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/initiatives/declaration.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const INITIATIVE_FILE_SUBTYPE=\"INITIATIVE_FILE\";/**\n * Represents a single Initiative using a file as source.\n *\n * Note: The file name will be used to derive the InitiativeId. So it doesn't\n * make sense to use this outside of the context of an InitiativesDirectory.\n */const upgradeFrom010=file=>_objectSpread(_objectSpread({},file),{},{contributions:{urls:file.contributions},dependencies:{urls:file.dependencies},references:{urls:file.references}});const upgrades={\"0.1.0\":upgradeFrom010};const COMPAT_INFO={type:\"sourcecred/initiativeFile\",version:\"0.2.0\"};function fromJSON(j){return Object(_util_compat__WEBPACK_IMPORTED_MODULE_1__[\"fromCompat\"])(COMPAT_INFO,j,upgrades);}function toJSON(m){return Object(_util_compat__WEBPACK_IMPORTED_MODULE_1__[\"toCompat\"])(COMPAT_INFO,m);}/**\n * When provided with the initiative NodeAddressT of an InitiativeFile this extracts\n * the URL from it. Or null when the address is not for an InitiativeFile.\n */function initiativeFileURL(address){const initiativeFilePrefix=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_3__[\"initiativeNodeType\"].prefix,INITIATIVE_FILE_SUBTYPE);if(!_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].hasPrefix(address,initiativeFilePrefix)){return null;}const parts=_core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].toParts(address);const remoteUrl=parts[4];const fileName=parts[5];return\"\".concat(remoteUrl,\"/\").concat(fileName);}// Creates the InitiativeId for an InitiativeFile.\nfunction initiativeFileId(_ref,fileName){let{remoteUrl}=_ref;return Object(_initiative__WEBPACK_IMPORTED_MODULE_2__[\"createId\"])(INITIATIVE_FILE_SUBTYPE,remoteUrl,fileName);}\n\n//# sourceURL=webpack:///./src/plugins/initiatives/initiativeFile.js?");

/***/ }),

/***/ "./src/plugins/initiatives/initiativesDirectory.js":
/*!*********************************************************!*\
  !*** ./src/plugins/initiatives/initiativesDirectory.js ***!
  \*********************************************************/
/*! exports provided: loadDirectory, _validatePath, _findFiles, _readFiles, _validateUrl, _convertToInitiatives, _createReferenceMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadDirectory\", function() { return loadDirectory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_validatePath\", function() { return _validatePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_findFiles\", function() { return _findFiles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_readFiles\", function() { return _readFiles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_validateUrl\", function() { return _validateUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_convertToInitiatives\", function() { return _convertToInitiatives; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_createReferenceMap\", function() { return _createReferenceMap; });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs-extra */ \"fs-extra\");\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs_extra__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var globby__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! globby */ \"globby\");\n/* harmony import */ var globby__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(globby__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _util_timestamp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/timestamp */ \"./src/util/timestamp.js\");\n/* harmony import */ var _edgeSpec__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./edgeSpec */ \"./src/plugins/initiatives/edgeSpec.js\");\n/* harmony import */ var _core_references__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/references */ \"./src/core/references/index.js\");\n/* harmony import */ var _initiative__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./initiative */ \"./src/plugins/initiatives/initiative.js\");\n/* harmony import */ var _initiativeFile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./initiativeFile */ \"./src/plugins/initiatives/initiativeFile.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/storage/disk */ \"./src/core/storage/disk.js\");\n/* harmony import */ var _parseInitiative__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./parseInitiative */ \"./src/plugins/initiatives/parseInitiative.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _objectWithoutProperties(source,excluded){if(source==null)return{};var target=_objectWithoutPropertiesLoose(source,excluded);var key,i;if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++){key=sourceSymbolKeys[i];if(excluded.indexOf(key)>=0)continue;if(!Object.prototype.propertyIsEnumerable.call(source,key))continue;target[key]=source[key];}}return target;}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}/**\n * Represents an Initiatives directory.\n *\n * Initiative directories contain a set of InitiativeFiles in a `*.json` pattern.\n * Where the file name is the ID of that Initiative.\n * Additionally we require a `remoteUrl` for this directory. We expect this directory\n * to be something you can browse online. This allows us to create a ReferenceDetector.\n */ /**\n * Loads a given InitiativesDirectory.\n */async function loadDirectory(dir){// Validate input.\nconst remoteUrl=_validateUrl(dir.remoteUrl);const localPath=await _validatePath(dir.localPath);const validatedDir={remoteUrl,localPath};// Load data.\nconst fileNames=await _findFiles(localPath);const fileMap=await _readFiles(localPath,fileNames);const _initiatives=_convertToInitiatives(validatedDir,fileMap);const refMap=_createReferenceMap(_initiatives);// Create output types.\nconst repository={initiatives:()=>_initiatives};const referenceDetector=new _core_references__WEBPACK_IMPORTED_MODULE_5__[\"MappedReferenceDetector\"](refMap);return{initiatives:repository,referenceDetector};}// Checks the path exists and is a directory.\n// Returns the absolute path or throws.\nasync function _validatePath(localPath){const absPath=path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(localPath);if(!(await fs_extra__WEBPACK_IMPORTED_MODULE_1___default.a.exists(absPath))){throw new Error(\"Provided initiatives directory does not exist at: \".concat(absPath));}if(!(await fs_extra__WEBPACK_IMPORTED_MODULE_1___default.a.lstat(absPath)).isDirectory()){throw new Error(\"Provided initiatives directory is not a directory at: \".concat(absPath));}return absPath;}// Gets all *.json filenames in the given directory.\nasync function _findFiles(localPath){const absoluteFileNames=await globby__WEBPACK_IMPORTED_MODULE_2___default()(path__WEBPACK_IMPORTED_MODULE_0___default.a.join(localPath,\"*.json\"));return absoluteFileNames.map(a=>path__WEBPACK_IMPORTED_MODULE_0___default.a.basename(a));}// Reads all given filenames in the given directory, validating them as compat.\nasync function _readFiles(localPath,fileNames){const map=new Map();// Sorting to be careful about predictability.\n// The eventual output of $ReadOnlyArray<Initiative> is ordered, so we'll see\n// the order matters for equality throughout the system.\nconst sortedFileNames=[...fileNames].sort();for(const fileName of sortedFileNames){const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_9__[\"DiskStorage\"](localPath);const initiativeFile=await Object(_util_storage__WEBPACK_IMPORTED_MODULE_8__[\"loadJson\"])(storage,fileName,_parseInitiative__WEBPACK_IMPORTED_MODULE_10__[\"parser\"]);map.set(fileName,initiativeFile);}return map;}// Checks the provided URL will parse and has no trailing slashes, search or hash.\n// Returns the validated URL without trailing slashes or throws.\nfunction _validateUrl(remoteUrl){try{const url=new global.URL(remoteUrl);if(url.search){throw\"URL should not have a search component: \".concat(url.search);}if(url.hash){throw\"URL should not have a hash component: \".concat(url.hash);}return url.toString().replace(/\\/+$/,\"\");}catch(e){throw new Error(\"Provided initiatives directory URL was invalid: \".concat(remoteUrl,\"\\n\").concat(e));}}// Converts the InitiativeFiles we've read to Initiatives.\nfunction _convertToInitiatives(directory,map){const initiatives=[];for(const[fileName,initiativeFile]of map.entries()){const{timestampIso,champions,contributions,dependencies,references}=initiativeFile,partialInitiativeFile=_objectWithoutProperties(initiativeFile,[\"timestampIso\",\"champions\",\"contributions\",\"dependencies\",\"references\"]);const timestampMs=_util_timestamp__WEBPACK_IMPORTED_MODULE_3__[\"fromISO\"](timestampIso);const initiative=_objectSpread(_objectSpread({},partialInitiativeFile),{},{id:Object(_initiativeFile__WEBPACK_IMPORTED_MODULE_7__[\"initiativeFileId\"])(directory,fileName),timestampMs,champions:champions||[],contributions:Object(_edgeSpec__WEBPACK_IMPORTED_MODULE_4__[\"normalizeEdgeSpec\"])(contributions,timestampMs),dependencies:Object(_edgeSpec__WEBPACK_IMPORTED_MODULE_4__[\"normalizeEdgeSpec\"])(dependencies,timestampMs),references:Object(_edgeSpec__WEBPACK_IMPORTED_MODULE_4__[\"normalizeEdgeSpec\"])(references,timestampMs)});initiatives.push(initiative);}return initiatives;}// Creates a reference map using `initiativeFileURL`.\nfunction _createReferenceMap(initiatives){const refs=new Map();for(const{id}of initiatives){const address=Object(_initiative__WEBPACK_IMPORTED_MODULE_6__[\"addressFromId\"])(id);const url=Object(_initiativeFile__WEBPACK_IMPORTED_MODULE_7__[\"initiativeFileURL\"])(address);if(!url){throw new Error(\"BUG: Initiative doesn't return an initiativeFileURL\");}refs.set(url,address);}return refs;}\n\n//# sourceURL=webpack:///./src/plugins/initiatives/initiativesDirectory.js?");

/***/ }),

/***/ "./src/plugins/initiatives/nodeEntry.js":
/*!**********************************************!*\
  !*** ./src/plugins/initiatives/nodeEntry.js ***!
  \**********************************************/
/*! exports provided: addressForNodeEntry, normalizeNodeEntry, _titleSlug */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addressForNodeEntry\", function() { return addressForNodeEntry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeNodeEntry\", function() { return normalizeNodeEntry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_titleSlug\", function() { return _titleSlug; });\n/* harmony import */ var _core_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/graph */ \"./src/core/graph.js\");\n/* harmony import */ var _util_timestamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/timestamp */ \"./src/util/timestamp.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/initiatives/declaration.js\");\n/**\n * Represents an \"inline contribution\" node. They're called entries and named\n * by type: contribution entry, reference entry, dependency entry.\n * The generalization of this is a node entry.\n */ // Which field the NodeEntry appeared in.\nfunction addressForNodeEntry(field,id,key){return _core_graph__WEBPACK_IMPORTED_MODULE_0__[\"NodeAddress\"].append(_declaration__WEBPACK_IMPORTED_MODULE_2__[\"nodeEntryTypes\"][field].prefix,...id,key);}/**\n * Takes a NodeEntryJson and normalizes it to a NodeEntry.\n *\n * Will throw when required fields are missing. Otherwise handles default\n * values and converting ISO timestamps.\n */function normalizeNodeEntry(input,defaultTimestampMs){if(!input.title){throw new TypeError(\"Title is required for an entry, received \".concat(JSON.stringify(input)));}return{key:input.key||_titleSlug(input.title),title:input.title,timestampMs:input.timestampIso?_util_timestamp__WEBPACK_IMPORTED_MODULE_1__[\"fromISO\"](input.timestampIso):defaultTimestampMs,contributors:input.contributors||[],weight:input.weight||null};}/**\n * Creates a url-friendly-slug from the title of a NodeEntry. Useful for\n * generating a default key.\n *\n * Note: keys are not required to meet the formatting rules of this slug,\n * this is mostly for predictability and convenience of NodeAddresses.\n */function _titleSlug(title){return String(title).toLowerCase().replace(/[^a-z0-9-_]+/g,\"-\").replace(/--+/g,\"-\").replace(/^-/,\"\").replace(/-$/,\"\");}\n\n//# sourceURL=webpack:///./src/plugins/initiatives/nodeEntry.js?");

/***/ }),

/***/ "./src/plugins/initiatives/parseInitiative.js":
/*!****************************************************!*\
  !*** ./src/plugins/initiatives/parseInitiative.js ***!
  \****************************************************/
/*! exports provided: parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony import */ var _util_combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/combo */ \"./src/util/combo.js\");\n/* harmony import */ var _util_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/compat */ \"./src/util/compat.js\");\n/* harmony import */ var _initiativeFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initiativeFile */ \"./src/plugins/initiatives/initiativeFile.js\");\n/* harmony import */ var _initiativesDirectory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./initiativesDirectory */ \"./src/plugins/initiatives/initiativesDirectory.js\");\n/* harmony import */ var _util_timestamp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/timestamp */ \"./src/util/timestamp.js\");\nconst URLParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],_initiativesDirectory__WEBPACK_IMPORTED_MODULE_3__[\"_validateUrl\"]);const TimestampParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],t=>Object(_util_timestamp__WEBPACK_IMPORTED_MODULE_4__[\"toISO\"])(Object(_util_timestamp__WEBPACK_IMPORTED_MODULE_4__[\"fromISO\"])(t)));const CommonFields={title:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],timestampIso:TimestampParser,weight:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({incomplete:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],complete:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"]}),completed:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"boolean\"]};const NodeEntryParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({title:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],timestampIso:TimestampParser,// Conceputally should use URLParser, but we allow strings\n// as part of a hack fix to https://github.com/sourcecred/sourcecred/issues/1807\ncontributors:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"])},{key:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],weight:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"]});const EdgeSpecParser=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({},{urls:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](URLParser),entries:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](NodeEntryParser)});const Parse_020=_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"](CommonFields,{contributions:EdgeSpecParser,dependencies:EdgeSpecParser,references:EdgeSpecParser,// Conceputally should use URLParser, but we allow strings\n// as part of a hack fix to https://github.com/sourcecred/sourcecred/issues/1807\nchampions:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"])});const Parse_010=(()=>{return _util_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"](CommonFields,{contributions:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](URLParser),dependencies:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](URLParser),references:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](URLParser),champions:_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"array\"](URLParser)});})();const parser=Object(_util_compat__WEBPACK_IMPORTED_MODULE_1__[\"compatibleParser\"])(_initiativeFile__WEBPACK_IMPORTED_MODULE_2__[\"COMPAT_INFO\"].type,{\"0.2.0\":Parse_020,\"0.1.0\":_util_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](Parse_010,_initiativeFile__WEBPACK_IMPORTED_MODULE_2__[\"upgradeFrom010\"])});\n\n//# sourceURL=webpack:///./src/plugins/initiatives/parseInitiative.js?");

/***/ }),

/***/ "./src/plugins/initiatives/plugin.js":
/*!*******************************************!*\
  !*** ./src/plugins/initiatives/plugin.js ***!
  \*******************************************/
/*! exports provided: InitiativesPlugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InitiativesPlugin\", function() { return InitiativesPlugin; });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/plugins/initiatives/config.js\");\n/* harmony import */ var _declaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./declaration */ \"./src/plugins/initiatives/declaration.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../analysis/pluginDeclaration */ \"./src/analysis/pluginDeclaration.js\");\n/* harmony import */ var _createGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createGraph */ \"./src/plugins/initiatives/createGraph.js\");\n/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/storage */ \"./src/util/storage.js\");\n/* harmony import */ var _initiativesDirectory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./initiativesDirectory */ \"./src/plugins/initiatives/initiativesDirectory.js\");\n/* harmony import */ var _core_weights__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/weights */ \"./src/core/weights.js\");\n/* harmony import */ var _core_storage_disk__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/storage/disk */ \"./src/core/storage/disk.js\");\nasync function loadConfig(ctx){const storage=new _core_storage_disk__WEBPACK_IMPORTED_MODULE_8__[\"DiskStorage\"](ctx.configDirectory());return Object(_util_storage__WEBPACK_IMPORTED_MODULE_5__[\"loadJson\"])(storage,\"config.json\",_config__WEBPACK_IMPORTED_MODULE_0__[\"parser\"]);}function getDirectoryFromContext(ctx){return Object(path__WEBPACK_IMPORTED_MODULE_2__[\"join\"])(ctx.configDirectory(),\"initiatives\");}class InitiativesPlugin{async declaration(){return _declaration__WEBPACK_IMPORTED_MODULE_1__[\"declaration\"];}// We dont need to load any data since all the initiative files are on disk\nasync load(){}async graph(ctx,rd){const{remoteUrl}=await loadConfig(ctx);const localPath=getDirectoryFromContext(ctx);const{initiatives}=await Object(_initiativesDirectory__WEBPACK_IMPORTED_MODULE_6__[\"loadDirectory\"])({remoteUrl,localPath});const{graph,weights}=Object(_createGraph__WEBPACK_IMPORTED_MODULE_4__[\"createWeightedGraph\"])(initiatives,rd);const declarationWeights=Object(_analysis_pluginDeclaration__WEBPACK_IMPORTED_MODULE_3__[\"weightsForDeclaration\"])(_declaration__WEBPACK_IMPORTED_MODULE_1__[\"declaration\"]);const combinedWeights=_core_weights__WEBPACK_IMPORTED_MODULE_7__[\"merge\"]([weights,declarationWeights]);return{graph,weights:combinedWeights};}async referenceDetector(ctx){const{remoteUrl}=await loadConfig(ctx);const localPath=getDirectoryFromContext(ctx);const{referenceDetector}=await Object(_initiativesDirectory__WEBPACK_IMPORTED_MODULE_6__[\"loadDirectory\"])({remoteUrl,localPath});return referenceDetector;}async identities(){// Initiatives plugin is a consumer of identities, but not a producer.\nreturn[];}}\n\n//# sourceURL=webpack:///./src/plugins/initiatives/plugin.js?");

/***/ }),

/***/ "./src/tools/entry.js":
/*!****************************!*\
  !*** ./src/tools/entry.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// Common entry point module. This module should be required by every\n// module that is intended to be run as a standalone application.\nconst util=__webpack_require__(/*! util */ \"util\");// Makes the script crash on unhandled rejections instead of silently\n// ignoring them. In the future, promise rejections that are not handled will\n// terminate the Node.js process with a non-zero exit code.\nprocess.on(\"unhandledRejection\",err=>{const details=util.inspect(err,{showHidden:true,depth:null});console.error(details);throw err;});\n\n//# sourceURL=webpack:///./src/tools/entry.js?");

/***/ }),

/***/ "./src/util sync recursive":
/*!***********************!*\
  !*** ./src/util sync ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src/util sync recursive\";\n\n//# sourceURL=webpack:///./src/util_sync?");

/***/ }),

/***/ "./src/util/batch.js":
/*!***************************!*\
  !*** ./src/util/batch.js ***!
  \***************************/
/*! exports provided: batchArray, batchIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"batchArray\", function() { return batchArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"batchIterator\", function() { return batchIterator; });\n/**\nReturns an array of arrays that contains all of the items in the original\narray parameter, but batched into arrays no larger than the batchSize.\nExample:\n  batch([1,2,3,4,5], 2) = [[1,2], [3,4], [5]]\n*/function batchArray(array,batchSize){if(batchSize<1)throw new Error(\"BatchSize must be 1 or more.\");const result=[];const backlog=array.slice();while(backlog.length){result.push(backlog.splice(0,batchSize));}return result;}/**\nReturns an iterator that will stop upon reaching the batchSize, and then can be\nreused again for more batches. Use the provided hasNext() method to know when\nthere are no more batches available.\nExample:\n  const result = [];\n  while (iterator.hasNext()) {\n    for (const item of iterator) {\n      // code to process item\n    }\n    // code to finalize batch\n  }\n */function batchIterator(iterator,batchSize){if(batchSize<1)throw new Error(\"BatchSize must be 1 or more.\");let itemsCompletedInCurrentBatch=0;let queue=iterator.next();let _hasNext=!queue.done;let batchesCompleted=0;const next=()=>{if(queue.done)return queue;if(itemsCompletedInCurrentBatch>=batchSize){itemsCompletedInCurrentBatch=0;batchesCompleted++;return{value:undefined,done:true};}itemsCompletedInCurrentBatch++;const current=queue;queue=iterator.next();_hasNext=!queue.done;if(queue.done)batchesCompleted++;return current;};const result={next,hasNext:()=>_hasNext,numBatchesCompleted:()=>batchesCompleted,[\"@@iterator\"]:()=>this,*[Symbol.iterator](){for(let r;!(r=next()).done;)yield r.value;}};return result;}\n\n//# sourceURL=webpack:///./src/util/batch.js?");

/***/ }),

/***/ "./src/util/buildObject.js":
/*!*********************************!*\
  !*** ./src/util/buildObject.js ***!
  \*********************************/
/*! exports provided: buildObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildObject\", function() { return buildObject; });\n/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clonedeep */ \"lodash.clonedeep\");\n/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__);\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\nA type-friendly way to add optional attributes to an object.\nUseful for building minimal objects for clean output, such as when transforming\nand writing configs.\n\nAttributes from the `optionals` parameter will only be added if their value\nis not in the `exclusions` parameter.\nIt is recommended to define T explicitly when using this.\n\nExamples:\nbuildObject<{| s: string, n?: number}>({s: \"test\"}, {n: 1})\n  returns {s: \"test\", n: 1}\nbuildObject<{| s: string, n?: number}>({s: \"test\"}, {n: undefined})\n  returns {s: \"test\"}\nbuildObject<{| s: string, n?: number}>({s: \"test\"}, {n: 1}, [1])\n  returns {s: \"test\"}\n*/function buildObject(required,optionals){let exclusions=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[undefined];let config=lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0___default()(required);for(const[key,value]of Object.entries(optionals)){if(!exclusions.includes(value))config=_objectSpread(_objectSpread({},config),{},{[key]:lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0___default()(value)});}return config;}\n\n//# sourceURL=webpack:///./src/util/buildObject.js?");

/***/ }),

/***/ "./src/util/combo.js":
/*!***************************!*\
  !*** ./src/util/combo.js ***!
  \***************************/
/*! exports provided: Parser, string, number, integer, boolean, null_, raw, pure, exactly, fmap, orElse, array, rename, object, shape, tuple, dict, delimited */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parser\", function() { return Parser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"string\", function() { return string; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"number\", function() { return number; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"integer\", function() { return integer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"boolean\", function() { return boolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"null_\", function() { return null_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"raw\", function() { return raw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pure\", function() { return pure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactly\", function() { return exactly; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fmap\", function() { return fmap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"orElse\", function() { return orElse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"array\", function() { return array; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rename\", function() { return rename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"object\", function() { return object; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shape\", function() { return shape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tuple\", function() { return tuple; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dict\", function() { return dict; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"delimited\", function() { return delimited; });\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}// Simple parser combinator library for structured types rather than\n// bytestring parsing.\nclass Parser{// Phantom data for the output type of this parser. Used to more\n// reliably match on parsers at the type level, via `$PropertyType`\n// rather than `$Call`. Not populated at runtime; do not dereference.\nconstructor(f){_defineProperty(this,\"_f\",void 0);_defineProperty(this,\"_phantomT\",void 0);this._f=f;}parse(raw){return this._f(raw);}parseOrThrow(raw){const result=this.parse(raw);if(result.ok){return result.value;}else{throw new Error(result.err);}}fmap(f){return fmap(this,f);}}// Helper type to extract the underlying type of a parser: for instance,\n// `ParserOutput<Parser<string>>` is just `string`.\n// Helper to make a successful parse result. For readability.\nfunction success(t){return{ok:true,value:t};}// Helper to make a failed parse result. For readability.\nfunction failure(err){return{ok:false,err};}// Helper to nicely render a JSON object's typename, accounting for\n// nulls and arrays.\nfunction typename(x){if(x===null){return\"null\";}if(Array.isArray(x)){return\"array\";}return typeof x;}const string=new Parser(x=>{if(typeof x!==\"string\"){return failure(\"expected string, got \"+typename(x));}return success(x);});const number=new Parser(x=>{if(typeof x!==\"number\"){return failure(\"expected number, got \"+typename(x));}return success(x);});const integer=new Parser(x=>{if(typeof x!==\"number\"||Math.floor(x)!==x){return failure(\"expected integer, got \"+typename(x));}return success(x);});const boolean=new Parser(x=>{if(typeof x!==\"boolean\"){return failure(\"expected boolean, got \"+typename(x));}return success(x);});// Parser that only accepts a literal `null`. (Called `null_` rather\n// than `null` to avoid conflicting with keyword.)\nconst null_=new Parser(x=>{if(x!==null){return failure(\"expected null, got \"+typename(x));}return success(x);});// The identity operation: a parser that always succeeds, emitting a\n// `JsonObject` (not `any`) with the input. Used when you need a parser\n// that matches anything:\n//\n//    // Accepts an arbitrary heterogeneous array and returns its length\n//    C.fmap(C.array(C.raw), (a) => a.length)\n//\n//    // Accepts a config file with dynamic plugin-specific data\n//    C.object({version: string, pluginConfig: C.dict(C.raw)})\n//\n// To destructure the parsed value dynamically, pair with `fmap`.\nconst raw=new Parser(success);// Lift a plain value into a parser that always returns that value,\n// ignoring its input.\nfunction pure(t){return new Parser(_=>success(t));}// Create a parser that accepts any value from a fixed set. This can be\n// used for enumerated values in configs:\n//\n//    type Environment = \"dev\" | \"prod\";\n//    const p: C.Parser<Environment> = C.exactly([\"dev\", \"prod\"]);\n//\n// This function only supports value types. Performing an `any`-cast\n// guarded by a deep equality check would be unsound, breaking opaque\n// type boundaries: e.g., a module could `export opaque type T = {}` and\n// provide two constants `ONE = {}` and `TWO = {}` (different objects),\n// and then expect that any value of type `T` would be identical to\n// either `ONE` or `TWO`. Using strict reference equality for array and\n// object types would be sound, but would not usually be what was\n// wanted, as it wouldn't match ~any actual output of `JSON.parse`.\nfunction exactly(ts){return new Parser(x=>{for(const t of ts){if(x===t){return success(t);}}const expected=ts.length===1?String(ts[0]):\"one of \".concat(JSON.stringify(ts));return failure(\"expected \".concat(expected,\", got \").concat(typename(x)));});}// Transform the output of a parser with a pure function. For instance,\n// if `p: Parser<number>` and `f = (n: number) => n % 2 === 0`, then\n// `fmap(p, f)` is a `Parser<boolean>` that first uses `p` to parse its\n// input to a number and then checks whether the number is even.\n//\n// If the function `f` throws, the thrown value will be converted to\n// string and returned as a parse error. (The string conversion takes\n// `e.message` if the thrown value `e` is an `Error`, else just converts\n// with the `String` builtin.)\n//\n// This can be used for \"strong validation\". If `U` is a (possibly\n// opaque) subtype of `T`, and `f: (T) => U` is a checked downcast that\n// either returns a `U` or throws an error, then `fmap` can transform a\n// `Parser<T>` into a validating `Parser<U>`, where the fact that the\n// validation has been performed is encoded at the type level. Thus:\n//\n//    import * as C from \".../combo\";\n//    import {NodeAddress, type NodeAddressT} from \".../core/graph\";\n//\n//    const addressParser: Parser<NodeAddressT> =\n//      C.fmap(C.array(C.string), NodeAddress.fromParts);\n//\n// As a degenerate case, it can also be used for \"weak validation\",\n// where the types `T` and `U` are the same and the function `f` simply\n// returns its argument or throws, but in this case there is nothing\n// preventing a user of a `Parser<T>` from simply forgetting to\n// validate. Prefer strong validation when possible.\nfunction fmap(p,f){return new Parser(x=>{const maybeT=p.parse(x);if(!maybeT.ok){return failure(maybeT.err);}const t=maybeT.value;let u;try{u=f(t);}catch(e){if(e instanceof Error){return failure(e.message);}else{return failure(String(e));}}return success(u);});}// replacer for stringify.JSON, in order to replace empty array with just `[]`.\n//\n// this replacer function can be extended and universally be used with other\n// aspect like empty objects.\nfunction emptyArrayReplacer(key,value){// check if the array is empty.\nif(Array.isArray(value)&&value.length===0){return[];}return value;}// Create a parser that tries each of the given parsers on the same\n// input, taking the first successful parse or failing if all parsers\n// fail. In the failure case, the provided `errorFn` will be called with\n// the error messages from all the sub-parsers to form the resulting\n// error; the default error function includes the full text of all the\n// error messages, but a user-supplied error function may act with\n// domain-specific precision.\n//\n// One use case is for parsing unions, including discriminated unions:\n//\n//    type Expr =\n//      | {|+type: \"CONSTANT\", +value: number|}\n//      | {|+type: \"VARIABLE\", +name: string|};\n//    const exprParser: C.Parser<Expr> = C.orElse([\n//      C.fmap(C.number, (value) => ({type: \"CONSTANT\", value})),\n//      C.fmap(C.string, (name) => ({type: \"VARIABLE\", name})),\n//    ]);\n//\n// Another is to use `pure` to provide a default value:\n//\n//    const lenientNumber: C.Parser<number | \"(unknown)\"> = C.orElse([\n//      C.number,\n//      C.pure(\"(unknown)\"),\n//    ]);\n//\n// This last parser will always succeed, because `C.pure(v)` always\n// succeeds and always returns `v`.\nfunction orElse(parsers){let errorFn=arguments.length>1&&arguments[1]!==undefined?arguments[1]:errors=>\"no parse matched: \".concat(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(errors,{replacer:emptyArrayReplacer,spacer:4}));return new Parser(x=>{const errors=[];for(const parser of parsers){const result=parser.parse(x);if(result.ok){return success(result.value);}else{errors.push(result.err);}}return failure(errorFn(errors));});}function array(p){return new Parser(x=>{if(!Array.isArray(x)){return failure(\"expected array, got \"+typename(x));}const result=Array(x.length);for(let i=0;i<result.length;i++){const raw=x[i];const parsed=p.parse(raw);if(!parsed.ok){return failure(\"index \".concat(i,\": \").concat(parsed.err));}result[i]=parsed.value;}return success(result);});}// Fields for an object type. Each is either a bare parser or the result\n// of `rename(\"oldFieldName\", p)` for a parser `p`, to be used when the\n// field name in the output type is to be different from the field name\n// in the input type.\nfunction rename(oldKey,parser){return new RenameFieldImpl(oldKey,parser);}class RenameFieldImpl extends Parser{constructor(oldKey,parser){super(parser._f);_defineProperty(this,\"oldKey\",void 0);this.oldKey=oldKey;}}// Parser combinator for an object type all of whose fields are\n// required.\n// Create a parser for an object type, with required fields and\n// (optionally) optional fields. The returned parser will silently drop\n// extraneous fields on values that it parses, to facilitate forward and\n// backward compatibility.\nconst object=function object(requiredFields,optionalFields){const newKeysSeen=new Set();const fields=[];const fieldsets=[{inputFields:requiredFields,required:true},{inputFields:optionalFields||{},required:false}];for(const{inputFields,required}of fieldsets){for(const newKey of Object.keys(inputFields)){const parser=inputFields[newKey];if(newKeysSeen.has(newKey)){throw new Error(\"duplicate key: \"+JSON.stringify(newKey));}newKeysSeen.add(newKey);const oldKey=parser instanceof RenameFieldImpl?parser.oldKey:newKey;fields.push({oldKey,newKey,parser,required});}}return new Parser(x=>{if(typeof x!==\"object\"||Array.isArray(x)||x==null){return failure(\"expected object, got \"+typename(x));}const result={};for(const{oldKey,newKey,parser,required}of fields){const raw=x[oldKey];if(raw===undefined){if(required){return failure(\"missing key: \"+JSON.stringify(oldKey));}else{continue;}}const parsed=parser.parse(raw);if(!parsed.ok){return failure(\"key \".concat(JSON.stringify(oldKey),\": \").concat(parsed.err));}result[newKey]=parsed.value;}return success(result);});};// Create a parser for an object type all of whose fields are optional.\n// Shorthand for `object` with an empty first argument.\nconst shape=function shape(fields){return object({},fields);};// Create a parser for a tuple: a fixed-length array with possibly\n// heterogeneous element types. For instance,\n//\n//    C.tuple([C.string, C.number, C.boolean])\n//\n// is a parser that accepts length-3 arrays whose first element is a\n// string, second element is a number, and third element is a boolean.\nfunction tuple(parsers){const ps=Array.from(parsers);return new Parser(x=>{if(!Array.isArray(x)){return failure(\"expected array, got \"+typename(x));}if(x.length!==ps.length){return failure(\"expected array of length \".concat(ps.length,\", got \").concat(x.length));}const result=Array(ps.length);for(let i=0;i<result.length;i++){const raw=x[i];const parser=ps[i];const parsed=parser.parse(raw);if(!parsed.ok){return failure(\"index \".concat(i,\": \").concat(parsed.err));}result[i]=parsed.value;}return success(result);});}// Parser combinator for a dictionary whose keys are arbitrary strings.\n// Create a parser for objects with arbitrary string keys and\n// homogeneous values. For instance, a set of package versions:\n//\n//    {\"better-sqlite3\": \"^7.0.0\", \"react\": \"^16.13.0\"}\n//\n// might be parsed by the following parser:\n//\n//    C.dict(C.fmap(C.string, (s) => SemVer.parse(s)))\n//\n// Objects may have any number of entries, including zero.\n//\n// An optional second argument may be passed to refine the keys to a\n// subtype of `string`, such as an opaque subtype (`NodeAddressT`) or a\n// string enum (`\"ONE\" | \"TWO\"`). Fails if the key parser gives the same\n// output for two distinct keys.\nconst dict=function dict(valueParser){let keyParser=arguments.length>1&&arguments[1]!==undefined?arguments[1]:string;return new Parser(x=>{if(typeof x!==\"object\"||Array.isArray(x)||x==null){return failure(\"expected object, got \"+typename(x));}const rawKeys=new Map();const result={};for(const rawKey of Object.keys(x)){const parsedKey=keyParser.parse(rawKey);if(!parsedKey.ok){return failure(\"key \".concat(JSON.stringify(rawKey),\": \").concat(parsedKey.err));}const oldRawKey=rawKeys.get(parsedKey.value);if(oldRawKey!=null){const s=JSON.stringify;return failure(\"conflicting keys \".concat(s(oldRawKey),\" and \").concat(s(rawKey),\" \")+\"both have logical key \".concat(s(parsedKey.value)));}rawKeys.set(parsedKey.value,rawKey);const rawValue=x[rawKey];const parsedValue=valueParser.parse(rawValue);if(!parsedValue.ok){return failure(\"value \".concat(JSON.stringify(rawKey),\": \").concat(parsedValue.err));}result[parsedKey.value]=parsedValue.value;}return success(result);});};const delimited=delimiter=>fmap(string,s=>s.split(delimiter)[0]);\n\n//# sourceURL=webpack:///./src/util/combo.js?");

/***/ }),

/***/ "./src/util/compat.js":
/*!****************************!*\
  !*** ./src/util/compat.js ***!
  \****************************/
/*! exports provided: toCompat, fromCompat, compatibleParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toCompat\", function() { return toCompat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromCompat\", function() { return fromCompat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compatibleParser\", function() { return compatibleParser; });\n/* harmony import */ var _combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./combo */ \"./src/util/combo.js\");\nfunction toCompat(compatInfo,obj){return[compatInfo,obj];}/**\n * Load an object from compatibilized state created by `toCompat`.\n * The object has an expected type and version, and may optionally have\n * handler functions for transforming previous versions into a canonical state.\n * If a handler is present for the current version, it will be applied.\n * Throws an error if the compatibilized object is the wrong type, or if its version\n * is not current and there was no handler for its version.\n */function fromCompat(expectedCompatInfo,obj,handlers){if(!Array.isArray(obj)||obj.length!==2){throw new Error(\"Tried to load object that didn't have compatibility defined\");}const{type,version}=obj[0];let result=obj[1];const{type:expectedType,version:expectedVersion}=expectedCompatInfo;if(type!==expectedType){throw new Error(\"Expected type to be \".concat(expectedType,\" but got \").concat(type));}if(handlers!=null&&handlers[version]!=null){result=handlers[version](result);}else if(version!==expectedVersion){throw new Error(\"\".concat(type,\": tried to load unsupported version \").concat(version));}return result;}const headerParser=_combo__WEBPACK_IMPORTED_MODULE_0__[\"object\"]({type:_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],version:_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"]});const wrappedParser=_combo__WEBPACK_IMPORTED_MODULE_0__[\"tuple\"]([headerParser,_combo__WEBPACK_IMPORTED_MODULE_0__[\"raw\"]]);function compatibleParser(expectedType,handlers){return new _combo__WEBPACK_IMPORTED_MODULE_0__[\"Parser\"](x=>{const wrapResult=wrappedParser.parse(x);if(!wrapResult.ok){return{ok:false,err:\"unable to unwrap compatible: \".concat(wrapResult.err)};}const[{type,version},raw]=wrapResult.value;if(type!==expectedType){return{ok:false,err:\"expected type \\\"\".concat(expectedType,\"\\\" but got \\\"\").concat(type,\"\\\"\")};}if(!Object.prototype.hasOwnProperty.call(handlers,version)){return{ok:false,err:\"no \\\"\".concat(type,\"/\").concat(version,\"\\\" handler\")};}const parseResult=handlers[version].parse(raw);if(parseResult.ok){return parseResult;}else{return{ok:false,err:\"\".concat(type,\"/\").concat(version,\": \").concat(parseResult.err)};}});}\n\n//# sourceURL=webpack:///./src/util/compat.js?");

/***/ }),

/***/ "./src/util/dedent.js":
/*!****************************!*\
  !*** ./src/util/dedent.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return dedent; });\n/*\n * A template tag function that performs dedenting on the template, but\n * not its arguments.\n *\n * For instance, given the template\n *\n *     |dedent`\\\n *     |    one ${one}\n *     |        two ${two}\n *     |    done`,\n *\n * where `one === \"1\"` and `two === \"\\n    2\"`, the template string\n * would expand to \"one 1\\n    two\\n    2\\ndone\". Note that four spaces\n * of indentation were stripped off of each of \"one\" and \"two\", but not\n * from \"2\".\n *\n * Lines that contain only whitespace are not used for measuring.\n */function dedent(strings){const lineLengths=strings.join(\"\").split(\"\\n\").filter(line=>line.trim().length!==0).map(line=>line.length-line.trimLeft().length);const trimAmount=Math.min.apply(null,lineLengths);const parts=[];for(let i=0;i<strings.length;i++){const trimmed=strings[i].split(\"\\n\").map((line,j)=>i===0||j>0?line.substr(trimAmount):line).join(\"\\n\");parts.push(trimmed);if(i<(arguments.length<=1?0:arguments.length-1)){parts.push(i+1<1||arguments.length<=i+1?undefined:arguments[i+1]);}}return parts.join(\"\");}\n\n//# sourceURL=webpack:///./src/util/dedent.js?");

/***/ }),

/***/ "./src/util/disk.js":
/*!**************************!*\
  !*** ./src/util/disk.js ***!
  \**************************/
/*! exports provided: mkdirx, isDirEmpty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mkdirx\", function() { return mkdirx; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDirEmpty\", function() { return isDirEmpty; });\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs-extra */ \"fs-extra\");\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs_extra__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Make a directory, if it doesn't already exist.\n */function mkdirx(path){try{fs_extra__WEBPACK_IMPORTED_MODULE_0___default.a.mkdirSync(path);}catch(e){if(e.code!==\"EEXIST\"){throw e;}}}/**\n * Check if a directory is empty\n *\n * Will error if a path that resolves to anything other\n * than a directory is provided\n */function isDirEmpty(dirPath){return fs_extra__WEBPACK_IMPORTED_MODULE_0___default.a.readdirSync(dirPath).length===0;}\n\n//# sourceURL=webpack:///./src/util/disk.js?");

/***/ }),

/***/ "./src/util/findDuplicates.js":
/*!************************************!*\
  !*** ./src/util/findDuplicates.js ***!
  \************************************/
/*! exports provided: findDuplicates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findDuplicates\", function() { return findDuplicates; });\n/**\n * Finds elements in the array which are included twice or more.\n * Uses a === comparison, not deep equality.\n */function findDuplicates(items){const encountered=new Set();const duplicates=new Set();for(const item of items){if(!encountered.has(item)){encountered.add(item);}else{duplicates.add(item);}}return duplicates;}\n\n//# sourceURL=webpack:///./src/util/findDuplicates.js?");

/***/ }),

/***/ "./src/util/getRandomValues.js":
/*!*************************************!*\
  !*** ./src/util/getRandomValues.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getRandomValues; });\n/*\n * API shim for `window.crypto.getRandomValues` in the browser, for\n * compatibility with browser, Node, Jest, and Observable.\n *\n * Forked from NPM `get-random-bytes` by Kenan Yildirim, which is\n * released under the MIT License.\n */ /**\n * Fill the given buffer with cryptographically secure random bytes. The\n * buffer length must not exceed 65536.\n */function getRandomValues(buf){if(typeof window!==\"undefined\"){if(window.crypto&&window.crypto.getRandomValues){return window.crypto.getRandomValues(buf);}if(typeof window.msCrypto===\"object\"&&typeof window.msCrypto.getRandomValues===\"function\"){return window.msCrypto.getRandomValues(buf);}}if(true){// Late-import `crypto` to avoid `require` in Observable notebooks,\n// and avoid using a literal `require(...)` to prevent Webpack from\n// rewriting this. (Getting Webpack externals to work properly is\n// daunting.)\n//\n/* eslint-disable camelcase */ /* eslint-disable no-undef */const realRequire=// $FlowExpectedError[cannot-resolve-name]\ntypeof require!==\"undefined\"?require:__webpack_require__(\"./src/util sync recursive\");/* needed for Jest */const nodeCrypto=realRequire(\"crypto\");if(buf.length>65536){const e=new Error();e.code=22;e.message=\"Quota exceeded: requested \".concat(buf.length,\" > 65536 bytes\");e.name=\"QuotaExceededError\";throw e;}const bytes=nodeCrypto.randomBytes(buf.length);buf.set(bytes);return buf;}throw new Error(\"No secure random number generator available.\");}\n\n//# sourceURL=webpack:///./src/util/getRandomValues.js?");

/***/ }),

/***/ "./src/util/jsonLog.js":
/*!*****************************!*\
  !*** ./src/util/jsonLog.js ***!
  \*****************************/
/*! exports provided: JsonLog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JsonLog\", function() { return JsonLog; });\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-stable-stringify */ \"json-stable-stringify\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _combo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./combo */ \"./src/util/combo.js\");\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * JsonLog tracks and serializes append-only logs of JSON values.\n *\n * At its heart, it's basically a simple wrapper around an array, which\n * enforces the rule that items may be appended to it, but never removed.\n *\n * It also provides serialization logic. We store the log as a\n * newline-delimited stream of JSON values, with a one-to-one correspondence\n * between POSIX lines and elements in the sequence. That is, the serialized\n * form of an element will never contain an embedded newline, and there are no\n * empty lines. JSON streams can be easily inspected and manipulatedwith tools\n * like `jq` as well as standard Unix filters, and can be stored and\n * transmitted efficiently in Git repositories thanks to packfiles and delta\n * compression.\n *\n * Elements of a `JsonLog` are always parsed using a Combo.Parser, which\n * ensures type safety at runtime.\n */class JsonLog{constructor(){_defineProperty(this,\"_items\",void 0);this._items=[];}append(item){this._items.push(item);return this;}extend(items){for(const item of items){this._items.push(item);}return this;}values(){return this._items.values();}toString(){const lines=this._items.map(x=>json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(x)+\"\\n\");return lines.join(\"\");}static fromString(log,parser){const result=new JsonLog();_extractLogLines(log).forEach((line,i)=>{let parsed;try{parsed=parser.parse(JSON.parse(line));}catch(e){throw new Error(\"line \".concat(i+1,\" is not valid JSON: \").concat(e));}if(parsed.ok){result.append(parsed.value);}else{throw new Error(\"line \".concat(i+1,\": \").concat(parsed.err));}});return result;}}function _extractLogLines(log){// In the legacy format, all automatically written ledgers erroneously\n// lacked trailing LF, but some hand-edited ones have them. In the new\n// format, all automatically written ledgers include a trailing LF.\n// Strip it, if present, for ease of `split(\"\\n\")`.\nlog=log.trimRight();// If the file is empty, return no entries to parse\nif(log.length===0){return[];}if(log.startsWith(\"[\")){// Temporarily compatibility measure for raw JSON arrays (not NDJSON),\n// in the specific form written by previous versions of this module.\nif(log===\"[]\"){return[];}const dataLines=log.split(\"\\n\").slice(1,-1);return dataLines.map(line=>line.endsWith(\",\")?line.slice(0,-1):line);}return log.split(\"\\n\");}\n\n//# sourceURL=webpack:///./src/util/jsonLog.js?");

/***/ }),

/***/ "./src/util/map.js":
/*!*************************!*\
  !*** ./src/util/map.js ***!
  \*************************/
/*! exports provided: toObject, fromObject, copy, mapKeys, mapValues, mapEntries, merge, pushValue, mapToArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toObject\", function() { return toObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromObject\", function() { return fromObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapKeys\", function() { return mapKeys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapValues\", function() { return mapValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapEntries\", function() { return mapEntries; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"merge\", function() { return merge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pushValue\", function() { return pushValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapToArray\", function() { return mapToArray; });\n/**\n * Convert a string-keyed map to an object. Useful for conversion to\n * JSON. If a map's keys are not strings, consider invoking `mapKeys`\n * first.\n */function toObject(map){const result={};for(const[k,v]of map.entries()){result[k]=v;}return result;}/**\n * Convert an object to a map. The resulting map will have key-value\n * pairs corresponding to the enumerable own properties of the object in\n * iteration order, as returned by `Object.keys`.\n */function fromObject(object){const result=new Map();const keys=Object.keys(object);for(const key of keys){result.set(key,object[key]);}return result;}/**\n * Shallow-copy a map, allowing upcasting its type parameters.\n *\n * The `Map` type constructor is not covariant in its type parameters,\n * which means that (e.g.) `Map<string, Dog>` is not a subtype of\n * `Map<string, Animal>` even if `Dog` is a subtype of `Animal`. This is\n * because, given a `Map<string, Animal>`, one can insert a `Cat`, which\n * would break invariants of existing references to the variable as a\n * map containing only `Dog`s.\n *\n *     declare class Animal {};\n *     declare class Dog extends Animal {};\n *     declare class Cat extends Animal {};\n *     declare var dogMap: Map<string, Dog>;\n *     const animalMap: Map<string, Animal> = dogMap;  // must fail\n *     animalMap.set(\"tabby\", new Cat());  // or we could do this...\n *     (dogMap.values(): Iterator<Dog>);  // ...now contains a `Cat`!\n *\n * This problem only exists when a map with existing references is\n * mutated. Therefore, when we shallow-copy a map, we have the\n * opportunity to upcast its type parameters: `copy(dogMap)` _can_ be a\n * `Map<string, Animal>`.\n */function copy(map){const entries=map.entries();return new Map(entries);}/**\n * Map across the keys of a map. Note that the key-mapping function is\n * provided both the key and the value for each entry.\n *\n * The key-mapping function must be injective on the map's key set. If\n * it maps two distinct input keys to the same output key, an error may\n * be thrown.\n */function mapKeys(map,f){const result=new Map();for(const[k,v]of map.entries()){const outK=f(k,v);if(result.has(outK)){throw new Error(\"duplicate key: \"+String(outK));}result.set(outK,v);}return result;}/**\n * Map across the values of a map. Note that the value-mapping function\n * is provided both the key and the value for each entry.\n *\n * There are no restrictions on the value-mapping function (in\n * particular, it need not be injective).\n */function mapValues(map,g){const result=new Map();for(const[k,v]of map.entries()){result.set(k,g(k,v));}return result;}/**\n * Map simultaneously across the keys and values of a map.\n *\n * The key-mapping function must be injective on the map's key set. If\n * it maps two distinct input keys to the same output key, an error may\n * be thrown. There are no such restrictions on the value-mapping\n * function.\n */function mapEntries(map,h){const result=new Map();for(const[k,v]of map.entries()){const[outK,outV]=h(k,v);if(result.has(outK)){throw new Error(\"duplicate key: \"+String(outK));}result.set(outK,outV);}return result;}/**\n * Merge maps without mutating the arguments.\n *\n * Merges multiple maps, returning a new map which has every key from\n * the source maps, with their corresponding values. None of the inputs\n * are mutated. In the event that multiple maps have the same key, an\n * error will be thrown.\n */function merge(maps){const result=new Map();let updates=0;for(const map of maps){for(const[key,value]of map.entries()){result.set(key,value);if(result.size!==++updates){throw new Error(\"Maps have duplicate key: \".concat(String(key)));}}}return result;}/**\n * Given a map whose values are arrays, push an element onto the array\n * corresponding to the given key. If the key is not in the map, first\n * insert it with value a new empty array.\n *\n * If the key is already in the map, its value will be mutated, not\n * replaced.\n */function pushValue(map,key,value){let arr=map.get(key);if(arr==null){map.set(key,arr=[]);}arr.push(value);return arr;}/**\n * Given a Map, transform its entries into an Array using a\n * provided transformer function.\n */function mapToArray(map,fn){return Array.from(map.entries()).map(fn);}\n\n//# sourceURL=webpack:///./src/util/map.js?");

/***/ }),

/***/ "./src/util/null.js":
/*!**************************!*\
  !*** ./src/util/null.js ***!
  \**************************/
/*! exports provided: map, get, orThrow, orElse, filterList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"orThrow\", function() { return orThrow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"orElse\", function() { return orElse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filterList\", function() { return filterList; });\n/**\n * Utilities for working with nullable types: `?T = T | null | void`.\n *\n * These functions use the native runtime representation, as opposed to\n * creating an `Optional<T>` wrapper class. This ensures that they have\n * minimal runtime cost (just a function call), and that they are\n * trivially interoperable with other code.\n *\n * When a value of type `?T` is `null` or `undefined`, we say that it is\n * _absent_. Otherwise, it is _present_.\n *\n * Some functions that typically appear in such libraries are not\n * needed:\n *\n *   - `join` (`??T => ?T`) can be implemented as the identity function,\n *     because the Flow types `??T` and `?T` are equivalent;\n *   - `flatMap` (`?T => (T => ?U) => ?U`) can be implemented simply as\n *     `map`, again because `??T` and `?T` are equivalent;\n *   - `first` (`?T => ?T => ?T`) can be implemented simply as `orElse`,\n *     again because `??T` and `?T` are equivalent;\n *   - `isPresent` (`?T => boolean`) doesn't provide much value over the\n *     equivalent abstract disequality check;\n *   - constructors like `empty` (`() => ?T`) and `of` (`T => ?T`) are\n *     entirely spurious.\n *\n * Other functions could reasonably be implemented, but have been left\n * out because they have rarely been needed:\n *\n *   - `filter` (`?T => (T => boolean) => ?T`);\n *   - `forEach` (`?T => (T => void) => void`);\n *   - `orElseGet` (`?T => (() => T) => T`), which is useful in the case\n *      where constructing the default value is expensive.\n *\n * (Of these three, `orElseGet` would probably be the most useful for\n * our existing codebase.)\n */ /**\n * Apply the given function inside the nullable. If the input is absent,\n * then it will be returned unchanged. Otherwise, the given function\n * will be applied.\n */function map(x,f){return x!=null?f(x):x;}/**\n * Extract the value from a nullable. If the input is present, it will\n * be returned. Otherwise, an error will be thrown with the provided\n * message (defaulting to the string representation of the absent input).\n */function get(x,errorMessage){if(x==null){throw new Error(errorMessage!=null?errorMessage:String(x));}else{return x;}}/**\n * Extract the value from a nullable. If the input is present, it will\n * be returned. Otherwise, an error will be thrown, with message given\n * by the provided function.\n */function orThrow(x,getErrorMessage){if(x==null){throw new Error(getErrorMessage());}else{return x;}}/**\n * Extract the value from a nullable, using the provided default value\n * in case the input is absent.\n */function orElse(x,defaultValue){return x!=null?x:defaultValue;}/**\n * Filter nulls and undefined out of an array, returning a new array.\n *\n * The functionality is easy to implement without a util method (just call\n * `filter`); however Flow doesn't infer the type of the output array based on\n * the callback that was passed to filter. This method basically wraps filter\n * in a type-aware way.\n */function filterList(xs){// A type-safe way to implement this would be:\n/*:: (xs.flatMap((x) => x == null ? [] : [x]): T[]); */ // For performance, we instead take an unsafe route.\nreturn xs.filter(x=>x!=null);}\n\n//# sourceURL=webpack:///./src/util/null.js?");

/***/ }),

/***/ "./src/util/pathNormalize.js":
/*!***********************************!*\
  !*** ./src/util/pathNormalize.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return normalize; });\n// This module reimplements Node's `require(\"path\").posix.normalize`\n// function, so that it can be bundled in the browser.\n//\n// The code is copied directly from the Node implementation in\n// `lib/path.js` at Git commit e0395247c899af101f8a1f76a8554be1ff14040a.\n// The code being copied is published under the MIT License.\n//\n// The `normalize` function and its transitive dependencies are\n// included. Flow types have been added where necessary, and the code\n// has been run through Prettier. Declarations with `var` have been\n// changed to `let` or `const`. Added comments are marked with `NOTE`.\n// The rest of the code is verbatim except where noted.\n// NOTE(@wchargin): The following documentation comment is adapted from\n// the Node documentation in `doc/api/path.md` (at the aforementioned\n// Git commit).\n/**\n * Normalize the given POSIX path, resolving \"..\" and \".\" segments.\n *\n * When multiple, sequential forward slashes are found, they are\n * replaced by a single forward slash. A trailing forward slash is\n * preserved if present, but not added if absent.\n *\n * If the path is a zero-length string, \".\" is returned, representing\n * the current working directory.\n *\n * A `TypeError` is thrown if `path` is not a string.\n */function normalize(path){assertPath(path);if(path.length===0)return\".\";const isAbsolute=path.charCodeAt(0)===CHAR_FORWARD_SLASH;const trailingSeparator=path.charCodeAt(path.length-1)===CHAR_FORWARD_SLASH;// Normalize the path\npath=normalizeString(path,!isAbsolute,\"/\",isPosixPathSeparator);if(path.length===0&&!isAbsolute)path=\".\";if(path.length>0&&trailingSeparator)path+=\"/\";if(isAbsolute)return\"/\"+path;return path;}const CHAR_DOT=46;const CHAR_FORWARD_SLASH=47;function assertPath(path){if(typeof path!==\"string\"){// NOTE(@wchargin): The exact error text used here has been changed\n// from the Node version to simplify the implementation.\nthrow new TypeError(\"Path must be a string. Received \"+String(path));}}function isPosixPathSeparator(code){return code===CHAR_FORWARD_SLASH;}// Resolves . and .. elements in a path with directory names\n// NOTE(@wchargin): This function does not do exactly what the preceding\n// comment (from the Node source) suggests. For instance, `/a/b` becomes\n// `a/b`. Caveat lector.\n// NOTE(@wchargin): PRECONDITION(A): `path` must not be empty.\n// NOTE(@wchargin): PRECONDITION(B): `separator` must be \"/\" or \"\\\\\".\n// NOTE(@wchargin): PRECONDITION(C): `isPathSeparator` must return\n//   `true` given `separator.charCodeAt(0)`.\n// NOTE(@wchargin): PRECONDITION(D): `isPathSeparator` must return\n//   `true` given `CHAR_FORWARD_SLASH`.\nfunction normalizeString(path,allowAboveRoot,separator,isPathSeparator){// NOTE(@wchargin): INVARIANT(E): `res` does not end with `separator`.\n//   Proof: By induction, at initialization and at every assignment to\n//   `res`. The base case holds because `res` is empty and `separator`\n//   is not, by PRECONDITION(B). Assignments will be justified inline.\n// NOTE(@wchargin):  INVARIANT(F): `res` does not contain two\n//   consecutive separators. Proof: By induction, at initialization and\n//   at every assignment to `res`. The base case is immediate.\n//   Assignments will be justified inline.\nlet res=\"\";let lastSegmentLength=0;// NOTE(@wchargin): INVARIANT(G): `lastSlash` is always an integer,\n//   and `i` is always an integer. Proof: By induction. The initial\n//   values of each are integers. The only assignment to `i` is to\n//   increment it (`++i` in the loop declaration), which preserves\n//   integrality. The only reassignment to `lastSlash` is to assign it\n//   the value of `i`, which is known by induction to be an integer.\n// NOTE(@wchargin): INVARIANT(H): Once the loop index `i` is\n//   initialized, it holds that `lastSlash <= i`. Proof: By induction,\n//   at initialization of `i` and at every assignment to `i` or\n//   `lastSlash`. The base case is clear: `i` is initialized to `0`,\n//   at which point `lastSlash` is `-1`. The only assignment to `i` is\n//   `++i`, which preserves the invariant. The only assignments to\n//   `lastSlash` are to set its value to `i`, which also preserve the\n//   invariant.\nlet lastSlash=-1;let dots=0;let code;// NOTE(@wchargin): INVARIANT(I): Loop invariant:\n//   `path.slice(lastSlash + 1, i)` does not contain a `separator`\n//   (once `i` has been initialized). We refer to this expression as\n//   \"the slice\". Proof: By induction: at initialization of `i`, and\n//   at every assignment to `lastSlash`, `i`, or `path`. The base case\n//   is clear: initially, the slice has domain `(0, 0)`, so is empty.\n//   Assignments will be justified inline.\n// NOTE(@wchargin): LEMMA(J): If `lastSlash` is assigned the value `i`\n//   and neither `lastSlash` nor `i` nor `path` is modified before the\n//   next iteration of the loop, then INVARIANT(I) is preserved both\n//   (a) at the assignment and (b) at the iteration boundary. Proof:\n//   At the assignment, the slice has domain `(i + 1, i)`, so is\n//   empty. After `++i`, the slice has domain `(i + 1, i + 1)`, which\n//   is still empty. The empty string does not contain a `separator`,\n//   because `separator` is non-empty by PRECONDITION(B). This is\n//   sufficient to maintain the INVARIANT(I).\n// NOTE(@wchargin): INVARIANT(K): At the top of the loop,\n//   `lastSlash < i`. Proof: By cases on the iteration of the loop.\n//   For the first iteration of the loop, `lastSlash === -1` and\n//   `i === 0`. For subsequent iterations, note that INVARIANT(H) held\n//   at the bottom of the previous iteration of the loop, before `i`\n//   was incremented: that is, the previous value of `lastSlash` was\n//   less than or equal to the previous value of `i`. Since then,\n//   `lastSlash` has not been reassigned, and `i` has been\n//   incremented, so it follows that `lastSlash <= i - 1`, and\n//   therefore `lastSlash < i`.\nfor(let i=0;i<=path.length;++i){if(i<path.length)code=path.charCodeAt(i);// NOTE(@wchargin): The following cast is required because `code`\n//   could in principle be uninitialized. However, PRECONDITION(A)\n//   requires that the input be non-empty, which means that the\n//   above guard `if (i < path.length)` will at some point have\n//   taken the `true` branch, which means that `code` will have been\n//   assigned.\n// NOTE(@wchargin): The `then`-branch has been changed from `break;`\n//   to `return res;` to help Flow deduce that, after this block,\n//   `code` must be initialized. (The change is semantics-preserving\n//   because the statement after the loop is to `return res;`.)\nelse if(isPathSeparator(code))return res;else code=CHAR_FORWARD_SLASH;if(isPathSeparator(code)){if(lastSlash===i-1||dots===1){// NOOP\n}else if(lastSlash!==i-1&&dots===2){if(res.length<2||lastSegmentLength!==2||res.charCodeAt(res.length-1)!==CHAR_DOT||res.charCodeAt(res.length-2)!==CHAR_DOT){if(res.length>2){const lastSlashIndex=res.lastIndexOf(separator);// NOTE(@wchargin): The `else`-branch of this `if`-statement\n//   is not reachable. See that branch for a proof. (The\n//   coverage pragma was added and is not present in the\n//   original Node source.)\n// istanbul ignore else\nif(lastSlashIndex!==res.length-1){if(lastSlashIndex===-1){// NOTE(@wchargin): JUSTIFICATION: This assignment\n//   trivially preserves INVARIANT(E) and INVARIANT(F).\nres=\"\";lastSegmentLength=0;}else{// NOTE(@wchargin): JUSTIFICATION: This assignment\n// preserves INVARIANT(E):\n//     - By control flow, we know that\n//       `lastSlashIndex !== -1`.\n//     - By definition of `lastIndexOf`, this means that\n//       `res` contains a `separator` at index\n//       `lastSlashIndex`.\n//     - By INVARIANT(F), `res` does not contain two\n//       consecutive `separator`s. Therefore, `res` does\n//       not contain a `separator` at index\n//       `lastSlashIndex - 1`.\n//     - Therefore, the new value for `res` does not\n//       contain a `separator` at `lastSlashIndex - 1`,\n//       so it does not end with a `separator`.\n// NOTE(@wchargin): JUSTIFICATION: This assignment\n//   preserves INVARIANT(F). By INVARIANT(F), we know\n//   inductively that `res` does not contain two\n//   consecutive `separator`s. It is immediate that no\n//   slice of `res` contains two consecutive\n//   `separator`s.\nres=res.slice(0,lastSlashIndex);lastSegmentLength=res.length-1-res.lastIndexOf(separator);}// NOTE(@wchargin): JUSTIFICATION: This assignment\n//   preserves INVARIANT(I) by LEMMA(J).\nlastSlash=i;dots=0;// NOTE(@wchargin): JUSTIFICATION: This loop boundary\n//   preserves INVARIANT(I) by LEMMA(J).\ncontinue;}else{// NOTE(@wchargin): This `else`-branch was added by\n//   @wchargin; it is not present in the original Node\n//   source. It is unreachable. Proof: INVARIANT(E)\n//   indicates that `res` does not end in a `separator`,\n//   which means that `lastSlashIndex !== res.length - 1`,\n//   which is the guard for the enclosing `if`-statement.\nthrow new Error(\"normalize: invariant violation: \"+JSON.stringify({path,allowAboveRoot,separator}));}}else if(res.length===2||res.length===1){// NOTE(@wchargin): JUSTIFICATION: This assignment trivially\n//   preserves INVARIANT(E) and INVARIANT(F).\nres=\"\";lastSegmentLength=0;// NOTE(@wchargin): JUSTIFICATION: This assignment preserves\n//   INVARIANT(I) by LEMMA(J).\nlastSlash=i;dots=0;// NOTE(@wchargin): JUSTIFICATION: This loop boundary\n//   preserves INVARIANT(I) by LEMMA(J).\ncontinue;}}if(allowAboveRoot){// NOTE(@wchargin): JUSTIFICATION: This assignment preserves\n//   INVARIANT(E) because `separator` is either \"/\" or \"\\\\\" by\n//   PRECONDITION(B), and so the new value of `res`, which\n//   ends with \".\", does not end with `separator`.\n// NOTE(@wchargin): JUSTIFICATION: This assignment preserves\n//   INVARIANT(F). We know by INVARIANT(E) that `res` does not\n//   end with a separator. Therefore, appending a `separator`\n//   does not introduce two consecutive `separator`s, and\n//   appending two copies of \".\" does not introduce two\n//   consecutive separators because, by PRECONDITION(B),\n//   `separator` is either \"/\" or \"\\\\\" and so does not contain\n//   \".\".\nif(res.length>0)res+=\"\".concat(separator,\"..\");// NOTE(@wchargin): JUSTIFICATION: This assignment preserves\n//   INVARIANT(E) and INVARIANT(F) because `separator` is\n//   either \"/\" or \"\\\\\" by PRECONDITION(B), and so does not\n//   appear in the new value for `res` at all (either at the\n//   end or twice consecutively).\nelse res=\"..\";lastSegmentLength=2;}}else{// NOTE(@wchargin): JUSTIFICATION: This assignment preserves\n// INVARIANT(D) and INVARIANT(E):\n//   - By INVARIANT(K), `lastSlash` was less than `i` at the top\n//     of the loop body. By control flow, neither `lastSlash`\n//     nor `i` has since been reassigned, so it still holds that\n//     `lastSlash < i`.\n//   - At this point in the loop body, we have not assigned to\n//     `lastSlash`.\n//   - By control flow, we also have `lastSlash !== i - 1`.\n//   - By INVARIANT(G), both `lastSlash` and `i` are integers.\n//   - Therefore, `lastSlash < i - 1`, so `lastSlash + 1 < i`.\n//     This indicates that the domain of the slice is nonempty;\n//     we still must show that it is within the bounds of the\n//     string being sliced.\n//   - By the loop guard, `i <= path.length`.\n//   - Therefore, `lastSlash + 1 < path.length`.\n//   - Therefore, `path.slice(lastSlash + 1, i)` is nonempty.\n//   - By INVARIANT(I), this slice does not contain a\n//     `separator`.\n//   - Because the slice is nonempty, the new value of `res`\n//     will end in the last character of the slice, which is not a\n//     `separator`, so INVARIANT(E) is preserved.\n//   - Because `res` does not end with a separator, appending a\n//     separator to `res` does not introduce two consecutive\n//     separators. Because the slice does not contain a\n//     separator, subsequently appending the slice also does not\n//     introduce two consecutive separators, so INVARIANT(F) is\n//     preserved.\nif(res.length>0)res+=separator+path.slice(lastSlash+1,i);// NOTE(@wchargin): JUSTIFICATION: This assignment preserves\n//   INVARIANT(E) and INVARIANT(F), because we know from\n//   INVARIANT(I) that the slice does not contain a separator at\n//   all, so the new value of `res` neither ends in a separator\n//   nor contains two consecutive separators.\nelse res=path.slice(lastSlash+1,i);lastSegmentLength=i-lastSlash-1;}// NOTE(@wchargin): JUSTIFICATION: This assignment preserves\n//   INVARIANT(I) by LEMMA(J).\nlastSlash=i;dots=0;// NOTE(@wchargin): JUSTIFICATION: This loop boundary preserves\n//   INVARIANT(I) by LEMMA(J).\n}else if(code===CHAR_DOT&&dots!==-1){++dots;// NOTE(@wchargin): JUSTIFICATION: This loop boundary preserves\n//   INVARIANT(I). We know by that `path.slice(lastSlash + 1, i)`\n//   does not contain a separator, by induction. We know from\n//   control flow that `code` is `CHAR_DOT`, so `path[i]` is not a\n//   separator. Thus, `path.slice(lastSlash + 1, i + 1)` does not\n//   contain a separator, so INVARIANT(I) holds.\n}else{dots=-1;// NOTE(@wchargin): JUSTIFICATION: This loop boundary preserves\n// INVARIANT(I):\n//   - We know that `path.slice(lastSlash + 1, i)` does not\n//     contain a separator, by induction.\n//   - We know from control flow that `!isPathSeparator(code)`.\n//   - We also know from control flow that `code` is either\n//     `path.charCodeAt(i)` or `CHAR_FORWARD_SLASH`.\n//   - PRECONDITION(D) shows that `code` cannot be\n//     `CHAR_FORWARD_SLASH`, because `!isPathSeparator(code)`, so\n//     `code` must be `path.charCodeAt(i)`.\n//   - PRECONDITION(C) shows that `code` cannot be\n//     `separator.charCodeAt(0)`.\n//   - This implies that `path[i]` is not `separator`.\n//   - Thus, `path.slice(lastSlash + 1, i + 1)` does not contain a\n//     separator, so INVARIANT(I) holds.\n}}return res;}\n\n//# sourceURL=webpack:///./src/util/pathNormalize.js?");

/***/ }),

/***/ "./src/util/retry.js":
/*!***************************!*\
  !*** ./src/util/retry.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return retry; });\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}// The outcome of a single attempt of a retryable operation.\n// The final result of executing an operation after retrying zero or more\n// times.\nfunction defaultPolicy(){return{initialDelayMs:1000,backoffRatio:2.0,jitterRatio:1.2,maxRetries:3,maxWaits:1};}/**\n * Run a retryable operation until it terminates or exhausts its retry\n * policy. If `attempt` ever rejects, this function also immediately\n * rejects with the same value.\n */async function retry(attempt,policy){let io=arguments.length>2&&arguments[2]!==undefined?arguments[2]:realIo;const fullPolicy=_objectSpread(_objectSpread({},defaultPolicy()),policy);let nextRetryDelayMs=fullPolicy.initialDelayMs;let retries=0;let waits=0;while(true){const outcome=await attempt();switch(outcome.type){case\"DONE\":return{type:\"DONE\",value:outcome.value};case\"FATAL\":return{type:\"FAILED\",err:outcome.err};case\"RETRY\":{if(retries>=fullPolicy.maxRetries){return{type:\"FAILED\",err:outcome.err};}retries++;const delayMs=nextRetryDelayMs*io.rollJitter(fullPolicy.jitterRatio);await io.sleepMs(delayMs);nextRetryDelayMs*=fullPolicy.backoffRatio;break;}case\"WAIT\":{if(waits>=fullPolicy.maxWaits){return{type:\"FAILED\",err:outcome.err};}waits++;const now=io.now();const delayMs=outcome.until-now;if(delayMs<0){const fmt=d=>\"@\".concat((+d/1000).toFixed(3));throw new Error(\"wait-until time in the past: \".concat(fmt(outcome.until),\" < \").concat(fmt(now)));}await io.sleepMs(delayMs);break;}// istanbul ignore next: unreachable per flow\ndefault:throw new Error(outcome.type);}}// istanbul ignore next: unreachable\n// ESLint knows that this next line is unreachable, but Flow doesn't. :-)\n// eslint-disable-next-line no-unreachable\nthrow new Error(\"unreachable\");}const realIo={// istanbul ignore next: impure non-test implementation\nnow(){return new Date();},// istanbul ignore next: impure non-test implementation\nsleepMs(ms){return new Promise(resolve=>{setTimeout(resolve,ms);});},// istanbul ignore next: impure non-test implementation\nrollJitter(r){return 1+Math.random()*(r-1);}};\n\n//# sourceURL=webpack:///./src/util/retry.js?");

/***/ }),

/***/ "./src/util/sortBy.js":
/*!****************************!*\
  !*** ./src/util/sortBy.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return sortBy; });\nconst identity=x=>x;/**\n * Sorting utility. Accepts an array and optionally any number of \"pluck\"\n * functions to get the value to sort by. Will create a shallow copy, and sort in ascending order.\n * - `arr`: The input array to sort\n * - `pluckArgs`: (0...n) Functions to get the value to sort by. Defaults to identity.\n */function sortBy(arr){for(var _len=arguments.length,pluckArgs=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){pluckArgs[_key-1]=arguments[_key];}const plucks=pluckArgs.length===0?[identity]:pluckArgs;function sortByCompare(a,b){for(const pluck of plucks){const valA=pluck(a);const valB=pluck(b);if(valA>valB)return 1;if(valA<valB)return-1;}return 0;}return[...arr].sort(sortByCompare);}\n\n//# sourceURL=webpack:///./src/util/sortBy.js?");

/***/ }),

/***/ "./src/util/storage.js":
/*!*****************************!*\
  !*** ./src/util/storage.js ***!
  \*****************************/
/*! exports provided: loadJson, loadJsonWithDefault, loadFileWithDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadJson\", function() { return loadJson; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadJsonWithDefault\", function() { return loadJsonWithDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadFileWithDefault\", function() { return loadFileWithDefault; });\n/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/storage */ \"./src/core/storage/index.js\");\n/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_core_storage__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/storage/textEncoding */ \"./src/core/storage/textEncoding.js\");\n/* harmony import */ var _combo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./combo */ \"./src/util/combo.js\");\nconst notFound=e=>e.code===\"ENOENT\"||e.number===404;/**\n * Load and parse a JSON file from DataStorage.\n *\n * If the file cannot be read, then an error is thrown.\n * If parsing fails, an error is thrown.\n */async function loadJson(storage,path,parser){const contents=await storage.get(path);return parser.parseOrThrow(JSON.parse(Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_1__[\"decode\"])(contents)));}/**\n * Load and parse a JSON file from DataStorage, with a default to use if the\n * file is not found.\n *\n * This is intended as a convenience for situations where the user may\n * optionally provide configuration in a json file.\n *\n * The default must be provided as a function that returns a default, to\n * accommodate situations where the object may be mutable, or where constructing\n * the default may be expensive.\n *\n * If no file is present at that location, then the default constructor is\n * invoked to create a default value, and that is returned.\n *\n * If attempting to load the file fails for any reason other than ENOENT or a\n * 404 (e.g. the path actually is a directory), then the error is thrown.\n *\n * If parsing fails, an error is thrown.\n */async function loadJsonWithDefault(storage,path,parser,def){try{const contents=await storage.get(path);return parser.parseOrThrow(JSON.parse(Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_1__[\"decode\"])(contents)));}catch(e){if(notFound(e)){console.log(\"File not found at path: \".concat(path,\". Defaulting.\"));return def();}else{throw e;}}}/**\n * Read a text file from DataStorage, with a default string value to use if the\n * file is not found. The file is read in the default encoding, UTF-8.\n *\n * This is intended as a convenience for situations where the user may\n * optionally provide configuration in a non-JSON file saved to disk.\n *\n * The default must be provided as a function that returns a default, in\n * case constructing the default may be expensive.\n *\n * If no file is present at that location, then the default constructor is\n * invoked to create a default value, and that is returned.\n *\n * If attempting to load the file fails for any reason other than ENOENT or a\n * 404 (e.g. the path actually is a directory), then the error is thrown.\n */async function loadFileWithDefault(storage,path,def){try{return Object(_core_storage_textEncoding__WEBPACK_IMPORTED_MODULE_1__[\"decode\"])(await storage.get(path));}catch(e){if(notFound(e)){return def();}else{throw e;}}}\n\n//# sourceURL=webpack:///./src/util/storage.js?");

/***/ }),

/***/ "./src/util/taskReporter.js":
/*!**********************************!*\
  !*** ./src/util/taskReporter.js ***!
  \**********************************/
/*! exports provided: LoggingTaskReporter, SilentTaskReporter, ScopedTaskReporter, formatTimeElapsed, startMessage, finishMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoggingTaskReporter\", function() { return LoggingTaskReporter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SilentTaskReporter\", function() { return SilentTaskReporter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScopedTaskReporter\", function() { return ScopedTaskReporter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatTimeElapsed\", function() { return formatTimeElapsed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startMessage\", function() { return startMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"finishMessage\", function() { return finishMessage; });\nfunction _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}const chalk=__webpack_require__(/*! chalk */ \"chalk\");/**\n * This class is a lightweight utility for reporting task progress to the\n * command line.\n *\n * - When a task is started, it's printed to the CLI with a \" GO \" label.\n * - When it's finished, it's printed with a \"DONE\" label, along with the time\n * elapsed.\n * - Tasks are tracked and represented by string id.\n * - The same task id may be re-used after the first task with that id is\n * finished.\n */class LoggingTaskReporter{// Maps the task to the time\nconstructor(consoleLog,getTime){_defineProperty(this,\"activeTasks\",void 0);_defineProperty(this,\"_consoleLog\",void 0);_defineProperty(this,\"_getTime\",void 0);this._consoleLog=consoleLog||console.log;this._getTime=getTime||function(){return+new Date();};this.activeTasks=new Map();}start(taskId){if(this.activeTasks.has(taskId)){throw new Error(\"task \".concat(taskId,\" already registered\"));}this.activeTasks.set(taskId,this._getTime());this._consoleLog(startMessage(taskId));return this;}finish(taskId){const startTime=this.activeTasks.get(taskId);if(startTime==null){throw new Error(\"task \".concat(taskId,\" not registered\"));}const elapsedTime=this._getTime()-startTime;this._consoleLog(finishMessage(taskId,elapsedTime));this.activeTasks.delete(taskId);return this;}}/**\n * SilentTaskReporter is a task reporter that collects some information, but does not\n * emit any visible notifications.\n *\n * It can be used for testing purposes, or as a default TaskReporter for cases where\n * we don't want to default to emitting anything to console.\n *\n * Rather than emitting any messages or taking timing information, it allows retrieving\n * the sequence of task updates that were sent to the reporter.\n * This makes it easy for test code to verify that the TaskReporter was sent the right\n * sequence of tasks.\n *\n * Callers can also check what tasks are still active (e.g. to verify that there are no\n * active tasks unfinished at the end of a method.)\n */class SilentTaskReporter{constructor(){_defineProperty(this,\"_activeTasks\",void 0);_defineProperty(this,\"_entries\",void 0);this._activeTasks=new Set();this._entries=[];}start(taskId){if(this._activeTasks.has(taskId)){throw new Error(\"task \".concat(taskId,\" already active\"));}this._activeTasks.add(taskId);this._entries.push({taskId,type:\"START\"});return this;}finish(taskId){if(!this._activeTasks.has(taskId)){throw new Error(\"task \".concat(taskId,\" not active\"));}this._activeTasks.delete(taskId);this._entries.push({taskId,type:\"FINISH\"});return this;}entries(){return this._entries.slice();}activeTasks(){return Array.from(this._activeTasks);}}/**\n * ScopedTaskReporter is a higher-order task reporter\n * for generating opaque scopes meant to be passed into child contexts.\n *\n * In this case, a scope is a log prefix indicating the parent context\n * in which the current task is running.\n *\n * This allows for reliable filtering and searching on existing tasks\n * by prefix. Care should be taken to ensure that the same prefix does\n * not exist in peer task contexts, so far as error handling is concerned,\n * or a filter may incorrectly catch and finish a still-running task while\n * error-handling. This risk can be mitigated by only designating prefixes via\n * a Scoped Task Reporter, as opposed to passing prefixes into the `start`\n * and `finish` methods manually. For example, this block will always throw:\n *\n * function f(top: SilentTaskReporter) {\n *  top.start(\"my-prefix: foo\");\n *  const scoped = new ScopedTaskReporter(top, \"my-prefix\");\n *  scoped.start(\"foo\"); // Error: task my-prefix: foo already active\n * }\n */class ScopedTaskReporter{constructor(delegate,prefix){_defineProperty(this,\"_delegate\",void 0);_defineProperty(this,\"_prefix\",void 0);this._delegate=delegate;this._prefix=prefix;}_scoped(taskId){return\"\".concat(this._prefix,\": \").concat(taskId);}start(taskId){this._delegate.start(this._scoped(taskId));return this;}finish(taskId){this._delegate.finish(this._scoped(taskId));return this;}}function formatTimeElapsed(elapsed){if(elapsed<0){throw new Error(\"nonegative time expected\");}if(elapsed<10*1000){return\"\".concat(elapsed,\"ms\");}const seconds=Math.round(elapsed/1000);const minutes=Math.floor(seconds/60);if(minutes===0)return\"\".concat(seconds,\"s\");const hours=Math.floor(minutes/60);if(hours===0)return\"\".concat(minutes,\"m \").concat(seconds%60,\"s\");const days=Math.floor(hours/24);if(days===0)return\"\".concat(hours,\"h \").concat(minutes%60,\"m\");return\"\".concat(days,\"d \").concat(hours%24,\"h\");}function startMessage(taskId){const label=chalk.bgBlue.bold.white(\"  GO  \");const message=\"\".concat(label,\" \").concat(taskId);return message;}function finishMessage(taskId,elapsedTimeMs){const elapsed=formatTimeElapsed(elapsedTimeMs);const label=chalk.bgGreen.bold.white(\" DONE \");const message=\"\".concat(label,\" \").concat(taskId,\": \").concat(elapsed);return message;}\n\n//# sourceURL=webpack:///./src/util/taskReporter.js?");

/***/ }),

/***/ "./src/util/timestamp.js":
/*!*******************************!*\
  !*** ./src/util/timestamp.js ***!
  \*******************************/
/*! exports provided: toISO, fromISO, validateTimestampMs, validateTimestampISO, timestampMsParser, timestampISOParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toISO\", function() { return toISO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromISO\", function() { return fromISO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateTimestampMs\", function() { return validateTimestampMs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateTimestampISO\", function() { return validateTimestampISO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"timestampMsParser\", function() { return timestampMsParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"timestampISOParser\", function() { return timestampISOParser; });\n/* harmony import */ var _combo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./combo */ \"./src/util/combo.js\");\n/**\n * We have a convention of using TimestampMs as our default representation.\n * However TimestampISO has the benefit of being human readable / writable,\n * so it's used for serialization and display as well.\n * We'll validate types at runtime, as there's a fair chance we'll use these\n * functions to parse data that came from a Flow `any` type (like JSON).\n */ // A timestamp representation in ms since epoch.\n/**\n * Creates a TimestampISO from a TimestampMs-like input.\n *\n * Since much of the previous types have used `number` as a type instead of\n * TimestampMs. Accepting `number` will give an easier upgrade path, rather\n * than a forced refactor across the codebase.\n */function toISO(timestampLike){const timestampMs=validateTimestampMs(timestampLike);return new Date(timestampMs).toISOString();}/**\n * Creates a TimestampMs from a TimestampISO.\n */function fromISO(timestampISO){if(typeof timestampISO!==\"string\"){throw new TypeError(\"TimestampISO values must be strings, \"+\"received: \".concat(String(timestampISO)));}const parsed=Date.parse(timestampISO);if(Number.isNaN(parsed)){throw new RangeError(\"Could not parse TimestampISO, are you sure it's a valid ISO format? \"+\"received: \".concat(String(timestampISO)));}return parsed;}/**\n * Validate that a number is potentially a valid timestamp.\n *\n * This checks that the number is a finite integer, which avoids some potential\n * numbers that are not valid timestamps.\n */function validateTimestampMs(timestampMs){const asNumber=Number(timestampMs);if(timestampMs===null||timestampMs===undefined||!Number.isInteger(asNumber)){throw new TypeError(\"Numbers representing TimestampMs values must be finite integers, \"+\"received: \".concat(String(timestampMs)));}return new Date(asNumber).valueOf();}function validateTimestampISO(timestampISO){// Verify that it can be converted without throwing an error\nfromISO(timestampISO);return timestampISO;}const timestampMsParser=_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_combo__WEBPACK_IMPORTED_MODULE_0__[\"number\"],validateTimestampMs);const timestampISOParser=_combo__WEBPACK_IMPORTED_MODULE_0__[\"fmap\"](_combo__WEBPACK_IMPORTED_MODULE_0__[\"string\"],validateTimestampISO);\n\n//# sourceURL=webpack:///./src/util/timestamp.js?");

/***/ }),

/***/ "./src/util/uuid.js":
/*!**************************!*\
  !*** ./src/util/uuid.js ***!
  \**************************/
/*! exports provided: random, fromString, parser, delimitedUuidParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromString\", function() { return fromString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parser\", function() { return parser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"delimitedUuidParser\", function() { return delimitedUuidParser; });\n/* harmony import */ var base_64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base-64 */ \"base-64\");\n/* harmony import */ var base_64__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(base_64__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _getRandomValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getRandomValues */ \"./src/util/getRandomValues.js\");\n/* harmony import */ var _combo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./combo */ \"./src/util/combo.js\");\n// Universally unique identifiers. As in the UUID4 spec, we use\n// uniformly random 128-bit payloads, but we represent them more\n// compactly as base64 strings (22 characters long) rather than hex\n// strings (36 characters with a bunch of hyphens). We also ensure that\n// the serialized form is clean for machine and human eyes.\n// Any UUIDs that we generate will be purely alphanumeric and will not\n// contain consecutive pairs of certain letters. Non-alphanumeric base64\n// characters are either +/ or -_, depending on encoding. The former set\n// is not URL-safe, and the latter set is not safe for command line\n// arguments (IDs starting with hyphens) or easy legibility (consecutive\n// hyphens or underscores). Consecutive occurrences of /csfhuit/i are\n// forbidden per a heuristic given by <https://hashids.org/#cursing> to\n// avoid common English curse words.\nconst _RE_UNCLEAN=/[+/\\-_]|[csfhuit]{2}/i;function isClean(s){return!s.match(_RE_UNCLEAN);}// Generate an unpadded base64 string of a uniformly random 128-bit\n// payload. This may be unclean.\nfunction randomUuidUnchecked(){const bytes=Object(_getRandomValues__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(new Uint8Array(16));const blob=[...bytes].map(n=>String.fromCharCode(n)).join(\"\");return Object(base_64__WEBPACK_IMPORTED_MODULE_0__[\"encode\"])(blob).slice(0,-2);// drop \"==\" padding\n}// Generate this many uniformly random UUIDs looking for a clean one.\n// The total failure probability drops off exponentially with each try.\n//\n// To model the probability that `randomUuidUnchecked` emits a clean ID,\n// consider a DFA with three states INIT, DANGER, and FAIL. If we ever\n// see a non-alphanumeric character, go straight to FAIL (which\n// absorbs). If we see one of the characters that must not appear twice\n// consecutively, more from INIT to DANGER or DANGER to FAIL. If we see\n// any other character, move from DANGER back to INIT. Then this is a\n// Markov chain with transitions:\n//\n//   - INIT: 48/64 to INIT, 14/64 to DANGER, 2/64 to FAIL;\n//   - DANGER: 48/64 to INIT, 16/64 to FAIL;\n//   - FAIL: always back to FAIL.\n//\n// A 128-bit payload is base-64 encoded by 21 uniform code units plus\n// one final code unit with less entropy (only 2 bits), but for\n// simplicity we'll just model this as 22 uniform code units, which is\n// very nearly correct. Then the probability of emitting an unclean ID\n// is the probability that after 22 steps in this Markov chain starting\n// from INIT we end up at FAIL---\n//\n//     $ octave --no-gui\n//     >> A = [48 14 2; 48 0 16; 0 0 64] / 64;\n//     >> A^22\n//     ans =\n//\n//        0.15839   0.03738   0.80424\n//        0.12815   0.03024   0.84161\n//        0.00000   0.00000   1.00000\n//\n// ---which is about 80.4%. So any individual attempt is likely to fail,\n// but after five attempts the probability of total failure is only\n// 33.6%, and it drops off exponentially from there.\nconst _MAX_ATTEMPTS=1024;/**\n * Generate a uniformly random clean ID.\n */function random(){for(let i=0;i<_MAX_ATTEMPTS;i++){const result=randomUuidUnchecked();if(isClean(result)){// Because we use rejection sampling, this is uniformly random\n// among clean IDs.\nreturn result;}}// This is vanishingly unlikely (p ~= 10^-97). Something is wrong.\n// istanbul ignore next\nthrow new Error(\"failed to generate clean UUID after \".concat(_MAX_ATTEMPTS,\" attempts\"));}/**\n * Parse a serialized UUID. This is the left inverse of the trivial\n * injection from `Uuid` to `string`, and throws on invalid input.\n */function fromString(s){if(s.endsWith(\"=\")){throw new Error(\"expected unpadded string: \"+JSON.stringify(s));}if(s.length!==22){throw new Error(\"expected length-22 string: \"+JSON.stringify(s));}if(!isClean(s)){throw new Error(\"unclean UUID: \"+JSON.stringify(s)+JSON.stringify(_RE_UNCLEAN.exec(s)));}let bytes;try{bytes=Object(base_64__WEBPACK_IMPORTED_MODULE_0__[\"decode\"])(s);}catch(e){throw new Error(\"invalid base64 string: \"+JSON.stringify(s));}if(Object(base_64__WEBPACK_IMPORTED_MODULE_0__[\"encode\"])(bytes)!==s+\"==\"){// e.g., \"z\" === atob(\"eg\") === atob(\"eh\")\nthrow new Error(\"non-canonical base64 string: \"+JSON.stringify(s));}return s;}/**\n * Parse a serialized UUID. This expects to parse a JSON string value\n * with the same semantics as `fromString`.\n */const parser=_combo__WEBPACK_IMPORTED_MODULE_2__[\"fmap\"](_combo__WEBPACK_IMPORTED_MODULE_2__[\"string\"],fromString);const delimitedUuidParser=_combo__WEBPACK_IMPORTED_MODULE_2__[\"fmap\"](_combo__WEBPACK_IMPORTED_MODULE_2__[\"delimited\"](\"//\"),s=>fromString(s));\n\n//# sourceURL=webpack:///./src/util/uuid.js?");

/***/ }),

/***/ "@sourcecred/grain-integration-csv":
/*!****************************************************!*\
  !*** external "@sourcecred/grain-integration-csv" ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@sourcecred/grain-integration-csv\");\n\n//# sourceURL=webpack:///external_%22@sourcecred/grain-integration-csv%22?");

/***/ }),

/***/ "base-64":
/*!**************************!*\
  !*** external "base-64" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"base-64\");\n\n//# sourceURL=webpack:///external_%22base-64%22?");

/***/ }),

/***/ "better-sqlite3":
/*!*********************************!*\
  !*** external "better-sqlite3" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"better-sqlite3\");\n\n//# sourceURL=webpack:///external_%22better-sqlite3%22?");

/***/ }),

/***/ "big-integer":
/*!******************************!*\
  !*** external "big-integer" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"big-integer\");\n\n//# sourceURL=webpack:///external_%22big-integer%22?");

/***/ }),

/***/ "bottleneck":
/*!*****************************!*\
  !*** external "bottleneck" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"bottleneck\");\n\n//# sourceURL=webpack:///external_%22bottleneck%22?");

/***/ }),

/***/ "chalk":
/*!************************!*\
  !*** external "chalk" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"chalk\");\n\n//# sourceURL=webpack:///external_%22chalk%22?");

/***/ }),

/***/ "commonmark":
/*!*****************************!*\
  !*** external "commonmark" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"commonmark\");\n\n//# sourceURL=webpack:///external_%22commonmark%22?");

/***/ }),

/***/ "commonmark/lib/common":
/*!****************************************!*\
  !*** external "commonmark/lib/common" ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"commonmark/lib/common\");\n\n//# sourceURL=webpack:///external_%22commonmark/lib/common%22?");

/***/ }),

/***/ "cross-fetch":
/*!******************************!*\
  !*** external "cross-fetch" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"cross-fetch\");\n\n//# sourceURL=webpack:///external_%22cross-fetch%22?");

/***/ }),

/***/ "d3-array":
/*!***************************!*\
  !*** external "d3-array" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"d3-array\");\n\n//# sourceURL=webpack:///external_%22d3-array%22?");

/***/ }),

/***/ "d3-format":
/*!****************************!*\
  !*** external "d3-format" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"d3-format\");\n\n//# sourceURL=webpack:///external_%22d3-format%22?");

/***/ }),

/***/ "d3-time":
/*!**************************!*\
  !*** external "d3-time" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"d3-time\");\n\n//# sourceURL=webpack:///external_%22d3-time%22?");

/***/ }),

/***/ "deep-freeze":
/*!******************************!*\
  !*** external "deep-freeze" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"deep-freeze\");\n\n//# sourceURL=webpack:///external_%22deep-freeze%22?");

/***/ }),

/***/ "entities":
/*!***************************!*\
  !*** external "entities" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"entities\");\n\n//# sourceURL=webpack:///external_%22entities%22?");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"express\");\n\n//# sourceURL=webpack:///external_%22express%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "fs-extra":
/*!***************************!*\
  !*** external "fs-extra" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs-extra\");\n\n//# sourceURL=webpack:///external_%22fs-extra%22?");

/***/ }),

/***/ "globby":
/*!*************************!*\
  !*** external "globby" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"globby\");\n\n//# sourceURL=webpack:///external_%22globby%22?");

/***/ }),

/***/ "htmlparser2":
/*!******************************!*\
  !*** external "htmlparser2" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"htmlparser2\");\n\n//# sourceURL=webpack:///external_%22htmlparser2%22?");

/***/ }),

/***/ "isomorphic-fetch":
/*!***********************************!*\
  !*** external "isomorphic-fetch" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"isomorphic-fetch\");\n\n//# sourceURL=webpack:///external_%22isomorphic-fetch%22?");

/***/ }),

/***/ "json-stable-stringify":
/*!****************************************!*\
  !*** external "json-stable-stringify" ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"json-stable-stringify\");\n\n//# sourceURL=webpack:///external_%22json-stable-stringify%22?");

/***/ }),

/***/ "json2csv":
/*!***************************!*\
  !*** external "json2csv" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"json2csv\");\n\n//# sourceURL=webpack:///external_%22json2csv%22?");

/***/ }),

/***/ "lodash.clonedeep":
/*!***********************************!*\
  !*** external "lodash.clonedeep" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"lodash.clonedeep\");\n\n//# sourceURL=webpack:///external_%22lodash.clonedeep%22?");

/***/ }),

/***/ "lodash.findlast":
/*!**********************************!*\
  !*** external "lodash.findlast" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"lodash.findlast\");\n\n//# sourceURL=webpack:///external_%22lodash.findlast%22?");

/***/ }),

/***/ "lodash.findlastindex":
/*!***************************************!*\
  !*** external "lodash.findlastindex" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"lodash.findlastindex\");\n\n//# sourceURL=webpack:///external_%22lodash.findlastindex%22?");

/***/ }),

/***/ "lodash.isequal":
/*!*********************************!*\
  !*** external "lodash.isequal" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"lodash.isequal\");\n\n//# sourceURL=webpack:///external_%22lodash.isequal%22?");

/***/ }),

/***/ "lodash.sortedindex":
/*!*************************************!*\
  !*** external "lodash.sortedindex" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"lodash.sortedindex\");\n\n//# sourceURL=webpack:///external_%22lodash.sortedindex%22?");

/***/ }),

/***/ "pako":
/*!***********************!*\
  !*** external "pako" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"pako\");\n\n//# sourceURL=webpack:///external_%22pako%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack:///external_%22util%22?");

/***/ }),

/***/ "web3-utils":
/*!*****************************!*\
  !*** external "web3-utils" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"web3-utils\");\n\n//# sourceURL=webpack:///external_%22web3-utils%22?");

/***/ })

/******/ });
});